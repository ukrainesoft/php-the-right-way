# [PHP *Правильний шлях*](/)

[Останнє оновлення: 2022-08-24 13:23:57 +0000](https://github.com/codeguy/php-the-right-way/commit/67bb04ce9db36d9e54afc9edabd9ec1c8e54bda9)

[Поділитися в Twitter](https://twitter.com/intent/tweet?text=PHP+The+Right+Way&url=https%3A%2F%2Fwww.phptherightway.com&hashtags=PHP)

[](https://github.com/codeguy/php-the-right-way)

# <a name="top"></a> Зміст

-   [Ласкаво просимо](#welcome)
    -   [Переклади](#translations)
    -   [Книга](#book)
    -   [Як зробити внесок](#how-to-contribute)
-   [Починаємо](#getting_started)
    -   [Використовуйте поточну стабільну версію (8.1)](#use_the_current_stable_version)
    -   [Вбудований веб-сервер](#builtin_web_server)
    -   [Налаштування Mac](#mac_setup)
    -   [Налаштування Windows](#windows_setup)
    -   [Загальна структура каталогу](#common_directory_structure)
-   [Керівництво по стилю коду](#code_style_guide)
-   [Основні моменти мови](#language_highlights)
    -   [Парадигми програмування](#programming_paradigms)
    -   [Простори імен](#namespaces)
    -   [Стандартна бібліотека PHP](#standard_php_library)
    -   [Інтерфейс командного рядка](#command_line_interface)
    -   [Xdebug](#xdebug)
-   [Управління залежностями](#dependency_management)
    -   [Composer & Packagist](#composer_and_packagist)
    -   [PEAR](#pear)
-   [Практики кодування](#coding_practices)
    -   [Основи](#the_basics)
    -   [Дата і час](#date_and_time)
    -   [Шаблони проєктування](#design_patterns)
    -   [Робота з UTF-8](#php_and_utf8)
    -   [Інтернаціоналізація та локалізація](#i18n_l10n)
-   [Ін'єкція залежності](#dependency_injection)
    -   [Основна концепція](#basic_concept)
    -   [Комплексна проблема](#complex_problem)
    -   [Контейнери](#containers)
    -   [Подальше читання](#further_reading)
-   [Бази даних](#databases)
    -   [Розширення MySQL](#mysql_extension)
    -   [Розширення PDO](#pdo_extension)
    -   [Взаємодія з базами даних](#databases_interacting)
    -   [Шари абстракції](#databases_abstraction_layers)
-   [Шаблонування](#templating)
    -   [Переваги](#templating_benefits)
    -   [Звичайні PHP шаблони](#plain_php_templates)
    -   [Скомпільовані шаблони](#compiled_templates)
    -   [Подальше читання](#templating_further_reading)
-   [Помилки та винятки](#errors_and_exceptions)
    -   [Помилки](#errors)
    -   [Винятки](#exceptions)
-   [Безпека](#security)
    -   [Безпека веб-додатків](#web_application_security)
    -   [Хешування пароля](#password_hashing)
    -   [Фільтрування даних](#data_filtering)
    -   [Файли конфігурації](#configuration_files)
    -   [Реєстрація Globals](#register_globals)
    -   [Звіт про помилку](#error_reporting)
-   [Тестування](#testing)
    -   [Розробка, орієнтована на тестування](#test_driven_development)
    -   [Розвиток, орієнтований на поведінку](#behavior_driven_development)
    -   [Додаткові засоби тестування](#complementary_testing_tools)
-   [Сервери та розгортання](#servers_and_deployment)
    -   [Платформа як послуга (PaaS)](#platform_as_a_service)
    -   [Віртуальні або виділені сервери](#virtual_or_dedicated_servers)
    -   [Спільні сервери](#shared_servers)
    -   [Створення вашої програми](#building_and_deploying_your_application)
-   [Віртуалізація](#virtualization)
    -   [Vagrant](#vagrant)
    -   [Docker](#docker)
-   [Кешування](#caching)
    -   [Кеш коду операції](#opcode_cache)
    -   [Кешування об'єктів](#object_caching)
-   [Документування вашого коду](#documenting)
    -   [PHPDoc](#phpdoc)
-   [Ресурси](#resources)
    -   [Від Джерела](#from_the_source)
    -   [Люди, за якими слід слідкувати](#people_to_follow)
    -   [Постачальники PHP PaaS](#php_paas_providers)
    -   [Каркаси](#frameworks)
    -   [Компоненти](#components)
    -   [Інші корисні ресурси](#other_resources)
    -   [Відеоуроки](#videos)
    -   [Книги](#books)
-   [Спільнота](#community)
    -   [Групи користувачів](#user_groups)
    -   [Конференції](#conferences)
    -   [Слони](#elephpants)
-   [Кредити](#credits)
    

# <a name="welcome"></a>Ласкаво просимо

У мережі є багато застарілої інформації, яка вводить нових користувачів PHP в оману, поширюючи погані практики та небезпечний код. *PHP: правильний шлях* це легкий для читання, короткий довідник для популярних стандартів кодування PHP, посилання на авторитетні навчальні посібники в Інтернеті та те, що учасники вважають найкращими практиками на даний момент.

*Не існує канонічного способу використання PHP*. Цей веб-сайт має на меті познайомити нових розробників PHP із деякими темами, які вони можуть не відкрити, доки не стане занадто пізно, і має на меті дати досвідченим професіоналам кілька свіжих ідей щодо тих тем, якими вони займалися роками, ніколи не переглядаючи їх. Цей веб-сайт також не скаже вам, які інструменти використовувати, натомість пропонує пропозиції щодо кількох варіантів, де це можливо, пояснюючи відмінності в підходах і варіантах використання.

Це живий документ, який буде продовжувати оновлюватися більш корисною інформацією та прикладами, коли вони стануть доступними.

## <a name="translations"></a>Переклади

*PHP: правильний шлях* перекладається багатьма різними мовами:

-   [англійська](http://www.phptherightway.com)
-   [Español](http://phpdevenezuela.github.io/php-the-right-way)
-   [Français](http://eilgin.github.io/php-the-right-way/)
-   [Індонезія](http://id.phptherightway.com)
-   [Italiano](http://it.phptherightway.com)
-   [Polski](http://pl.phptherightway.com)
-   [Português do Brasil](http://br.phptherightway.com)
-   [Română](https://bgui.github.io/php-the-right-way/)
-   [Словенщина](http://sl.phptherightway.com)
-   [Srpski](http://phpsrbija.github.io/php-the-right-way/)
-   [турецька](http://hkulekci.github.io/php-the-right-way/)
-   [български](http://bg.phptherightway.com)
-   [Русский язык](http://getjump.github.io/ru-php-the-right-way)
-   [Українська](http://iflista.github.io/php-the-right-way/)
-   [العربية](https://adaroobi.github.io/php-the-right-way/)
-   [فارسى](http://novid.github.io/php-the-right-way/)
-   [ภาษาไทย](https://apzentral.github.io/php-the-right-way/)
-   [한국어판](http://modernpug.github.io/php-the-right-way)
-   [日本語](http://ja.phptherightway.com)
-   [简体中文](https://laravel-china.github.io/php-the-right-way/)
-   [繁體中文](https://laravel-taiwan.github.io/php-the-right-way)

## <a name="book"></a>Книга

Остання версія *PHP: правильний шлях* також доступна у форматах PDF, EPUB і MOBI. [Перейти до Leanpub](https://leanpub.com/phptherightway)

## <a name="how-to-contribute"></a>Як зробити внесок

Допоможіть зробити цей веб-сайт найкращим ресурсом для початківців PHP-програмістів! [Зробіть внесок на GitHub](https://github.com/ukrainesoft/php-the-right-way/edit/master/README.md)

[Догори](#top)

# <a name="getting_started"></a>Починаємо

## <a name="use_the_current_stable_version"></a>Використовуйте поточну стабільну версію (8.1)

Якщо ви починаєте працювати з PHP, почніть із поточної стабільної версії [PHP 8.1](https://php.net/downloads.md). PHP 8.x додає багато [нових можливостей](#language_highlights) над старішими версіями 7.x і 5.x. Двигун був значною мірою переписаний, і PHP тепер навіть швидший, ніж попередні версії. PHP 8 — це велике оновлення мови, яке містить багато нових функцій і оптимізацій.

Спробуйте швидко оновитися до останньої стабільної версії PHP 7.4. [Його підтримка вже закінчилася](https://php.org.ua/manual/uk/supported-versions.md). Оновити легко, оскільки там небагато [порушень зворотньої сумісністі](https://php.org.ua/manual/uk/migration81.incompatible.md). Якщо ви не впевнені, у якій версії є функція або функціонал, ви можете перевірити документацію PHP на веб-сайті [php.org.ua](https://php.org.ua/manual/uk/index.md) .

## <a name="builtin_web_server"></a>Вбудований веб-сервер

З PHP 5.4 або новішої версії ви можете почати вивчати PHP без встановлення та налаштування повноцінного веб-сервера. Щоб запустити сервер, запустіть таку команду з терміналу в кореневій папці вашого проєкту:

```console
> php -S localhost:8000
```

-   [Дізнайтеся про вбудований веб-сервер командного рядка](https://php.org.ua/manual/uk/features.commandline.webserver.md)

## <a name="mac_setup"></a>Налаштування Mac

macOS постачається в комплекті з PHP, але зазвичай він трохи відстає від останнього стабільного випуску. Є кілька способів інсталювати останню версію PHP на macOS.

### Встановіть PHP через Homebrew

[Homebrew](https://brew.sh/) — це менеджер пакунків для macOS, який допомагає легко встановити PHP і різні розширення. Базовий репозиторій Homebrew містить «формули» для PHP 5.6, 7.0, 7.1, 7.2, 7.3, 7.4, 8.0 і PHP 8.1. Встановіть останню версію за допомогою цієї команди:

```
brew install php@8.1
```

Ви можете переключатися між версіями PHP Homebrew, змінюючи свою змінну `PATH`. Як варіант, ви можете використовувати [brew-php-switcher](https://github.com/philcook/brew-php-switcher) щоб автоматично перемикати версії PHP.

Ви також можете перемикатися між версіями PHP вручну, від’єднавши та зв’язавши потрібну версію:

```
brew unlink php
brew link --overwrite php@8.0
```

```
brew unlink php
brew link --overwrite php@8.1
```

### Встановіть PHP через Macports

The [MacPorts](https://www.macports.org/install.md) Project — це ініціатива спільноти з відкритим вихідним кодом, спрямована на розробку простої у використанні системи для компіляції, встановлення та оновлення програмного забезпечення з відкритим кодом на базі командного рядка, X11 або Aqua в операційній системі OS X.

MacPorts підтримує попередньо скомпільовані бінарні файли, тому вам не потрібно перекомпілювати кожну залежність із вихідних архівних файлів, це рятує ваше життя, якщо у вашій системі не встановлено жодного пакета.

На цьому етапі можна встановити `php54`, `php55`, `php56`, `php70`, `php71`, `php72`, `php73`, `php74`, `php80` або `php81` використовуючи команду `port install`, наприклад:

```
sudo port install php74
sudo port install php81
```

І можна запустити команду `select` для перемикання активного PHP:

```
sudo port select --set php php81
```

### Встановіть PHP через phpbrew

[phpbrew](https://github.com/phpbrew/phpbrew) - це інструмент для встановлення та керування кількома версіями PHP. Це може бути дуже корисно, якщо дві різні програми/проєкти потребують різних версій PHP, і ви не використовуєте віртуальні машини.

### Встановіть PHP за допомогою бінарного інсталятора Liip

Ще один популярний варіант [php-osx.liip.ch](https://php-osx.liip.ch/) який надає один метод встановлення вкладки для версій 5.3–7.3. Він не перезаписує бінарні файли PHP, встановлені Apple, але інсталює все в окремому місці (/usr/local/php5).

### Скомпілювати з вихідного коду

Інший варіант, який дає вам контроль над версією PHP, яку ви встановлюєте, це [зібрати його самостійно](https://php.org.ua/manual/uk/install.macosx.md). У такому випадку переконайтеся, що встановлено [Xcode](https://github.com/kennethreitz/osx-gcc-installer) або замінник Apple [«Інструменти командного рядка для XCode»](https://developer.apple.com/downloads), який можна завантажити з Apple Mac Developer Center.

### Універсальні інсталятори

Рішення, перелічені вище, в основному обробляють сам PHP і не надають таких речей як [Apache](https://httpd.apache.org/), [Nginx](https://www.nginx.com/) або сервер SQL. Рішення «все в одному», такі як [MAMP](https://www.mamp.info/en/downloads/) і [XAMPP](https://www.apachefriends.org/index.html) встановить ці частини програмного забезпечення для вас і зв’яже їх усі разом, але легкість налаштування приходить із компромісом гнучкості.

## <a name="windows_setup"></a>Налаштування Windows

Ви можете завантажити бінарні файли з [http://windows.php.net/download/](http://windows.php.net/download/). Після вилучення PHP рекомендується встановити [PATH](http://www.windows-commandline.com/set-path-command-line/) у корінь вашої папки PHP (де знаходиться php.exe), щоб ви могли виконувати PHP з будь-якого місця.

Для навчання та локальної розробки ви можете використовувати вбудований веб-сервер із PHP 5.4+, тому вам не потрібно турбуватися про його налаштування. Якщо вам потрібен «все-в-одному», який включає повномасштабний веб-сервер і MySQL, тоді використовуйте такі інструменти, як [XAMPP](http://www.apachefriends.org/en/xampp.html), [EasyPHP](http://www.easyphp.org/), [OpenServer](http://open-server.ru/) і [WAMP](http://www.wampserver.com/en/), що допоможе швидко запустити середовище розробки для Windows. Тим не менш, ці інструменти будуть дещо відрізнятися від робочих, тому будьте обережні з відмінностями середовища, якщо ви програмуєте в Windows, а розгортаєте ваш застосунок у Linux.

Якщо вам потрібно запустити робочу систему на Windows, IIS7 забезпечить вам найстабільнішу та найкращу продуктивність. Ви можете використовувати [phpmanager](http://phpmanager.codeplex.com/) (плагін графічного інтерфейсу для IIS7), щоб спростити налаштування та керування PHP. IIS7 поставляється з вбудованим і готовим до роботи FastCGI, вам просто потрібно налаштувати PHP як обробник. Для підтримки та додаткових ресурсів є [виділена область на iis.net](http://php.iis.net/) для PHP.

Як правило, запуск вашої програми в різних середовищах розробки та продакшену може призвести до появи дивних помилок під час її запуску. Якщо ви розробляєте на Windows і розгортаєте Linux (або будь-що інше, що не є Windows), вам слід розглянути можливість використання [Віртуальної машини](#virtualization_title).

Кріс Танкерслі має дуже корисну публікацію в блозі про те, які інструменти він використовує для [Розробки PHP за допомогою Windows](http://ctankersley.com/2016/11/13/developing-on-windows-2016/).

## <a name="common_directory_structure"></a>Загальна структура каталогу

Поширене питання серед тих, хто починає писати програми для Інтернету: «куди мені розмістити свої скрипти?» Протягом багатьох років ця відповідь незмінно була «туди, де ваш `DocumentRoot`». Хоча ця відповідь не є повною, це чудове місце для початку.

З міркувань безпеки файли конфігурації не повинні бути доступні для відвідувачів сайту; тому загальнодоступні скрипти зберігаються у загальнодоступному каталозі, а приватні конфігурації та дані зберігаються за межами цього каталогу.

Для кожної команди, CMS або фреймворку, у якому працює ваша программа, використовується стандартна структура каталогу. Однак, якщо хтось починає робити проєкт сам з нуля, то складно дізнатись, яку сами структуру файлової системи використовувати.

[Пол М. Джонс](http://paul-m-jones.com/) провів фантастичне дослідження загальних практик десятків тисяч проєктів з github у сфері PHP. Він скомпільував стандартну структуру файлів і каталогів, [Скелет стандартного пакету PHP](https://github.com/php-pds/skeleton), на основі цього дослідження. У цій структурі каталогу `DocumentRoot` має вказувати на `public/`, модульні тести повинні бути в `tests/` каталог і бібліотеки сторонніх розробників, встановлені через [composer](#composer_and_packagist), належать до каталогу `vendor/`. Для інших файлів і каталогів, слід дотримуватись [Скелету стандартного пакету PHP](https://github.com/php-pds/skeleton), це буде мати найбільший сенс для всіх учасників проєкту.

[Догори](#top)

# <a name="code_style_guide"></a>Керівництво по стилю коду

Спільнота PHP велика й різноманітна, складається з незліченних бібліотек, фреймворків і компонентів. Розробники PHP зазвичай вибирають декілька з них і об’єднують їх в один проєкт. Важливо, щоб PHP-код відповідав (якомога ближче) загальному стилю коду, щоб розробникам було легко змішувати та поєднувати різні бібліотеки для своїх проєктів.

The [Framework Interop Group](https://www.php-fig.org/) запропонував і схвалив низку рекомендацій щодо стилю. Не всі з них стосуються стилю коду, але ті, що стосуються [PSR-1](https://www.php-fig.org/psr/psr-1/), [PSR-12](https://www.php-fig.org/psr/psr-12/) і [PSR-4](https://www.php-fig.org/psr/psr-4/). Ці рекомендації є лише набором правил, які застосовують багато проєктів, як-от Drupal, Zend, Symfony, Laravel, CakePHP, phpBB, AWS SDK, FuelPHP, Lithium тощо. Ви можете використовувати їх для власних проєктів або продовжувати використовувати свій особистий стиль.

В ідеалі ви повинні написати код PHP, який відповідає відомому стандарту. Це може бути будь-яка комбінація PSR або один зі стандартів кодування PEAR або Zend. Це означає, що інші розробники можуть легко читати ваш код і працювати з ним, а програми, які реалізують компоненти, можуть мати узгодженість навіть при роботі з великою кількістю коду сторонніх розробників.

-   [Читайте про PSR-1](https://www.php-fig.org/psr/psr-1/)
-   [Читайте про PSR-12](https://www.php-fig.org/psr/psr-12/)
-   [Читайте про PSR-4](https://www.php-fig.org/psr/psr-4/)
-   [Прочитайте про стандарти кодування PEAR](https://pear.php.net/manual/en/standards.md)
-   [Прочитайте про стандарти кодування Symfony](https://symfony.com/doc/current/contributing/code/standards.html)

Ви можете використовувати [PHP\_CodeSniffer](https://pear.php.net/package/PHP_CodeSniffer/) щоб перевірити код на відповідність будь-якій із цих рекомендацій, і плагіни для текстових редакторів, як-от [Sublime Text](https://github.com/benmatselby/sublime-phpcs), щоб отримати зворотний зв’язок у реальному часі.

Ви можете автоматично виправити структуру коду за допомогою одного з таких інструментів:

-   Одним є [PHP Coding Standards Fixer](https://cs.symfony.com/) який має дуже добре перевірену кодову базу.
-   Крім того, [PHP Code Beautifier and Fixer](https://github.com/squizlabs/PHP_CodeSniffer/wiki/Fixing-Errors-Automatically) інструмент, який входить до складу PHP\_CodeSniffer можна використовувати для відповідного налаштування коду.

І ви можете запустити phpcs вручну з оболонки:

```
phpcs -sw --standard=PSR1 file.php
```

Він покаже помилки та опише, як їх виправити. Також може бути корисним включити цю команду в git hook. Таким чином, гілки, які містять порушення вибраного стандарту, не зможуть увійти до репозіторія, доки порушення не будуть усунені.

Якщо у вас є PHP\_CodeSniffer, тоді ви можете автоматично виправити проблеми з компонуванням коду, про які він повідомляє, за допомогою [PHP Code Beautifier and Fixer](https://github.com/squizlabs/PHP_CodeSniffer/wiki/Fixing-Errors-Automatically).

```
phpcbf -w --standard=PSR1 file.php
```

Іншим варіантом є використання [PHP Coding Standards Fixer](https://cs.symfony.com/). Він покаже, які типи помилки були в структурі коду до їх виправлення.

```
php-cs-fixer fix -v --rules=@PSR1 file.php
```

Англійська мова є переважною для всіх назв, символів та кодової інфраструктури. Коментарі можуть бути написані будь-якою мовою, легкою для читання всіма поточними та майбутніми сторонами, які можуть працювати над кодовою базою.

Нарешті, хороший додатковий ресурс для написання чистого коду PHP [Чистий код PHP](https://github.com/jupeter/clean-code-php).

[Догори](#top)

# <a name="language_highlights"></a>Основні моменти мови

## <a name="programming_paradigms"></a>Парадигми програмування

PHP — це гнучка динамічна мова, яка підтримує різноманітні техніки програмування. Протягом багатьох років він різко розвивався, особливо додавши міцну об’єктно-орієнтовану модель у PHP 5.0 (2004), анонімні функції та простори імен у PHP 5.3 (2009) і трейти в PHP 5.4 (2012).

### Об'єктно-орієнтоване програмування

PHP має повний набір функцій об’єктно-орієнтованого програмування, включаючи підтримку класів, абстрактних класів, інтерфейсів, успадкування, конструкторів, клонування, винятків тощо.

-   [Прочитайте про об’єктно-орієнтований PHP](https://php.org.ua/manual/uk/language.oop5.md)
-   [Читайте про трейти](https://php.org.ua/manual/uk/language.oop5.traits.md)

### Функціональне програмування

PHP підтримує функції першого класу, тобто функцію можна призначити змінній. Як визначені користувачем, так і вбудовані функції можуть посилатися на змінну та викликатися динамічно. Функції можна передавати як аргументи іншим функціям (це функція називається *Функції вищого порядку*) і функції можуть повертати інші функції.

Рекурсія, функція, яка дозволяє функції викликати саму себе, підтримується мовою, але більшість коду PHP зосереджено на ітераціях.

Нові анонімні функції (з підтримкою замикань) присутні з PHP 5.3 (2009).

У PHP 5.4 додано можливість прив’язувати замикання до області видимості об’єкта, а також покращено підтримку викликів, щоб їх можна було використовувати як взаємозамінні з анонімними функціями майже в усіх випадках.

-   Продовжуйте читати далі про [Функціональне програмування на PHP](https://phptherightway.com/pages/Functional-Programming.html)
-   [Прочитайте про анонімні функції](https://php.org.ua/manual/uk/functions.anonymous.md)
-   [Прочитайте про клас Closure](https://php.org.ua/manual/uk/class.closure.md)
-   [Докладніше в Closures RFC](https://wiki.php.net/rfc/closures)
-   [Прочитайте про Callables](https://php.org.ua/manual/uk/language.types.callable.md)
-   [Прочитайте про динамічний виклик функцій за допомогою `call_user_func_array()`](https://php.org.ua/manual/uk/function.call-user-func-array.md)

### Мета програмування

PHP підтримує різні форми метапрограмування за допомогою таких механізмів, як Reflection API і Magic Methods. Існує багато магічних методів, таких як `__get()`, `__set()`, `__clone()`, `__toString()`, `__invoke()` тощо, які дозволяють розробникам підключатися до поведінки класу. Розробники Ruby часто кажуть, що PHP не вистачає `method_missing`, але він доступний як `__call()` і `__callStatic()`.

-   [Читайте про магічні методи](https://php.org.ua/manual/uk/language.oop5.magic.md)
-   [Читайте про Reflection](https://php.org.ua/manual/uk/intro.reflection.md)
-   [Прочитайте про перевантаження](https://php.org.ua/manual/uk/language.oop5.overloading.md)

## <a name="namespaces"></a>Простори імен

Як згадувалося вище, спільнота PHP має багато розробників, які створюють багато коду. Це означає, що PHP-код однієї бібліотеки може використовувати те саме ім’я класу, що й інший. Коли обидві бібліотеки використовуються в одному просторі імен, вони стикаються та спричиняють проблеми.

*Простори імен* потрібні, щоб вирішити цю проблему. Як описано в довідковому посібнику PHP, простори імен можна порівняти з каталогами операційної системи, які *розділяють* файли; два файли з однаковою назвою можуть співіснувати в окремих каталогах. Подібним чином два класи PHP з однаковою назвою можуть співіснувати в окремих просторах імен PHP. Ось так просто.

Для вас важливо створити простір імен для свого коду, щоб його могли використовувати інші розробники, не боячись зіткнення з іншими бібліотеками.

Один із рекомендованих способів використання просторів імен викладено в [PSR-4](https://www.php-fig.org/psr/psr-4/), який має на меті забезпечити стандартний файл, клас і простір імен, щоб дозволити підключити ваш код.

У жовтні 2014 року PHP-FIG скасував попередній стандарт автозавантаження: [PSR-0](https://www.php-fig.org/psr/psr-0/). І PSR-0, і PSR-4 досі цілком придатні для використання. Для останнього потрібен PHP 5.3, тому багато проєктів реалізують PSR-0 лише для PHP 5.2.

Якщо ви збираєтеся використовувати стандарт автозавантажувача для нової програми чи пакета, подивіться на PSR-4.

-   [Прочитайте про простори імен](https://php.org.ua/manual/uk/language.namespaces.md)
-   [Читайте про PSR-0](https://www.php-fig.org/psr/psr-0/)
-   [Читайте про PSR-4](https://www.php-fig.org/psr/psr-4/)

## <a name="standard_php_library"></a>Стандартна бібліотека PHP

Стандартна бібліотека PHP (SPL), якою укомплектована PHP, надає набір класів та інтерфейсів. Він складається в основному із типових класів структур даних (стек, черга, купа тощо) та ітераторів, які можуть проходити через ці структури даних або ваших власних класів, які реалізують інтерфейси SPL.

-   [Прочитайте про SPL](https://php.org.ua/manual/uk/book.spl.md)
-   [Відеокурс SPL на Lynda.com (платний)](https://www.lynda.com/PHP-tutorials/Up-Running-Standard-PHP-Library/175038-2.html)

## <a name="command_line_interface"></a>Інтерфейс командного рядка

PHP був створений для написання веб-додатків, але також корисний для створення сценаріїв програм інтерфейсу командного рядка (CLI). Програми командного рядка PHP можуть допомогти автоматизувати типові завдання, такі як тестування, розгортання та адміністрування додатків.

Програми CLI PHP є потужними, тому що ви можете використовувати код своєї програми безпосередньо без необхідності створювати та захищати графічний веб-інтерфейс користувача. Просто будь впевнений що **не** розміститив свої сценарії CLI PHP у загальнодоступному веб-корені!

Спробуйте запустити PHP з командного рядка:

```console
> php -i
```

The `-i` опція надрукує вашу конфігурацію PHP так само, як і функція [`phpinfo()`](https://php.org.ua/manual/uk/function.phpinfo.md).

The `-a` опція надає інтерактивну оболонку, подібну до IRB, що є в Ruby або інтерактивної оболонки python. Є ряд інших корисних [параметрів командного рядку](https://php.org.ua/manual/uk/features.commandline.options.md).

Давайте напишемо просту програму CLI «Hello, $name». Щоб спробувати, створіть файл під назвою `hello.php`, як зазначено нижче.

```php
<?php
if ($argc !== 2) {
    echo "Usage: php hello.php <name>". PHP_EOL;
    exit(1);
}
$name = $argv[1];
echo "Hello, $name". PHP_EOL;
```

PHP встановлює дві спеціальні змінні на основі аргументів, з якими виконується ваш сценарій. [`$argc`](https://php.org.ua/manual/uk/reserved.variables.argc.md) є цілочисельною змінною, що містить *кількість* аргументів і [`$argv`](https://php.org.ua/manual/uk/reserved.variables.argv.md) - це змінна масиву, що містить *значення* кожного аргументу. У цьому випадку першим аргументом завжди є ім’я вашого файлу сценарію PHP `hello.php`.

Вираз `exit()` використовується з ненульовим числом, щоб повідомити оболонці, що команда не виконана. Можна знайти типові коди виходу [тут](https://www.gsp.com/cgi-bin/man.cgi?section=3&topic=sysexits).

Щоб запустити наш сценарій, наведений вище, з командного рядка:

```console
> php hello.php
Usage: php hello.php <name>
> php hello.php world
Hello, world
```

-   [Дізнайтеся про запуск PHP з командного рядка](https://php.org.ua/manual/uk/features.commandline.options.md)

## <a name="xdebug"></a>Xdebug

Одним із найкорисніших інструментів у розробці програмного забезпечення є належний відладчик. Він дозволяє відстежувати виконання вашого коду та стежити за вмістом стека. Xdebug, дебаггер PHP, може використовуватися різними IDE для встановлення точок зупину та перевірки стека. Це також може дозволити таким інструментам, як PHPUnit і KCacheGrind, виконувати аналіз покриття коду та профілювання коду.

Якщо ви опинилися в безвиходній ситуації й готові вдатися до `var_dump()`/`print_r()`, і ви все ще не можете знайти рішення - можливо, вам потрібно скористатися дебаггером.

[Встановлення Xdebug](https://xdebug.org/docs/install) може бути складним, але однією з його найважливіших функцій є «Віддалене налагодження» — якщо ви розробляєте код локально, а потім тестуєте його всередині віртуальної машини або на іншому сервері, віддалене налагодження — це функція, яку ви захочете ввімкнути відразу.

Традиційно ви змінюєте файл Apache VHost або .htaccess із такими значеннями:

```ini
php_value xdebug.remote_host 192.168.?.?
php_value xdebug.remote_port 9000
```

«Віддалений хост» і «віддалений порт» відповідатимуть вашому локальному комп’ютеру та порту, на який ви налаштували IDE для прослуховування. Потім потрібно лише перевести IDE у режим «прослуховування з’єднань» і завантажити URL-адресу:

```
http://your-website.example.com/index.php?XDEBUG_SESSION_START=1
```

Ваша IDE тепер перехоплюватиме поточний стан під час виконання сценарію, дозволяючи встановлювати точки зупину та перевіряти значення в пам’яті.

Графічні налагоджувачі дозволяють дуже легко проходити код, перевіряти змінні та оцінювати код у порівнянні з живим середовищем виконання. Багато IDE мають вбудовану підтримку або підтримку графічного дебаггера за допомогою Xdebug. MacGDBp — це безкоштовний автономний графічний інтерфейс Xdebug із відкритим кодом для Mac.

-   [Дізнайтеся більше про Xdebug](https://xdebug.org/docs/)
-   [Дізнайтеся більше про MacGDBp](https://www.bluestatic.org/software/macgdbp/)

[Догори](#top)

# <a name="dependency_management"></a>Управління залежностями

Існує маса бібліотек PHP, фреймворків і компонентів на вибір. Ваш проєкт, імовірно, використовуватиме декілька з них — це залежності проєкту. Донедавна PHP не мав хорошого способу керування цими залежностями проєкту. Навіть якщо ви керували ними вручну, вам все одно доводилося турбуватися про автозавантажувачі. Зараз це вже не проблема.

На даний момент існує дві основні системи керування пакетами для PHP - [Composer](#composer_and_packagist) і [PEAR](#pear). Composer наразі є найпопулярнішим менеджером пакетів для PHP, однак протягом тривалого часу PEAR був основним менеджером пакунків у використанні. Знати історію PEAR — гарна ідея, оскільки ви все одно можете знайти посилання на неї, навіть якщо ніколи нею не користуєтесь.

## <a name="composer_and_packagist"></a>Composer і Packagist

Composer — рекомендований менеджер залежностей для PHP. Перелічіть залежності вашого проєкту в `composer.json` файлі і за допомогою кількох простих команд Composer автоматично завантажить залежності вашого проєкту та налаштує автозавантаження для вас. Composer аналогічний NPM у світі node.js або Bundler у світі Ruby.

Існує безліч бібліотек PHP, які сумісні з Composer і готові до використання у вашому проєкті. Ці «пакети» перераховані на сайті [Packagist](https://packagist.org/), офіційному сховищі бібліотек PHP, сумісних із Composer.

### Як встановити Composer

Найбезпечніший спосіб завантажити composer — [дотримуючись офіційних інструкцій](https://getcomposer.org/download/). Це дозволить переконатися, що програму встановлення не пошкоджено чи не змінено. Інсталятор встановлює `composer.phar` бінарний файл у вашому *поточному робочому каталозі*.

Ми рекомендуємо встановити Composer *глобально* (наприклад, створити копію в `/usr/local/bin`). Для цього виконайте наступну команду:

```console
mv composer.phar /usr/local/bin/composer
```

**Примітка:** Якщо вищевказане не вдається через дозволи, додайте префікс з `sudo`.

Щоб запустити локально встановлений Composer, виконайте в командному рядку `php composer.phar`, якщо він встановлено глобально - просто `composer`.

#### Встановлення на Windows

Для користувачів Windows найпростішим способом почати роботу є використання [ComposerSetup](https://getcomposer.org/Composer-Setup.exe) інсталятор, який виконує глобальне встановлення та налаштовує ваш `$PATH` так що ви можете просто викликати `composer` з будь-якого каталогу у вашому командному рядку.

### Як визначити та встановити залежності

Composer відстежує залежності вашого проєкту у файлі під назвою `composer.json`. Ви можете керувати ним вручну, якщо хочете, або використовувати сам Composer. Команда `composer require` додає залежність проєкту, а якщо у вас її немає `composer.json` файл, буде створено. Ось приклад, який додає [Twig](https://twig.symfony.com/) як залежність для вашого проєкту.

```console
composer require twig/twig:^2.0
```

Як альтернатива, команда `composer init` допоможе вам створити повний файл `composer.json` для вашого проєкту. У будь-якому випадку, коли ви створите свій `composer.json` ви можете сказати Composer завантажити та встановити ваші залежності у каталог `vendor/`. Це також стосується завантажених вами проєктів, які вже є у `composer.json` файлі:

```console
composer install
```

Далі додайте цей рядок до основного файлу PHP вашої програми; це вкаже PHP використовувати автозавантажувач Composer для залежностей вашого проєкту.

```php
<?php
require 'vendor/autoload.php';
```

Тепер ви можете використовувати ваші залежності проєкту, і вони будуть автоматично завантажуватися на вашу вимогу.

### Оновлення ваших залежностей

Composer створює файл під назвою `composer.lock` який зберігає точну версію кожного пакета, який він завантажив під час першого запуску `composer install`. Якщо ви ділитеся своїм проєктом з іншими, переконайтеся, що передаєте і `composer.lock` файл, щоб під час їх запуску `composer install` вони отримали ті самі версії, що й ви. Щоб оновити ваші залежності, запустіть `composer update`. Не використовуйте `composer update` тільки при розгортанні `composer install`, інакше ви можете отримати різні версії пакетів на продакшені.

Найбільш корисно, коли ви гнучко визначаєте вимоги до версії. Наприклад, вимога до версії `~1.8` означає «все, що новіше за `1.8.0`, але менше ніж `2.0.x-dev`”. Ви також можете використовувати символ підстановки `*`, як у `1.8.*`. Тепер команда `composer update` оновить усі ваші залежності до найновішої версії, яка відповідає встановленим вами обмеженням.

### Сповіщення про оновлення

Щоб отримувати сповіщення про випуск нових версій, ви можете зареєструватися на [libraries.io](https://libraries.io/), веб-службу, яка може відстежувати залежності та надсилати вам сповіщення про оновлення.

### Перевірка ваших залежностей на наявність проблем із безпекою

[Local PHP Security Checker](https://github.com/fabpot/local-php-security-checker) це інструмент командного рядка, який перевірить ваш `composer.lock` файл і повідомить вам, чи потрібно оновити будь-які ваші залежностей.

### Обробка глобальних залежностей за допомогою Composer

Composer також може обробляти глобальні залежності та їхні бінарні файли. Використання просте: все, що вам потрібно зробити, це додати до команди префікс `global`. Якщо, наприклад, ви хочете встановити PHPUnit і зробити його доступним у глобально, ви повинні виконати таку команду:

```console
composer global require phpunit/phpunit
```

Це створить папку `~/.composer`, де знаходяться ваші глобальні залежності. Щоб бінарні файли встановлених пакетів були доступні скрізь, ви повинні додати `~/.composer/vendor/bin` папку до вашої змінної `$PATH` .

-   [Дізнайтеся про Composer](https://getcomposer.org/doc/00-intro.md)

## <a name="pear"></a>PEAR

Ветеранський менеджер пакетів, який подобається деяким розробникам PHP [PEAR](https://pear.php.net/). Він працює подібно до Composer, але має деякі помітні відмінності.

PEAR вимагає, щоб кожен пакунок мав певну структуру, що означає, що автор пакунка повинен підготувати його для використання з PEAR. Використання проєкту, який не був підготовлений для роботи з PEAR, неможливе.

PEAR встановлює пакети глобально, що означає, що після встановлення вони стають доступними для всіх проєктів на цьому сервері. Це може бути добре, якщо багато проєктів покладаються на той самий пакет з тією самою версією, але може призвести до проблем, якщо виникають конфлікти версій між двома проєктами.

### Як встановити PEAR

Ви можете встановити PEAR, завантаживши `.phar` інсталятор і виконати його. Документація PEAR докладно описує [інструкції зі встановлення](https://pear.php.net/manual/installation.getting.md) для кожної операційної системи.

Якщо ви використовуєте Linux, ви також можете переглянути менеджер пакунків дистрибутива. Debian і Ubuntu, наприклад, мають apt `php-pear` пакет.

### Як встановити пакет

Якщо пакет вказано у [Списку пакетів PEAR](https://pear.php.net/packages.md), ви можете встановити його, вказавши офіційну назву:

```console
pear install foo
```

Якщо пакет розміщено на іншому каналі, вам потрібно відкрити (`discover`) спочатку канал і також вказати його під час встановлення. Дивіться документ [використання каналів](https://pear.php.net/manual/guide.users.commandline.channels.md) для отримання додаткової інформації на цю тему.

-   [Дізнайтеся про PEAR](https://pear.php.net/)

### Обробка залежностей PEAR за допомогою Composer

Якщо ви вже використовуєте [Composer](#composer_and_packagist) і ви також бажаєте встановити певний код PEAR, ви можете використовувати Composer для обробки залежностей PEAR. У цьому прикладі буде встановлено код із `pear2.php.net`:

```json
{
    "repositories": [
        {
            "type": "pear",
            "url": "https://pear2.php.net"
        }
    ],
    "require": {
        "pear-pear2/PEAR2_Text_Markdown": "*",
        "pear-pear2/PEAR2_HTTP_Request": "*"
    }
}
```

Перший розділ `"repositories"` використовуватиметься, щоб повідомити Composer, що він повинен «ініціалізувати» (або «викрити» в термінології PEAR) репозиторій pear. Потім у розділі `require` ці пакети матимуть префікс імені пакета таким чином:

> pear-channel/Package

Префікс “pear” жорстко закодований, щоб уникнути будь-яких конфліктів, оскільки канал “pear” може збігатися з іменем іншого постачальника пакетів. Тоді коротку назву каналу (або повну URL-адресу) можна використовувати для посилання на канал, у якому знаходиться пакет.

Коли цей код буде встановлено, він буде доступний у вашому каталозі vendor та автоматично доступний через автозавантажувач Composer:

> vendor/pear-pear2.php.net/PEAR2\_HTTP\_Request/pear2/HTTP/Request.php

Щоб використовувати цей пакет PEAR, просто посилайтеся на нього так:

```php
<?php
$request = new pear2\HTTP\Request();
```

-   [Дізнайтеся більше про використання PEAR із Composer](https://getcomposer.org/doc/05-repositories.md#pear)

[Догори](#top)

# <a name="coding_practices"></a>Практики кодування

## <a name="the_basics"></a>Основи

PHP — це велика мова, яка дозволяє програмістам усіх рівнів створювати код не лише швидко, але й ефективно. Однак, просуваючись у мові, ми часто забуваємо основи, які спочатку вивчили (або пропустили), на користь коротких шляхів і/або шкідливих звичок. Щоб допомогти впоратися з цією поширеною проблемою, цей розділ має на меті нагадати програмістам про базові методи кодування в PHP.

-   Продовжуйте читати далі [Основи](https://phptherightway.com/pages/The-Basics.html)

## <a name="date_and_time"></a>Дата і час

У PHP є клас під назвою DateTime, який допоможе вам читати, записувати, порівнювати або обчислювати дату й час. У PHP, окрім DateTime, є багато функцій, пов’язаних із датою та часом, але він забезпечує гарний об’єктно-орієнтований інтерфейс для вирішення більшості поширених проблем. DateTime може обробляти також часові пояси, але це виходить за рамки цього короткого вступу.

Щоб розпочати роботу з DateTime, перетворіть необроблений рядок дати й часу на об’єкт за допомогою фабрічного методу `createFromFormat()` або зробіть `new DateTime` щоб отримати поточну дату й час. Використовуйте метод `format()` для перетворення DateTime назад у рядок для виведення.

```php
<?php
$raw = '22. 11. 1968';
$start = DateTime::createFromFormat('d. m. Y', $raw);

echo 'Start date: '. $start->format('Y-m-d'). PHP_EOL;
```

Обчислення за допомогою DateTime можливе за допомогою класу DateInterval. DateTime має такі методи, як `add()` і `sub()` які приймають DateInterval як аргумент. Не пишіть код, який очікує однакову кількість секунд щодня. Літній час, та зміна часового поясу порушують це ваше припущення. Натомість використовуйте інтервали дат. Щоб обчислити різницю дат, використовуйте метод `diff()`. Він поверне новий DateInterval, який дуже легко відобразити.

```php
<?php
// create a copy of $start and add one month and 6 days
$end = clone $start;
$end->add(new DateInterval('P1M6D'));

$diff = $end->diff($start);
echo 'Difference: '. $diff->format('%m month, %d days (total: %a days)'). PHP_EOL;
// Difference: 1 month, 6 days (total: 37 days)
```

Ви можете використовувати стандартні порівняння об’єктів DateTime:

```php
<?php
if ($start < $end) {
    echo "Start is before the end!". PHP_EOL;}
```

Останній приклад приведено для демонстрації класу DatePeriod. Він використовується для подій, що повторюються. Він може приймати два об’єкти DateTime, початок і кінець, а також інтервал, протягом якого повертаються всі події між ними.

```php
<?php
// output all thursdays between $start and $end
$periodInterval = DateInterval::createFromDateString('first thursday');
$periodIterator = new DatePeriod($start, $periodInterval, $end, DatePeriod::EXCLUDE_START_DATE);
foreach ($periodIterator as $date) {
    // output each date in the period
    echo $date->format('Y-m-d'). ' ';
}
```

Популярним розширенням PHP API для роботи з часом є [Carbon](https://carbon.nesbot.com/). Він успадковує класи DateTime, тому передбачає мінімальні зміни коду, але додаткові функції включають підтримку локалізації, додаткові способи додавання, віднімання та форматування об’єкта DateTime, а також засоби для тестування вашого коду шляхом імітації дати та часу за вашим вибором.

-   [Прочитайте про DateTime](https://php.org.ua/manual/uk/book.datetime.md)
-   [Прочитайте про форматування дати](https://php.org.ua/manual/uk/function.date.md) (прийнятні параметри рядка формату дати)

## <a name="design_patterns"></a>Шаблони проєктування

Коли ви створюєте свою програму, корисно використовувати загальні шаблони у вашому коді та загальні шаблони для загальної структури вашого проєкту. Використання загальних шаблонів є корисним, оскільки це значно полегшує керування вашим кодом і дозволяє іншим розробникам швидко зрозуміти, як все поєднується.

Якщо ви використовуєте фреймворк, то більша частина коду вищого рівня та структура проєкту базуватимуться на цьому фреймворку, тому багато рішень щодо шаблонів приймається за вас. Але ви все одно повинні вибрати найкращі шаблони для дотримання коду, який ви створюєте поверх фреймворку. З іншого боку, якщо ви не використовуєте фреймворк для створення своєї програми, тоді вам потрібно знайти шаблони, які найкраще відповідають типу та розміру програми, яку ви створюєте.

Ви можете дізнатися більше про шаблони проєктування PHP і переглянути робочі приклади за адресою:

[https://designpatternsphp.readthedocs.io/](https://designpatternsphp.readthedocs.io/)

## <a name="php_and_utf8"></a>Робота з UTF-8

*Цей розділ був спочатку написаний [Алексом Кабал](https://alexcabal.com/) о [Найкращіх практиках PHP](https://phpbestpractices.org/#utf-8) і був використаний як основа для наших власних порад щодо UTF-8*.

### Немає one-liners. Будьте уважними, детальними та послідовними.

Зараз PHP не підтримує Unicode на низькому рівні. Існують способи переконатися, що рядки UTF-8 обробляються належним чином, але це нелегко, і це вимагає копання майже на всіх рівнях веб-програми, від HTML до SQL і PHP. Ми прагнемо до короткого практичного підсумку.

### UTF-8 на рівні PHP

Основні операції над рядками, такі як об’єднання двох рядків і призначення рядків змінним, не потребують нічого особливого для UTF-8. Однак більшість рядкових функцій, наприклад `strpos()` і `strlen()`, потребують особливої ​​уваги. Ці функції часто мають відповідні `mb_*` функції: наприклад, `mb_strpos()` і `mb_strlen()`. Ці `mb_*` рядки доступні для вас через [розширення багатобайтових рядків](https://php.org.ua/manual/uk/book.mbstring.md) і спеціально розроблені для роботи з рядками Unicode.

Ви повинні використовувати `mb_*` функції кожного разу, коли ви працюєте з рядком Unicode. Наприклад, якщо ви використовуєте `substr()` у рядку UTF-8б є хороший шанс, що результат включатиме деякі спотворені півсимволи. Правильною функцією для використання буде багатобайтовий аналог, `mb_substr()`.

Важко пам’ятати про використання `mb_*` весь час і тому якщо ви забудете використати многобайтову функцію хоча б один раз, ваш рядок Unicode може бути спотворений під час подальшої обробки.

Не всі рядкові функції мають відповідні `mb_*`. Якщо що ви хочете щось зробити з рядком і такої функції немає, вам не пощастило.

Ви повинні використовувати `mb_internal_encoding()` у верхній частині кожного сценарію PHP, який ви пишете (або у верхній частині вашого глобального сценарію включення), і `mb_http_output()` відразу після нього, якщо ваш сценарій виводить у браузер. Явне визначення кодування ваших рядків у кожному сценарії позбавить вас від головних болей у майбутньому.

Крім того, багато функцій PHP, які працюють із рядками, мають додатковий параметр, який дозволяє вказати кодування символів. Ви завжди повинні явно вказувати UTF-8, коли надається така опція. Наприклад, `htmlentities()` має опцію для кодування символів, і ви завжди повинні вказувати UTF-8, якщо маєте справу з такими рядками. Зауважте, що починаючи з PHP 5.4.0, UTF-8 є кодуванням за умовчанням для `htmlentities()` і `htmlspecialchars()`.

Нарешті, якщо ви створюєте розподілену програму і не можете бути впевнені, що `mbstring` розширення буде ввімкнено, тоді розгляньте можливість використання пакету [symfony/polyfill-mbstring](https://packagist.org/packages/symfony/polyfill-mbstring). Він буде використовувати `mbstring` якщо це доступно, і повернутися до функцій, відмінних від UTF-8, якщо ні.

### UTF-8 на рівні бази даних

Якщо ваш скрипт PHP отримує доступ до MySQL, існує ймовірність того, що ваші рядки можуть зберігатися як рядки, відмінні від UTF-8, у базі даних, навіть якщо ви дотримуєтеся всіх наведених вище заходів безпеки.

Щоб переконатися, що ваші рядки переходять із PHP на MySQL як UTF-8, переконайтеся, що ваша база даних і таблиці налаштовані на набір символів `utf8mb4`, а також те, що ви використовуєте набір символів `utf8mb4` у рядку підключення PDO. Перегляньте приклад коду нижче. Це *критично важливо*.

Зверніть увагу, що ви повинні використовувати набір символів `utf8mb4` для повної підтримки UTF-8, а не `utf8`! Читайте далі, щоб дізнатися, чому.

### UTF-8 на рівні браузера

Використовуйте `mb_http_output()` щоб переконатися, що ваш скрипт PHP виводить рядки UTF-8 у ваш браузер.

У відповідь HTTP має повідомити веб-браузеру, що цю сторінку слід вважати UTF-8. Явно прийнято встановлювати набір символів у заголовку відповіді HTTP таким чином:

```php
<?php
header('Content-Type: text/html; charset=UTF-8')
```

Історичний підхід до цього мав включати [`<meta>` тег](http://htmlpurifier.org/docs/enduser-utf8.html) на вашій HTML сторінці у тезі `<head>`.

```php
<?php
// Кажемо PHP, що ми використовуємо рядки UTF-8 до кінця скрипту
mb_internal_encoding('UTF-8');
$utf_set = ini_set('default_charset', 'utf-8');
if (!$utf_set) {
    throw new Exception('could not set default_charset to utf-8, please ensure it\'s set on your system!');
}

// Будемо виводити UTF-8 у браузер
mb_http_output('UTF-8');
 
// Наш тестовий рядок UTF-8
$string = 'Êl síla erin lû e-govaned vîn.';

// Перетворюємо рядок певним чином за допомогою багатобайтової функції
// Зверніть увагу, як ми вирізали рядок за символом, відмінним від Ascii, для демонстраційних цілей
$string = mb_substr($string, 0, 15);

// Підключення до бази даних для збереження зміненого рядка
// Для отримання додаткової інформації дивіться приклад PDO в цьому документі
// Зверніть увагу на `charset=utf8mb4` в назві джерела даних (DSN)
$link = new PDO(
    'mysql:host=your-hostname;dbname=your-db;charset=utf8mb4',
    'your-username',
    'your-password',
    array(
        PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,
        PDO::ATTR_PERSISTENT => false
    )
);

// Зберігаємо наш перетворений рядок як UTF-8 у нашій базі даних
// Ваша БД і таблиці мають набір символів і сортування utf8mb4, вірно?
$handle = $link->prepare('insert into ElvishSentences (Id, Body, Priority) values (default, :body, :priority)');
$handle->bindParam(':body', $string, PDO::PARAM_STR);
$priority = 45;
$handle->bindParam(':priority', $priority, PDO::PARAM_INT); // явно вказуємо pdo очікувати int
$handle->execute();

// Отримати рядок, який ми щойно зберегли, щоб підтвердити, що він був збережений правильно
$handle = $link->prepare('select * from ElvishSentences where Id = :id');
$id = 7;
$handle->bindParam(':id', $id, PDO::PARAM_INT);
$handle->execute();

// Зберігаємо результат в об’єкт, який ми виведемо пізніше в нашому HTML
// Цей об’єкт не вб’є вашу пам’ять, оскільки він отримує дані Just-In-Time 
$result = $handle->fetchAll(\PDO::FETCH_OBJ);

// Приклад обгортки, яка дозволяє вам екранувати дані в html
function escape_to_html($dirty){
    echo htmlspecialchars($dirty, ENT_QUOTES, 'UTF-8');
}

header('Content-Type: text/html; charset=UTF-8'); // Немає потреби, якщо для default_charset уже встановлено значення utf-8
?><!doctype html>
<html>
    <head>
        <meta charset="UTF-8">
        <title>UTF-8 test page</title>
    </head>
    <body>
        <?php
        foreach($result as $row){
            escape_to_html($row->Body);  // Це має правильно вивести наш трансформований рядок UTF-8 у браузер
        }
        ?>
    </body>
</html>
```

### Подальше читання

-   [Посібник PHP: Операції з рядками](https://php.org.ua/manual/uk/language.operators.string.md)
-   [Посібник PHP: Рядкові функції](https://php.org.ua/manual/uk/ref.strings.md)
    -   [`strpos()`](https://php.org.ua/manual/uk/function.strpos.md)
    -   [`strlen()`](https://php.org.ua/manual/uk/function.strlen.md)
    -   [`substr()`](https://php.org.ua/manual/uk/function.substr.md)
-   [Посібник PHP: Функції багатобайтових рядків](https://php.org.ua/manual/uk/ref.mbstring.md)
    -   [`mb_strpos()`](https://php.org.ua/manual/uk/function.mb-strpos.md)
    -   [`mb_strlen()`](https://php.org.ua/manual/uk/function.mb-strlen.md)
    -   [`mb_substr()`](https://php.org.ua/manual/uk/function.mb-substr.md)
    -   [`mb_internal_encoding()`](https://php.org.ua/manual/uk/function.mb-internal-encoding.md)
    -   [`mb_http_output()`](https://php.org.ua/manual/uk/function.mb-http-output.md)
    -   [`htmlentities()`](https://php.org.ua/manual/uk/function.htmlentities.md)
    -   [`htmlspecialchars()`](https://php.org.ua/manual/uk/function.htmlspecialchars.md)
-   [StackOverflow: які фактори роблять PHP Unicode несумісним?](https://stackoverflow.com/questions/571694/what-factors-make-php-unicode-incompatible)
-   [StackOverflow: найкращі практики PHP і MySQL із міжнародними рядками](https://stackoverflow.com/questions/140728/best-practices-in-php-and-mysql-with-international-strings)
-   [Як підтримувати повний Юнікод у базах даних MySQL](https://mathiasbynens.be/notes/mysql-utf8mb4)
-   [Перенесення Unicode в PHP за допомогою Portable UTF-8](https://www.sitepoint.com/bringing-unicode-to-php-with-portable-utf8/)
-   [StackOverflow: DOMDocument loadHTML неправильно кодує UTF-8](https://stackoverflow.com/questions/8218230/php-domdocument-loadhtml-not-encoding-utf-8-correctly)

## <a name="i18n_l10n"></a>Інтернаціоналізація (i18n) і локалізація (l10n)

*Застереження для новачків: i18n і l10n — це нумероніми, своєрідна абревіатура, де цифри використовуються для скорочення слів — у нашому випадку інтернаціоналізація стає i18n, а локалізація — l10n.*

Перш за все, нам потрібно визначити ці два схожі поняття та інші пов’язані речі:

-   **Інтернаціоналізація** коли ви організовуєте свій код так, щоб його можна було адаптувати до різних мов або регіонів без рефакторингу. Ця дія зазвичай виконується один раз - бажано на початку проєкту, інакше вам, ймовірно, знадобляться значні зміни в ваших скриптах!
-   **Локалізація** відбувається, коли ви адаптуєте інтерфейс (головним чином) шляхом перекладу вмісту на основі попередньої роботи i18n. Зазвичай це робиться щоразу, коли потрібна підтримка нової мови чи регіону, і оновлюється, коли додаються нові частини інтерфейсу, оскільки вони мають бути доступними всіма підтримуваними мовами.
-   **Плюралізація** визначає правила, необхідні між різними мовами для взаємодії рядків, що містять числа та лічильники. Наприклад, в англійській мові, коли у вас є лише один елемент, він в однині, а все, що відрізняється від цього, називається множиною; множина в цій мові позначається додаванням S після деяких слів і іноді змінює його частини. В інших мовах, таких як українська чи сербська, є дві форми множини на додаток до однини – ви навіть можете знайти мови із чотирма, п’ятьма чи шістьма формами, як-от словенська, ірландська чи арабська.

## Поширені способи реалізації

Найпростіший спосіб інтернаціоналізації програмного забезпечення PHP — використання файлів масивів і використання цих рядків у шаблонах, таких як `<h1><?=$TRANS['title_about_page']?></h1>`. Однак цей спосіб навряд чи рекомендований для серйозних проєктів, оскільки він створює деякі проблеми з обслуговуванням та підтримкою - деякі можуть з’явитися на самому початку, наприклад, множинність. Тому, будь ласка, не використовуйте цей підхід, якщо ваш проєкт міститиме більше пари сторінок.

Найбільш класичним способом, який часто використовують як еталон для i18n і l10n, є a [Інструмент Unix під назвою `gettext`](https://en.wikipedia.org/wiki/Gettext). Він бере свій початок у 1995 році і досі є повною реалізацією для перекладу програмного забезпечення. Його досить легко запустити і при цьому він має потужні інструменти підтримки. Саме про Gettext ми тут і будемо говорити. Крім того, щоб допомогти вам не плутатися з командним рядком, ми представимо чудову програму з графічним інтерфейсом користувача, за допомогою якої можна легко оновити l10n в скриптах.

### Інші інструменти

Використовуються загальні бібліотеки, які підтримують Gettext та інші реалізації i18n. Деякі з них можуть здаватися легшими для встановлення або мати додаткові функції чи формати файлів i18n. У цьому документі ми зосереджуємося на інструментах, які постачаються з ядром PHP, але тут ми перелічуємо інші для доповнення:

-   [aura/intl](https://github.com/auraphp/Aura.Intl): Надає інструменти інтернаціоналізації (I18N), зокрема пакетно-орієнтований переклад повідомлень для кожної мови. Він використовує формати масивів для повідомлень. Не надає екстрактора повідомлень, але надає розширене форматування повідомлень за допомогою `intl` розширення (включаючи повідомлення у множині).
-   [oscarotero/Gettext](https://github.com/oscarotero/Gettext): підтримка Gettext з обʼєктно-орієнтованим інтерфейсом; містить покращені допоміжні функції, потужні екстрактори для кількох форматів файлів (деякі з них не підтримуються нативно `gettext` командую), а також може експортувати файли в формати`.mo/.po`. Може бути корисним, якщо вам потрібно інтегрувати файли перекладу в інші частини системи, як-от інтерфейс JavaScript.
-   [symfony/translation](https://symfony.com/doc/current/components/translation.html): підтримує багато різних форматів, але рекомендує використовувати XLIFF. Включає допоміжні функції та вбудований екстрактор і підтримує використання заповнювачів `strtr()` внутрішньо.
-   [laminas/laminas-i18n](https://docs.laminas.dev/laminas-i18n/): підтримує файли масиву та INI, або формати Gettext. Є кешування, щоб уникнути кожного разу читання файлової системи. Він також містить помічники перегляду, фільтри та валідатори з урахуванням локалі. Однак він не має екстрактора повідомлень.

Інші фреймворки також включають модулі i18n, але вони недоступні за межами їхніх кодових баз:

-   [Laravel](https://laravel.com/docs/master/localization) підтримує базові файли масивів, не має автоматичного екстрактора, але містить `@lang` помічник для файлів шаблонів.
-   [Yii](https://www.yiiframework.com/doc/guide/2.0/en/tutorial-i18n) підтримує масив, Gettext і переклад на основі бази даних, а також містить екстрактор повідомлень. Підтримується [`Intl`](https://php.org.ua/manual/uk/intro.intl.md) розширення, доступне з PHP 5.3 і засноване на [проєкт ICU](http://www.icu-project.org); це дозволяє Yii запускати потужні заміни, як-от написання чисел, форматування дат, часу, інтервалів, валюти та порядкових номерів.

Якщо ви вирішите вибрати одну з бібліотек, в яких немає екстракторів, ви можете використовувати формати gettext і  використовувати оригінальний інструментарій gettext (включаючи Poedit), як описано далі.

## Gettext

### Встановлення

Можливо, вам знадобиться інсталювати Gettext і відповідну бібліотеку PHP за допомогою менеджера пакетів, наприклад `apt-get` або `yum`. Після встановлення увімкніть його, додавши `extension=gettext.so` (Linux/Unix) або `extension=php_gettext.dll` (Windows) до вашого `php.ini`.

Тут ми також будемо використовувати [poedit](https://poedit.net) для створення файлів перекладу. Ймовірно, ви знайдете його в менеджері пакетів вашої системи; він доступний для Unix, Mac і Windows і може бути так само [завантаженим безкоштовно з їхнього веб-сайту](https://poedit.net/download).

### Структура

#### Типи файлів

Під час роботи з gettext ви зазвичай маєте справу з трьома файлами. Основними з них є файли PO (Portable Object) і MO (Machine Object), перший з яких є списком доступних для читання «перекладених об’єктів», а другий — відповідний бінарний файл, який інтерпретується gettext під час локалізації. Існує також файл POT (шаблон), який просто містить усі наявні ключі з ваших вихідних файлів і може використовуватися як посібник для створення та оновлення всіх файлів PO. Ці файли шаблонів не є обов’язковими: залежно від інструменту, який ви використовуєте для виконання l10n, ви зможете добре працювати, маючи лише  файли PO/MO. У вас завжди буде одна пара файлів PO/MO для кожної мови та регіону, але лише один POT для кожного домену.

### Домени

Бувають випадки у великих проєктах, коли вам може знадобитися розділити переклади, коли ті самі слова передають різне значення в контексті. У цих випадках ви розділяєте їх на різні *домени*. Це, в основному, іменовані групи файлів POT/PO/MO, де назва файлу це *домен перекладу*. Малі та середні проєкти зазвичай для спрощення використовують лише один домен; його назва довільна, але ми будемо використовувати «main» для наших зразків коду. В [Symfony](https://symfony.com/doc/current/components/translation.html), наприклад, домени використовуються для розділення перекладу для повідомлень валідації.

#### Код мови

Локаль — це просто код, який ідентифікує одну версію мови. Визначається наступним чином [ISO 639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) і [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) специфікаціями: дві малі літери для мови, необов’язково супроводжувані підкресленням і двома великими літерами, що ідентифікують код країни або регіону. Для [рідкісних мов](https://www.gnu.org/software/gettext/manual/gettext.html#Rare-Language-Codes), використовуються три літери.

Деяким програмістам частина "країни" може здатися зайвою. Насправді деякі мови мають діалекти в різних країнах, як-от австрійська німецька (`de_AT`) або бразильською португальською (`pt_BR`). Друга частина використовується для розрізнення цих діалектів - якщо її немає, вона вважається «загальною» або «гібридною» версією мови.

### Структура каталогу

Щоб використовувати Gettext, нам потрібно буде дотримуватися певної структури папок. По-перше, вам потрібно буде вибрати довільний корінь для файлів l10n у вашому вихідному сховищі. Усередині нього ви матимете папку для кожної необхідної мови та фіксовану папку `LC_MESSAGES`, яка міститиме всі ваші пари PO/MO. приклад:

```console
<project root>
 ├─ src/
 ├─ templates/
 └─ locales/
    ├─ forum.pot
    ├─ site.pot
    ├─ de/
    │  └─ LC_MESSAGES/
    │     ├─ forum.mo
    │     ├─ forum.po
    │     ├─ site.mo
    │     └─ site.po
    ├─ es_ES/
    │  └─ LC_MESSAGES/
    │     └─ ...
    ├─ fr/
    │  └─ ...
    ├─ pt_BR/
    │  └─ ...
    └─ pt_PT/
       └─ ...
```

### Форми множини

Як ми вже говорили у вступі, різні мови можуть використовувати різні правила множини. Однак gettext знову рятує нас від цієї проблеми. При створенні нового `.po` файл, вам доведеться оголосити [правила множини](http://docs.translatehouse.org/projects/localization-guide/en/latest/l10n/pluralforms.html) для цієї мови, і перекладені частини, які чутливі до множини, матимуть різну форму для кожного з цих правил. Викликаючи Gettext у коді, вам доведеться вказати номер, пов’язаний із реченням, і він визначить правильну форму для використання – навіть із використанням заміни рядка, якщо потрібно.

Правила множини включають кількість доступних множин і булевий тест `n` який би визначав, до якого правила потрапляє дане число (починаючи підрахунок з 0). Наприклад:

-   Японська: `nplurals=1; plural=0` - тільки одне правило
-   англійська: `nplurals=2; plural=(n != 1);` - два правила, перше, якщо N дорівнює одиниці, друге правило – інакше
-   бразильська португальська: `nplurals=2; plural=(n > 1);` - два правила, друге, якщо N більше одиниці, перше в іншому випадку

Тепер ви розумієте, як працюють правила множини, а якщо ні, подивіться докладніше пояснення у [підручнику LingoHub](https://lingohub.com/blog/2013/07/php-internationalization-with-gettext-tutorial/#Plurals). Ви можете скопіювати потрібні правила з [списку](http://docs.translatehouse.org/projects/localization-guide/en/latest/l10n/pluralforms.html) замість того, щоб писати їх вручну.

Викликаючи Gettext для локалізації речень із лічильниками, ви також повинні надати відповідний номер. Gettext визначить, яке правило має діяти, і використає правильну локалізовану версію. Для кожного визначеного правила множини вам потрібно буде включити речення до фалу `.po`.

### Зразок реалізації

Після всієї цієї теорії давайте трохи практики. Ось уривок `.po` файлу – не зважайте на його формат, а на загальний вміст; пізніше ви дізнаєтеся, як це легко редагувати:

```po
msgid ""
msgstr ""
"Language: pt_BR\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"

msgid "We are now translating some strings"
msgstr "Nós estamos traduzindo algumas strings agora"

msgid "Hello %1$s! Your last visit was on %2$s"
msgstr "Olá %1$s! Sua última visita foi em %2$s"

msgid "Only one unread message"
msgid_plural "%d unread messages"
msgstr[0] "Só uma mensagem não lida"
msgstr[1] "%d mensagens não lidas"
```

Перший розділ працює як заголовок, маючи порожні `msgid` і `msgstr`. У ньому описано кодування файлу, форми множини та інші менш важливі речі. Другий розділ перекладає простий рядок з англійської на бразильську португальську, а третій робить те саме, але використовуючи заміну рядка з [`sprintf`](https://php.org.ua/manual/uk/function.sprintf.md) тому переклад може містити ім'я користувача та дату відвідування. Останній розділ — це зразок форм множини, що відображає однину та множину як `msgid` англійською мовою та їхні відповідні переклади як `msgstr` 0 і 1 (після числа, заданого правилом множини). Там також використовується заміна рядка, щоб число можна було побачити безпосередньо в реченні за допомогою `%d`. Форми множини завжди дві `msgid` (однина та множина), тому радимо не використовувати складну мову як джерело перекладу.

### Обговорення ключів l10n

Як ви могли помітити, ми використовуємо як ідентифікатор джерела фактичне речення англійською мовою. що `msgid` однаково використовується в усіх ваших `.po` файли, тобто інші мови матимуть той самий формат і однакові поля `msgid`, але перекладені рядки `msgstr`.

Якщо говорити про ключі перекладу, то тут є дві основні «школи»:

1.  *`msgid` як реальне речення*. Основні переваги:
    -   якщо є частини програмного забезпечення, не перекладені будь-якою мовою, відображений ключ все одно матиме певне значення. Приклад: якщо ви перекладаєте напам’ять з англійської на іспанську, але вам потрібна допомога з перекладом на французьку, ви можете опублікувати нову сторінку з відсутніми французькими реченнями, а частини веб-сайту натомість відображатимуться англійською мовою;
    -   перекладачу набагато легше зрозуміти, що відбувається, і зробити правильний переклад на основі `msgid`;
    -   це дає вам «безкоштовний» l10n для однієї мови - вихідної;
    -   Єдиний недолік: якщо вам потрібно змінити фактичний текст, вам доведеться замінити його `msgid` у кількох мовних файлах.
2.  *`msgid` як унікальний, структурований ключ*. Це структуровано описуватиме роль речення в програмі, включаючи шаблон або частину, де розміщено рядок замість його вмісту.
    -   це чудовий спосіб упорядкувати код, відокремивши текстовий вміст від логіки шаблону.
    -   однак це може спричинити проблеми для перекладача, оскільки він упустить контекст. Як основа для інших перекладів знадобиться вихідний мовний файл. Приклад: в ідеалі розробник мав би `en.po` файл, який перекладачі прочитали б, щоб зрозуміти, що писати, наприклад, у відповідному `fr.po` файлі.
    -   відсутні переклади відображатимуть безглузді клавіші на екрані (`top_menu.welcome` замість `Hello there, User!` на вищезгаданій неперекладеній французькій сторінці). Це може бути ок, оскільки переклад має бути завершеним перед публікацією, але проблеми з перекладом будуть надзвичайно жахливими в інтерфейсі. Деякі бібліотеки, однак, включають опцію "вказати дану мову як «резервну»", маючи таку ж поведінку, як і вершому підході.

[Посібник Gettext](https://www.gnu.org/software/gettext/manual/gettext.html) надає перевагу першому підходу, оскільки, загалом, це легше для перекладачів і користувачів у разі виникнення проблем. Так ми будемо працювати і тут. Однак, [Документація Symfony](https://symfony.com/doc/current/components/translation/usage.html#creating-translations) надає перевагу перекладу на основі ключових слів, щоб дозволити незалежні зміни всіх перекладів, не впливаючи при цьому на шаблони.

### Щоденне використання

У типовій програмі ви використовували б деякі функції Gettext під час написання статичного тексту на своїх сторінках. Потім ці речення з’являться в `.po` файлі, їх треба перекласти, скомпілювати в `.mo` файли, а потім використати Gettext під час відтворення фактичного інтерфейсу. Враховуючи це, давайте об’єднаємо те, що ми обговорювали вище, у покроковий приклад:

#### 1\. Зразок файлу шаблону, включаючи кілька різних викликів gettext

```php
<?php include 'i18n_setup.php' ?>
<div id="header">
    <h1><?=sprintf(gettext('Welcome, %s!'), $name)?></h1>
    <!-- Цей код має такі відступи лише для розбірливості -->
    <?php if ($unread): ?>
        <h2><?=sprintf(
            ngettext('Only one unread message',
                     '%d unread messages',
                     $unread),
            $unread)?>
        </h2>
    <?php endif ?>
</div>

<h1><?=gettext('Introduction')?></h1>
<p><?=gettext('We\'re now translating some strings')?></p>
```

-   [`gettext()`](https://php.org.ua/manual/uk/function.gettext.md) просто перекладає `msgid` у відповідний `msgstr` для даної мови. Існує також функція скорочення `_()` що працює так само;
-   [`ngettext()`](https://php.org.ua/manual/uk/function.ngettext.md) робить те саме, але з правилами множини;
-   Також є [`dgettext()`](https://php.org.ua/manual/uk/function.dgettext.md) і [`dngettext()`](https://php.org.ua/manual/uk/function.dngettext.md), які дозволяють замінити домен для одного виклику. Докладніше про налаштування домену в наступному прикладі.

#### 2\. Зразок файлу налаштування (`i18n_setup.php` як використано вище), вибравши правильну мову та налаштувавши Gettext

```php
<?php
/**
 * Перевіряє, чи даний $locale підтримується проектом
 * @param string $locale
 * @return bool
 */
function valid($locale) {
   return in_array($locale, ['en_US', 'en', 'pt_BR', 'pt', 'es_ES', 'es']);
}

// налаштування вихідної/замовчованої мови для інформаційних цілей
$lang = 'en_US';

if (isset($_GET['lang']) && valid($_GET['lang'])) {
    // локаль можна змінити за допомогою рядка запиту
    $lang = $_GET['lang'];    // тут потрібна валідація!
    setcookie('lang', $lang); // зберігає в файлі cookie, щоб можна використовувати повторно
} elseif (isset($_COOKIE['lang']) && valid($_COOKIE['lang'])) {
    // якщо натомість присутній файл cookie, давайте просто збережемо його
    $lang = $_COOKIE['lang']; // тут потрібна валідація!
} elseif (isset($_SERVER['HTTP_ACCEPT_LANGUAGE'])) {
    // default: шукає мови, які, за словами браузера, приймає користувач
    $langs = explode(',', $_SERVER['HTTP_ACCEPT_LANGUAGE']);
    array_walk($langs, function (&$lang) { $lang = strtr(strtok($lang, ';'), ['-' => '_']); });
    foreach ($langs as $browser_lang) {
        if (valid($browser_lang)) {
            $lang = $browser_lang;
            break;
        }
    }
}

// тут ми визначаємо глобальну системну локаль з урахуванням знайденої мови
putenv("LANG=$lang");

// це може бути корисним для функцій дати (LC_TIME) або, наприклад, форматування грошей (LC_MONETARY)
setlocale(LC_ALL, $lang);

// це змусить Gettext шукати ../locales/<lang>/LC_MESSAGES/main.mo
bindtextdomain('main', '../locales');

// вказує, у якому кодуванні має бути прочитаний файл
bind_textdomain_codeset('main', 'UTF-8');

// якщо ваша програма має додаткові домени, як уже згадувалося раніше, вам також слід прив’язати їх тут
bindtextdomain('forum', '../locales');
bind_textdomain_codeset('forum', 'UTF-8');

// тут ми вказуємо домен за замовчуванням, на який відповідатимуть виклики gettext().
textdomain('main');

// це буде шукати рядок у forum.mo замість main.mo
// echo dgettext('forum', 'Welcome back!');
?>
```

#### 3\. Підготовка перекладу до першого запуску

Однією з великих переваг Gettext над спеціальними пакетами фреймворку i18n є його широкий і потужний формат файлів. «О, чувак, це досить важко зрозуміти та редагувати вручну, простий масив був би легшим!» Ви помиляєтесь, бо є такі додатки, як [poedit](https://poedit.net), щоб *дуже* нам допомогти. Ви можете отримати програму з [їхнього веб-сайту](https://poedit.net/download), вона безкоштовна і доступна для всіх платформ. Це досить простий інструмент, до якого можна звикнути, і водночас дуже потужний — він використовує всі доступні функції Gettext. Цей посібник базується на PoEdit 1.8.

Під час першого запуску вам слід вибрати в меню «Файл > Створити…». Вам буде запропоновано вказати мову: тут ви можете вибрати/відфільтрувати мову, на яку хочете перекласти, або використати формат, який ми згадували раніше, наприклад `en_US` або `pt_BR`.

Тепер збережіть файл, використовуючи цю структуру каталогів, яку ми також згадували. Потім вам слід натиснути «Витягти з джерел», і тут ви налаштуєте різні параметри для завдань вилучення та перекладу. Пізніше ви зможете знайти їх у «Каталог > Властивості»:

-   Вихідні шляхи: тут ви повинні включити всі папки з проєкту, де визиваєеться `gettext()` (та суміжні папки) - зазвичай це ваші папки шаблонів/відображень. Це єдине обов'язкове налаштування;
-   Властивості перекладу:
    -   Назва та версія проєкту, команда та адреса електронної пошти команди: корисна інформація, яка міститься в заголовку файлу .po;
    -   Форми множини: ось ці правила, про які ми згадували раніше - там також є посилання зі зразками. У більшості випадків ви можете залишити параметр за замовчуванням, оскільки PoEdit уже містить зручну базу даних правил множини для багатьох мов.
    -   Кодування: бажано, UTF-8;
    -   Набір кодів вихідного коду: встановіть тут набір символів, який використовується вашою кодовою базою - можливо, також UTF-8, чи не так?
-   Ключові слова джерела: базове програмне забезпечення знає як `gettext()` і подібні виклики функцій виглядають у кількох мовах програмування, але ви також можете створити власні функції перекладу. Тут ви додасте інші методи. Про це йтиметься пізніше в розділі «Поради».

Після встановлення цих точок програма запустить сканування ваших вихідних файлів, щоб знайти всі виклики локалізації. Після кожного сканування PoEdit відображатиме підсумок того, що було знайдено та що було видалено з вихідних файлів. Нові записи будуть подані порожніми в таблицю перекладу, і ви почнете вводити локалізовані версії цих рядків. Збережіть його, і файл .mo буде (повторно) скомпільовано в ту саму папку. І так: ваш проєкт інтернаціоналізовано.

#### 4\. Переклад рядків

Як ви могли помітити раніше, існує два основних типи локалізованих рядків: прості та ті, що мають форму множини. Перші мають просто два поля: джерело та локалізований рядок. Вихідний рядок не можна змінити, оскільки Gettext/Poedit не мають повноважень змінювати ваші скрипти - вам слід змінити саме джерело та повторно просканувати файли. Порада: ви можете клацнути правою кнопкою миші на рядок перекладу, і він підкаже вам вихідні файли та рядки, де цей рядок використовується. З іншого боку, рядки форми множини містять два поля для відображення двох вихідних рядків і вкладки, щоб ви могли налаштувати різні кінцеві форми.

Кожного разу, коли ви змінюєте свої скрипти та потребуєте оновити переклади, просто натисніть «Оновити», і Poedit повторно просканує код, видаляючи неіснуючі записи, об’єднуючи ті, що змінилися, і додаючи нові. Він також може спробувати вгадати деякі переклади на основі інших ваших перекладів. Ці припущення та змінені записи отримають маркер «Fuzzy», що вказує на те, що їх потрібно переглянути, і відображатиметься у списку золотим кольором. Це також корисно, якщо у вас є команда перекладачів і хтось намагається написати щось, у чому не впевнений: просто позначте Fuzzy, і хтось інший перегляне пізніше.

Нарешті, радимо залишити позначку «Перегляд > Спочатку неперекладені записи», оскільки це *дуже* допоможе вам не забути жодного запису. У цьому меню ви також можете відкривати частини інтерфейсу користувача, які дозволяють залишати контекстну інформацію для перекладачів, якщо це необхідно.

### Поради та підказки

#### Можливі проблеми з кешуванням

Якщо ви використовуєте PHP як модуль на Apache (`mod_php`), у вас можуть виникнути проблеми з кешуванням файлу `.mo`. Це відбувається під час першого читання, а потім, щоб оновити його, вам може знадобитися перезапустити сервер. На Nginx і PHP5 зазвичай потрібно лише кілька оновлень сторінки, щоб оновити кеш перекладу, а на PHP7 це потрібно ще рідше.

#### Додаткові допоміжні функції

Багато людей вважають за краще використовувати `_()` замість `gettext()`. Багато спеціальних бібліотек i18n із фреймворків використовують щось подібне до `t()` а також, щоб зробити перекладений код коротшим. Однак це єдина функція, яка має ярлик. Ви можете додати до свого проєкту деякі інші, наприклад `__()` або `_n()` для `ngettext()`, або, можливо, `_r()` що б приєднатися до визову `gettext()` і `sprintf()`. Інші бібліотеки, як напр [Gettext від oscarotero](https://github.com/oscarotero/Gettext) також надають такі допоміжні функції.

У таких випадках вам потрібно буде вказати утиліті Gettext, як витягти рядки з цих нових функцій. Не бійтеся; це дуже легко. Це просто поле в `.po` файлі або екран налаштувань у Poedit. У редакторі цей параметр знаходиться всередині «Каталог > Властивості > Вихідні ключові слова». Пам’ятайте: Gettext уже знає функції за замовчуванням для багатьох мов, тож не бійтеся, якщо цей список виглядає порожнім. Ви повинні включити туди специфікації цих нових функцій, наведені нижче [у певному форматі](https://www.gnu.org/software/gettext/manual/gettext.html#Language-specific-options):

-   якщо створити щось подібне `t()`, який просто повертає переклад для рядка, ви можете вказати його як `t`. Gettext знатиме, що єдиним аргументом функції є рядок, який потрібно перекласти;
-   якщо функція має більше одного аргументу, ви можете вказати, у якому з них перший рядок, і, якщо потрібно, також форму множини. Наприклад, якщо ми викличемо нашу функцію так: `__('one user', '%d users', $number)`, специфікація буде `__:1,2`, тобто перша форма є першим аргументом, а друга форма є другим аргументом. Якщо ваше число буде першим аргументом замість цього, специфікація буде `__:2,3`, вказуючи, що перша форма є другим аргументом, і так далі.

Після включення цих нових правил до `.po` файлу, нове сканування знайде ваші нові рядки так само легко, як і раніше.

### Список літератури

-   [Вікіпедія: i18n і l10n](https://en.wikipedia.org/wiki/Internationalization_and_localization)
-   [Вікіпедія: Gettext](https://en.wikipedia.org/wiki/Gettext)
-   [LingoHub: інтернаціоналізація PHP за допомогою підручника gettext](https://lingohub.com/blog/2013/07/php-internationalization-with-gettext-tutorial/)
-   [Посібник PHP: Gettext](https://php.org.ua/manual/uk/book.gettext.md)
-   [Посібник Gettext](https://www.gnu.org/software/gettext/manual/gettext.html)

[Догори](#top)

# <a name="dependency_injection"></a>Ін'єкція залежності

[Вікіпедія](https://wikipedia.org/wiki/Dependency_injection):

> Впровадження залежностей — це шаблон розробки програмного забезпечення, який дозволяє видаляти жорстко закодовані залежності та дає можливість змінювати їх під час виконання чи компіляції.

Ця цитата робить концепцію набагато складнішою, ніж вона є насправді. Впровадження залежностей надає компоненту його залежності за допомогою впровадження конструктора, викликів методів або встановлення властивостей. Ось так просто.

## <a name="basic_concept"></a>Основна концепція

Ми можемо продемонструвати концепцію простим, але наївним прикладом.

Ось у нас є клас `Database`, якому потрібен адаптер для спілкування з базою даних. Ми створюємо екземпляр адаптера в конструкторі та створюємо жорстку залежність. Це ускладнює тестування та означає, що клас `Database` дуже тісно пов'язаний з адаптером.

```php
<?php
namespace Database;

class Database
{
    protected $adapter;

    public function __construct()
    {
        $this->adapter = new MySqlAdapter;
    }
}

class MysqlAdapter {}
```

Цей код можна переробити для використання Dependency Injection і таким чином послабити залежність.

```php
<?php
namespace Database;

class Database
{
    protected $adapter;

    public function __construct(MySqlAdapter $adapter)
    {
        $this->adapter = $adapter;
    }
}

class MysqlAdapter {}
```

Зараз ми надаємо `Database` класифікувати свою залежність, а не створювати її саму. Ми навіть могли б створити метод, який би приймав аргумент залежності та встановлював його таким чином (сеттер). Або якщо `$adapter` був би `public`, ми могли б встановити його безпосередньо.

## <a name="complex_problem"></a>Комплексна проблема

Якщо ви коли-небудь читали про впровадження залежностей, ви, напевно, бачили терміни *«Інверсія контролю»* або *«Принцип інверсії залежностей»*. Це складні проблеми, які вирішує Dependency Injection.

### Інверсія контролю

Інверсія контролю — це, як там сказано, «інвертування контролю» системи шляхом утримання організаційного контролю повністю відокремленим від наших об’єктів. З точки зору впровадження залежностей, це означає послаблення наших залежностей шляхом контролю та інстанціювання їх деінде в системі.

Роками фреймворки PHP досягали інверсії керування, однак постало питання, яку частину керування ми інвертуємо і куди? Наприклад, фреймворки MVC зазвичай надають супероб’єкт або базовий контролер, який інші контролери мають розширити, щоб отримати доступ до його залежностей. Це **є** Інверсія контролю, однак, замість того, щоб послабити залежності, цей метод просто перемістив їх.

Впровадження залежностей дозволяє нам більш елегантно вирішити цю проблему, вставляючи лише ті залежності, які нам потрібні, коли вони нам потрібні, без жодних жорстко закодованих залежностей взагалі.

### S.O.L.I.D.

#### Принцип єдиної відповідальності

Принцип єдиної відповідальності стосується акторів і архітектури високого рівня. У ньому сказано, що «клас повинен мати лише одну причину для зміни». Це означає, що кожен клас повинен *тільки* нести відповідальність за одну частину функціональних можливостей програмного забезпечення. Найбільша перевага цього підходу полягає в тому, що він дозволяє покращити код для *багаторазового використання*. Спроєктувавши наш клас для виконання лише однієї речі, ми можемо використовувати (або повторно використовувати) його в будь-якій іншій програмі, не змінюючи її.

#### Принцип Оpen/Closed

Принцип відкритості/закритості стосується дизайну класу та розширення функцій. У ньому сказано, що «програмні сутності (класи, модулі, функції тощо) мають бути відкритими для розширення, але закритими для модифікації». Це означає, що ми повинні розробляти наші модулі, класи та функції таким чином, щоб, коли потрібна нова функціональність, ми не змінювали наш існуючий код, а скоріше писали новий код, який використовуватиметься в існуючому коді. Практично кажучи, це означає, що ми повинні писати класи, які реалізовуватимуться та дотримуватимуться *інтерфейсів*, а потім використовувати type-hinting для цих інтерфейсів замість конкретних класів.

Найбільша перевага цього підходу полягає в тому, що ми можемо дуже легко розширити наш код підтримкою чогось нового без необхідності змінювати наявний код, що означає, що ми можемо скоротити час на перевірку якості та значно зменшити ризик негативного впливу на програму. Ми можемо розгорнути новий код швидше та з більшою впевненістю.

#### Принцип підстановки Лісков

Принцип заміни Ліскова стосується підтипу та успадкування. У ньому зазначено, що «дочірні класи ніколи не повинні порушувати визначення типів батьківського класу». Або, за словами Роберта С. Мартіна, «Підтипи мають бути замінними для своїх базових типів».

Наприклад, якщо у нас є `FileInterface` інтерфейс, який визначає `embed()` метод, і ми маємо `Audio` і `Video` класи, які обидва реалізують `FileInterface` інтерфейс, то ми можемо очікувати, що використання `embed()` методу завжди виконуватиме те що треба. Якщо пізніше ми створимо `PDF` клас або `Gist` клас, який реалізує `FileInterface` інтерфейс, ми вже будемо знати і розуміти, що підійде метод `embed()`. Найбільша перевага цього підходу полягає в тому, що ми маємо можливість створювати гнучкі та легко настроювані програми, оскільки коли ми змінюємо один об’єкт типу (наприклад, `FileInterface`) до іншого, нам не потрібно нічого змінювати в нашій програмі.

#### Принцип поділу інтерфейсу

Принцип сегрегації інтерфейсу (ISP) про це *бізнес-логіка для клієнтів* спілкування. У ньому сказано, що «жоден клієнт не повинен бути змушений залежати від методів, які він не використовує». Це означає, що замість того, щоб мати єдиний монолітний інтерфейс, який повинні реалізувати всі відповідні класи, ми повинні надати набір менших, специфічних для концепції інтерфейсів, один або більше з яких реалізує відповідний клас.

Наприклад, для класу `Car` або `Bus`  може бути цікавим метод `steeringWheel()`, але для класу `Motorcycle` або `Tricycle` цей метод не може бути реалізовано (бо в них немає рульового колеса). І навпаки, для класів `Motorcycle` або `Tricycle`  може буде цікавим метод `handlebars()`, але для `Car` або `Bus` - не буде. Немає необхідності, щоб усі ці типи транспортних засобів підтримували обидва і `steeringWheel()`, і `handlebars()`, тому ми повинні розбити цей один інтерфейс на меньші інтерфейси.

#### Принцип інверсії залежностей

Принцип інверсії залежностей стосується видалення жорстких зв’язків між окремими класами, щоб можна було використовувати нову функціональність шляхом передачі іншого класу. Там зазначено, що треба *«Залежить від абстракцій. Не залежати від реалізації».*. Простіше кажучи, це означає, що наші залежності мають бути інтерфейсами/контрактами або абстрактними класами, а не конкретними реалізаціями. Ми можемо легко змінити наведений вище приклад з базою даних, щоб слідувати цьому принципу.

```php
<?php
namespace Database;

class Database
{
    protected $adapter;

    public function __construct(AdapterInterface $adapter)
    {
        $this->adapter = $adapter;
    }
}

interface AdapterInterface {}

class MysqlAdapter implements AdapterInterface {}
```

Тепер є кілька переваг для класу `Database` - він залежить від інтерфейсу, а не від конкреції.

Вважайте, що ми працюємо в команді, а над адаптером працює колега. У нашому першому прикладі нам довелося б дочекатися, поки згаданий колега закінчить адаптер, перш ніж ми зможемо належним чином імітувати його для наших модульних тестів. Тепер, коли залежність - це інтерфейс/контракт, то ми можемо замокати цей інтерфейс, знаючи, що наш колега створить адаптер на основі цього контракту.

Ще більшою перевагою цього методу є те, що наш код тепер набагато більш масштабований. Якщо через рік ми вирішимо, що ми хочемо перейти на інший тип бази даних, ми можемо написати адаптер, який реалізує оригінальний інтерфейс і натомість вставляти його. Більше не буде потрібно рефакторити, оскільки ми можемо гарантувати, що адаптер слідує договору, який встановлено інтерфейсом.

## <a name="containers"></a>Контейнери

Перше, що вам слід зрозуміти про контейнери ін’єкцій залежностей, це те, що вони не те саме, що ін’єкції залежностей. Контейнер — це зручна утиліта, яка допомагає нам реалізувати ін’єкцію залежностей, однак вони можуть використовуватися й часто зловживаються для реалізації антіпаттерну Service Location. Впровадження контейнера DI як Service Locator у ваші класи, ймовірно, створює більш жорстку залежність від контейнера, ніж залежність, яку ви замінюєте. Це також робить ваш код менш прозорим і, зрештою, важчим для тестування.

Більшість сучасних фреймворків мають власний контейнер ін’єкцій залежностей, який дозволяє об’єднувати ваші залежності за допомогою конфігурації. На практиці це означає, що ви можете написати код, який буде таким же чистим і незв’язаним, як і структура, на якій він побудований.

## <a name="further_reading"></a>Подальше читання

-   [Що таке ін’єкція залежності?](http://fabien.potencier.org/article/11/what-is-dependency-injection)
-   [Ін’єкція залежності: аналогія](https://mwop.net/blog/260-Dependency-Injection-An-analogy.html)
-   [Ін'єкція залежності: га?](https://code.tutsplus.com/tutorials/dependency-injection-huh--net-26903)
-   [Dependency Injection як інструмент для тестування](https://medium.com/philipobenito/dependency-injection-as-a-tool-for-testing-902c21c147f1)

[Догори](#top)

# <a name="databases"></a>Бази даних

Багато разів ваш код PHP використовуватиме базу даних для збереження інформації. У вас є кілька варіантів підключення та взаємодії з вашою базою даних. Рекомендований варіант **до PHP 5.1.0** було використовувати рідні драйвери, такі як [mysqli](https://php.org.ua/manual/uk/mysqli.md), [pgsql](https://php.org.ua/manual/uk/pgsql.md), [mssql](https://php.org.ua/manual/uk/mssql.md) тощо.

Рідні драйвери чудові, якщо ви використовуєте лише *один* у вашій програмі, але якщо, наприклад, ви використовуєте MySQL і трохи MSSQL, або вам потрібно підключитися до бази даних Oracle, ви не зможете використовувати ті самі драйвери. Вам потрібно буде вивчити абсолютно новий API для кожної бази даних — і це може стати досить безглуздим заняттям.

## <a name="mysql_extension"></a>Розширення MySQL

[MySQL](https://php.org.ua/manual/uk/mysql.md) - це неймовірно старе розширення для PHP, його замінили два інші розширення:

-   [mysqli](https://php.org.ua/manual/uk/mysqli.md)
-   [pdo](https://php.org.ua/manual/uk/pdo.md)

Розвиток [mysql](https://php.org.ua/manual/uk/mysql.md) давно зупинився, і його було [вилучено з PHP 5.5.0](https://php.org.ua/manual/uk/migration55.deprecated.md), і воно **було [офіційно видалено в PHP 7.0](https://php.org.ua/manual/uk/migration70.removed-exts-sapis.md)**.

Щоб не копатися у параметрах у вашому `php.ini`, щоб побачити, який модуль ви використовуєте, одним із варіантів є пошук `mysql_*` у обраному вами редакторі. Якщо знайдено будь-які функції, такі як `mysql_connect()`, або `mysql_query()` тоді ви використовуєте `mysql`.

Якщо ви ще не використовуєте PHP 7.x, і не розглянети це оновлення якнайшвидше, це призведе до більших труднощів, коли треба буде оновлятися до PHP 7.x і вище. Найкращий варіант – замінити використання mysql на [mysqli](https://php.org.ua/manual/uk/mysqli.md) або [PDO](https://php.org.ua/manual/uk/pdo.md) у ваших програмах (це можна зробити у рабочому порядку у межах ваших власних розкладів розробки).

**Якщо ви оновлюєтеся з [mysql](https://php.org.ua/manual/uk/mysql.md) до [mysqli](https://php.org.ua/manual/uk/mysqli.md), остерігайтеся ледачих посібників з оновлення, які пропонують просто знайти та замінити `mysql_*` з `mysqli_*`. Мало того, що це надмірне спрощення, воно втрачає переваги, які надає mysqli, наприклад зв’язування параметрів, яке також пропонується і в [PDO](https://php.org.ua/manual/uk/pdo.md).**

-   [Підготовлені вирази MySQLi](https://websitebeaver.com/prepared-statements-in-php-mysqli-to-prevent-sql-injection)
-   [PHP: Вибір API для MySQL](https://php.org.ua/manual/uk/mysqlinfo.api.choosing.md)

## <a name="pdo_extension"></a>Розширення PDO

[PDO](https://php.org.ua/manual/uk/pdo.md) — це бібліотека абстракцій підключення до бази даних — вбудована в PHP, починаючи з версії 5.1.0, яка забезпечує загальний інтерфейс для спілкування з багатьма різними базами даних. Наприклад, ви можете використовувати практично ідентичний код для взаємодії з MySQL або SQLite:

```php
<?php
// PDO + MySQL
$pdo = new PDO('mysql:host=example.com;dbname=database', 'user', 'password');
$statement = $pdo->query("SELECT some_field FROM some_table");
$row = $statement->fetch(PDO::FETCH_ASSOC);
echo htmlentities($row['some_field']);

// PDO + SQLite
$pdo = new PDO('sqlite:/path/db/foo.sqlite');
$statement = $pdo->query("SELECT some_field FROM some_table");
$row = $statement->fetch(PDO::FETCH_ASSOC);
echo htmlentities($row['some_field']);
```

PDO не перекладатиме ваші запити SQL і не емулюватиме відсутні функції; це розширення  - виключно для підключення до кількох типів баз даних з тим самим API.

Що ще більш важливо, `PDO` дає змогу безпечно вводити сторонні дані (наприклад, ідентифікатори) у ваші запити SQL, не турбуючись про атаки впровадження SQL в базу даних. Це можливо за допомогою операторів PDO та зв’язаних параметрів.

Припустімо, скрипт PHP отримує числовий ідентифікатор як параметр запиту. Цей ідентифікатор слід використовувати для отримання запису користувача з бази даних. Ось *неправильний* спосіб як це зробити:

```php
<?php
$pdo = new PDO('sqlite:/path/db/users.db');
$pdo->query("SELECT name FROM users WHERE id = ". $_GET['id']); // <-- Не треба так робити!
```

Це жахливий код. Ви вставляєте необроблений параметр запиту в запит SQL. Це дозволить миттєво зламати вашу БД, використовуючи практику під назвою [SQL ін'єкція](http://wiki.hashphp.org/Validation). Тільки уявіть, якби хакер передав запрос у `id`, вийшло би щось таке `http://domain.com/?id=1%3BDELETE+FROM+users`. Це встановить для змінної `$_GET['id']` значення  `1;DELETE FROM users` який видалить усіх ваших користувачів! Натомість вам слід очистити введений ідентифікатор за допомогою параметрів, пов’язаних із PDO.

```php
<?php
$pdo = new PDO('sqlite:/path/db/users.db');
$stmt = $pdo->prepare('SELECT name FROM users WHERE id = :id');
$id = filter_input(INPUT_GET, 'id', FILTER_SANITIZE_NUMBER_INT); // <-- спочатку отфільтруємо дані (див. [Фільтрація даних](#data_filtering)), особливо важливо про INSERT, UPDATE, тощо.
$stmt->bindParam(':id', $id, PDO::PARAM_INT); // <-- Автоматично провалідує $id для SQL запросу
$stmt->execute();
```

Це *правильний* код. Він використовує зв’язаний параметр у ствердженні PDO. Це також валідує id із запросу перед тим, як він буде збережений у базу даних, запобігаючи потенційним атакам SQL-ін’єкцій.

Для записів, таких як INSERT або UPDATE, особливо важливо спочатку [фільтрувати дані](#data_filtering) та очистіть їх для інших речей (видалення тегів HTML, JavaScript тощо). PDO очистить його лише для SQL, а не для вашої програми.

-   [Дізнайтеся про PDO](https://php.org.ua/manual/uk/book.pdo)

Ви також повинні знати, що з’єднання з базою даних витрачають ресурси, і це було нечуваним випадком вичерпання ресурсів, якщо з’єднання не було явно закрито. Однак це було більш поширеним в інших мовах. Використовуючи PDO, ви можете неявно закрити з’єднання, знищивши об’єкт, переконавшись, що решта посилань на нього видалено, тобто встановлено значення NULL. Якщо ви не зробите цього явно, PHP автоматично закриє з’єднання, коли ваш сценарій завершиться, якщо, звичайно, ви не використовуєте постійні з’єднання.

-   [Дізнайтеся про підключення PDO](https://php.org.ua/manual/uk/pdo.connections)

## <a name="databases_interacting"></a>Взаємодія з базами даних

Коли розробники вперше починають вивчати PHP, вони часто змішують свою взаємодію з базою даних із логікою відображення, використовуючи код, який може виглядати так:

```php
<ul>
<?php
foreach ($db->query('SELECT * FROM table') as $row) {
    echo "<li>".$row['field1']." - ".$row['field1']."</li>";
}
?>
</ul>
```

Це погана практика з багатьох причин, головним чином через те, що його важко налагодити, важко перевірити, важко читати, і він збирається виводити багато полів, якщо ви не встановите обмеження.

Хоча є багато інших рішень для цього - залежно від того, чи ви віддаєте перевагу [ООП](#object-oriented-programming) або [функціональному програмуванню](#functional-programming) - повинен бути якийсь елемент поділу.

Розглянемо найпростіший крок:

```php
<?php
function getAllFoos($db) {
    return $db->query('SELECT * FROM table');
}

$results = getAllFoos($db);
foreach ($results as $row) {
    echo "<li>".$row['field1']." - ".$row['field1']."</li>"; // Погано!!
}
```

Це хороший початок. Помістіть ці два елементи в два різні файли, і ви отримаєте чітке розділення.

Створіть клас, щоб розмістити цей метод, і у вас буде «модель». Створіть простий `.php` файл, щоб розмістити логіку презентації, і ви отримаєте «Відображення», що дуже близько до [MVC](https://code.tutsplus.com/tutorials/mvc-for-noobs--net-10488) - загальної архітектура ООП для більшості [фреймворків](#frameworks).

**foo.php**

```php
<?php
$db = new PDO('mysql:host=localhost;dbname=testdb;charset=utf8mb4', 'username', 'password');

// Зробіть свою модель доступною
include 'models/FooModel.php';

// Створіть екземпляр
$fooModel = new FooModel($db);
// Отримайте список foos
$fooList = $fooModel->getAllFoos();

// Показати
include 'views/foo-list.php';
```

**models/FooModel.php**

```php
<?php
class FooModel
{
    protected $db;

    public function __construct(PDO $db)
    {
        $this->db = $db;
    }

    public function getAllFoos() {
        return $this->db->query('SELECT * FROM table');
    }
}
```

**views/foo-list.php**

```php
<?php foreach ($fooList as $row): ?>
    <li><?= $row['field1'] ?> - <?= $row['field1'] ?></li>
<?php endforeach ?>
```

Це, по суті, те саме, що робить більшість сучасних фреймворків, хоча й трохи більше зроблено вручну. Можливо, вам не доведеться робити все це щоразу, але змішування надто великої кількості логіки відображення та взаємодії з базою даних може стати справжньою проблемою, якщо ви коли-небудь захочете впровадити [модульне тестування](#unit-testing).

## <a name="databases_abstraction_layers"></a>Шари абстракції

Багато фреймворків надають власний рівень абстракції, який може розміщуватися поверх нього, а деякі - не надають (як-от [PDO](https://php.org.ua/manual/uk/book.pdo)). Вони часто емулюють функції для однієї системи бази даних, яких немає в іншій, загортаючи ваші запити в методи PHP, надаючи фактичну абстракцію бази даних замість просто абстракції з’єднання, яку надає PDO. Це, звичайно, додасть невеликих витрат, але якщо ви створюєте портативну програму, яка повинна працювати з MySQL, PostgreSQL і SQLite, тоді невеликі витрати будуть того варті заради чистоти коду.

Деякі шари абстракції були створені за допомогою стандартів простору імен [PSR-0](https://www.php-fig.org/psr/psr-0/) та [PSR-4](https://www.php-fig.org/psr/psr-4/), тому їх можна встановити в будь-якій програмі:

-   [Atlas](https://atlasphp.io)
-   [Aura SQL](https://github.com/auraphp/Aura.Sql)
-   [Doctrine2 DBAL](https://www.doctrine-project.org/projects/dbal.html)
-   [Medoo](https://medoo.in/)
-   [Propel](http://propelorm.org/)
-   [Zend-db](https://packages.zendframework.com/docs/latest/manual/en/index.html#zendframework/zend-db)

[Догори](#top)

# <a name="templating"></a>Шаблонування

Шаблони забезпечують зручний спосіб відокремлення контролера та логіки домену від логіки презентації. Шаблони зазвичай містять HTML вашої програми, але також можуть використовуватися для інших форматів, наприклад XML. Шаблони часто називають «видами», які складають другу **частину** у шаблоні архітектури програмного забезпечення [MVC](https://phptherightway.com/pages/Design-Patterns.html#model-view-controller).

## <a name="templating_benefits"></a>Переваги

Головною перевагою використання шаблонів є чітке відокремлення між логікою презентації та рештою вашої програми. Шаблони несуть виключну відповідальність за відображення форматованого вмісту. Вони не відповідають за пошук даних, збереження чи інші складніші завдання. Це призводить до чистішого та читабельнішого коду, що особливо корисно в командному середовищі, де розробники працюють над кодом на стороні сервера (контролери, моделі), а дизайнери працюють над кодом на стороні клієнта (розмітка).

Шаблони також покращують організацію коду відображення. Шаблони зазвичай розміщуються в папці «views», кожен з яких визначається в одному файлі. Цей підхід заохочує повторне використання коду, коли більші блоки коду розбиваються на менші частини, які можна багаторазово використовувати, які часто називають частковими. Наприклад, верхній і нижній колонтитул вашого сайту можна визначити як шаблони, які потім додаються до та після кожного шаблону сторінки.

Нарешті, залежно від бібліотеки, яку ви використовуєте, шаблони можуть запропонувати більший захист, автоматично виключаючи вміст, створений користувачами. Деякі бібліотеки навіть пропонують пісочницю, де дизайнери шаблонів мають доступ лише до змінних і функцій із білого списку.

## <a name="plain_php_templates"></a>Звичайні PHP шаблони

Звичайні шаблони PHP — це просто шаблони, які використовують рідний код PHP. Вони є природним вибором, оскільки PHP насправді вже є мовою шаблонів. Це просто означає, що ви можете поєднувати код PHP з іншим кодом, наприклад HTML. Це вигідно розробникам PHP, оскільки немає нового синтаксису для вивчення, вони знають доступні їм функції, а їхні редактори коду вже мають підсвічування синтаксису PHP і вбудоване автозавершення. Крім того, звичайні шаблони PHP, як правило, дуже швидкі, оскільки не потрібен етап компіляції.

Кожен сучасний фреймворк PHP використовує певну систему шаблонів, більшість із яких за замовчуванням використовує звичайний PHP. Поза рамками, як бібліотеки [platesphp](http://platesphp.com/), або [Aura.View](https://github.com/auraphp/Aura.View) полегшує роботу зі звичайними шаблонами PHP, пропонуючи такі сучасні функції шаблонів, як успадкування, макети та розширення.

### Простий приклад звичайного шаблону PHP

Використовуючи бібліотеку [platesphp](http://platesphp.com/).

```php
<?php // user_profile.php ?>

<?php $this->insert('header', ['title' => 'User Profile']) ?>

<h1>User Profile</h1>
<p>Hello, <?=$this->escape($name)?></p>

<?php $this->insert('footer') ?>
```

### Приклад простих шаблонів PHP із використанням успадкування

Використовуючи [platesphp](http://platesphp.com/) бібліотека.

```php
<?php // template.php ?>

<html>
<head>
    <title><?=$title?></title>
</head>
<body>

<main>
    <?=$this->section('content')?>
</main>

</body>
</html>
```

```php
<?php // user_profile.php ?>

<?php $this->layout('template', ['title' => 'User Profile']) ?>

<h1>User Profile</h1>
<p>Hello, <?=$this->escape($name)?></p>
```

## <a name="compiled_templates"></a>Скомпільовані шаблони

Хоча PHP вже перетворився на зрілу об’єктно-орієнтовану мову, він [не сильно покращився](http://fabien.potencier.org/article/34/templating-engines-in-php) як мова шаблонів. Скомпільовані шаблони, на кшталт [twig](https://twig.symfony.com/), [Brainy](https://github.com/box/brainy), або [Smarty](https://www.smarty.net/)\*, заповняє цю порожнечу, запропонувавши новий синтаксис, який спеціально розроблено для створення шаблонів. Від автоматичного екранування до успадкування та спрощених структур керування, скомпільовані шаблони розроблено таким чином, щоб їх було легше писати, зрозуміліше читати та безпечніше використовувати. Зібрані шаблони можна навіть використовувати різними мовами, [mustache](https://mustache.github.io/) є хорошим прикладом цього. Оскільки ці шаблони повинні бути скомпільовані, має місце невелике зниження продуктивності, однак воно мінімальне, якщо використовується належне кешування.

*\*Хоча Smarty і пропонує автоматичний екранування, ця функція НЕ ввімкнена за замовчуванням.*

### Простий приклад скомпільованого шаблону

Використовуючи бібліотеку [twig](https://twig.symfony.com/) .

```twig
{% include 'header.html' with {'title': 'User Profile'} %}

<h1>User Profile</h1>
<p>Hello, {{ name }}</p>

{% include 'footer.html' %}
```

### Приклад скомпільованих шаблонів з використанням успадкування

Використовуючи [twig](https://twig.symfony.com/) бібліотека.

```twig
// template.html

<html>
<head>
    <title>{% block title %}{% endblock %}</title>
</head>
<body>

<main>
    {% block content %}{% endblock %}
</main>

</body>
</html>
```

```twig
// user_profile.html

{% extends "template.html" %}

{% block title %}User Profile{% endblock %}
{% block content %}
    <h1>User Profile</h1>
    <p>Hello, {{ name }}</p>
{% endblock %}
```

## <a name="templating_further_reading"></a>Подальше читання

### Статті та посібники

-   [Механізми створення шаблонів у PHP](http://fabien.potencier.org/article/34/templating-engines-in-php)
-   [Вступ до представлень і шаблонів у CodeIgniter](https://code.tutsplus.com/tutorials/an-introduction-to-views-templating-in-codeigniter--net-25648)
-   [Початок роботи з шаблонами PHP](https://www.smashingmagazine.com/2011/10/getting-started-with-php-templating/)
-   [Створіть свою власну систему шаблонів у PHP](https://code.tutsplus.com/tutorials/roll-your-own-templating-system-in-php--net-16596)
-   [Master Pages](https://laracasts.com/series/laravel-from-scratch/episodes/7)
-   [Робота з шаблонами в Symfony 2](https://code.tutsplus.com/tutorials/working-with-templates-in-symfony-2--cms-21172)
-   [Написання безпечніших шаблонів](https://github.com/box/brainy/wiki/Writing-Safe-Templates)

### Бібліотеки

-   [Aura.View](https://github.com/auraphp/Aura.View) *(рідний)*
-   [Blade](https://laravel.com/docs/blade) *(компільований, специфічний для фреймворку)*
-   [Brainy](https://github.com/box/brainy) *(складено)*
-   [Latte](https://github.com/nette/latte) *(складено)*
-   [Mustache](https://github.com/bobthecow/mustache.md) *(складено)*
-   [PHPTAL](https://phptal.org/) *(складено)*
-   [Plates](http://platesphp.com/) *(рідний)*
-   [Smarty](https://www.smarty.net/) *(складено)*
-   [Twig](https://twig.symfony.com/) *(складено)*
-   [Zend\\View](https://framework.zend.com/manual/2.3/en/modules/zend.view.quick-start.html) *(нативний, специфічний для фреймворку)*

[Догори](#top)

# <a name="errors_and_exceptions"></a>Помилки та винятки

## <a name="errors"></a>Помилки

У багатьох мовах програмування, які містять велику кількість винятків, щоразу, коли щось йде не так, створюється виняток. Це, безперечно, життєздатний спосіб робити речі, але PHP — мова програмування “exception-light”. Хоча вона має винятки і все більше у ядрі починаюсь використовувати їх під час роботи з об’єктами, більша частина самого PHP намагатиметься продовжувати обробку незалежно від того, що станеться, якщо не станеться фатальна помилка.

Наприклад:

```console
$ php -a
php > echo $foo;
Notice: Undefined variable: foo in php shell code on line 1
```

Це лише повідомлення про помилку, і PHP із задоволенням продовжить роботу. Це може збити з пантелику тих, хто приходить із мов із «значною кількістю винятків», оскільки, наприклад, посилання на відсутню змінну в Python призведе до виключення:

```console
$ python
>>> print foo
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'foo' is not defined
```

Єдина реальна різниця полягає в тому, що Python злякається через будь-яку дрібницю, тож розробники можуть бути дуже впевнені, що будь-яка потенційна проблема чи крайній випадок буде виявлено, тоді як PHP продовжуватиме обробку, якщо не трапиться щось екстремальне, після чого він викличе помилку та повідомить про неї.

### Серйозність помилки

PHP має кілька рівнів серйозності помилок. Три найпоширеніші типи повідомлень: помилки, повідомлення та попередження. Вони мають різні тяжкості; `E_ERROR`, `E_NOTICE`, і `E_WARNING`. Помилки — це фатальні помилки під час виконання, які зазвичай викликані помилками у вашому коді, і їх потрібно виправляти, оскільки вони призводять до зупинки виконання PHP. Сповіщення – це консультативні повідомлення, викликані кодом, який може або не може викликати проблеми під час виконання сценарію, виконання не зупиняється. Попередження — це нефатальні помилки, виконання сценарію не буде зупинено.

Іншим типом повідомлень про помилку, які повідомляються під час компіляції, є `E_STRICT` повідомлення. Ці повідомлення використовуються, щоб запропонувати зміни до вашого коду, щоб забезпечити найкращу взаємодію та пряму сумісність із майбутніми версіями PHP.

### Зміна поведінки звітів про помилки PHP

Повідомлення про помилки можна змінити за допомогою налаштувань PHP та/або викликів функцій PHP. Використання вбудованої функції PHP `error_reporting()` може встановити рівень помилок протягом тривалості виконання сценарію, передавши одну з попередньо визначених констант або їх комбінацію за допомогою бітових операцій. Тобто якщо ви хочете бачити лише помилки та попередження, але не сповіщення, ви можете налаштувати це:

```php
<?php
error_reporting(E_ERROR | E_WARNING);
```

Ви також можете керувати тим, чи помилки відображаються на екрані (добре для розробки), чи приховані та реєструються (добре для продакшену). Для отримання додаткової інформації про це перегляньте розділ [Error reporting](#error_reporting).

### Вбудоване придушення помилок

Ви також можете наказати PHP придушувати певні помилки за допомогою оператора контролю помилок `@`. Ви розміщуєте цей оператор на початку виразу, і будь-яка помилка, яка є прямим результатом виразу, замовчується.

```php
<?php
echo @$foo['bar'];
```

Це виведе `$foo['bar']` якщо вона існує, але просто поверне нуль і нічого не виведе, якщо змінна `$foo` або ключ `'bar'` не існують. Без оператора керування помилками цей вираз може створити помилку `PHP Notice: Undefined variable: foo` або `PHP Notice: Undefined index: bar`.

Це може здатися гарною ідеєю, але є кілька небажаних компромісів. PHP обробляє вирази за допомогою `@` у менш продуктивний спосіб, ніж вирази без `@`. Передчасна оптимізація може бути коренем всіх помилок у програмувані, але якщо продуктивність особливо важлива для вашої програми/бібліотеки, важливо розуміти вплив оператора контролю помилок на продуктивність.

По-друге, оператор контролю помилок **повністю** ковтає помилку. Помилка не відображається, і помилка не надсилається до журналу помилок. Крім того, системи PHP не мають можливості вимкнути оператор контролю помилок. Хоча ви можете мати рацію в тому, що помилка, яку ви бачите, нешкідлива, інша, більш шкідлива помилка буде так само замовчуватись.

Якщо є спосіб уникнути оператора придушення помилок, вам слід його уникнути. Наприклад, наш код вище можна переписати так:

```php
<?php
// Нульовий оператор об'єднання
echo $foo['bar'] ?? '';
```

Один із випадків, коли придушення помилок може мати сенс, це де `fopen()` не вдається знайти файл для завантаження. Ви можете перевірити існування файлу перед тим, як спробувати його завантажити, але якщо файл буде видалено після перевірки та перед `fopen()` (що може здатися неможливим, але це все ж таки може статися), тоді `fopen()` поверне false *і* буде видавати помилку. Потенційно це те, що PHP повинен сам вирішити, але це той випадок, коли придушення помилок може бути єдиним дійсним рішенням.

Раніше ми згадували, що в базовій системі PHP немає способу вимкнути оператор контролю помилок. однак, [Xdebug](https://xdebug.org/docs/basic) має ini параметр `xdebug.scream`, який вимкне оператор контролю помилок. Ви можете встановити його за допомогою файлу конфігурації `php.ini`.

```ini
xdebug.scream = On
```

Ви також можете встановити це значення під час виконання за допомогою функції `ini_set` 

```php
<?php
ini_set('xdebug.scream', '1')
```

-   [Оператори контролю помилок](https://php.org.ua/manual/uk/language.operators.errorcontrol.md)
-   [SitePoint](https://www.sitepoint.com/)
-   [Xdebug](https://xdebug.org/docs/basic)

### ErrorException

PHP цілком здатний бути мовою програмування зі «значною кількістю винятків» і потребує лише кількох рядків коду для такого переходу. По суті, ви можете викидати свої «помилки» як «винятки», використовуючи клас `ErrorException`, який розширює клас `Exception`.

Це звичайна практика, реалізована великою кількістю сучасних фреймворків, таких як Symfony і Laravel. У режимі налагодження *(або режимі розробника)* обидва ці фреймворки відображатимуть гарний і чистий вигляд *трасування стеку*.

Також доступні деякі пакети для кращої обробки помилок, винятків та звітування. Мені подобається [Whoops!](https://filp.github.io/whoops/), який постачається разом із Laravel за замовчуванням і також може використовуватися в будь-якому фреймворку.

Викидаючи помилки як винятки під час розробки, ви можете впоратися з ними краще. Якщо ви побачите виняток під час розробки, ви можете загорнути його в оператор catch із конкретними інструкціями щодо вирішення ситуації. Кожен виключений випадок, який ви миттєво перехоплюєте, робить вашу програму трохи надійнішою.

Більше інформації про це та докладні відомості про використання `ErrorException` з обробкою помилок можна знайти в документації класу [ErrorException](https://php.org.ua/manual/uk/class.errorexception.md).

-   [Оператори контролю помилок](https://php.org.ua/manual/uk/language.operators.errorcontrol.md)
-   [Попередньо визначені константи для обробки помилок](https://php.org.ua/manual/uk/errorfunc.constants.md)
-   [`error_reporting()`](https://php.org.ua/manual/uk/function.error-reporting.md)
-   [Error reporting](#error_reporting)

## <a name="exceptions"></a>Винятки

Винятки є стандартною частиною більшості популярних мов програмування, але програмісти на PHP часто не помічають їх. У таких мовах, як Ruby, надзвичайно багато винятків, тому щоразу, коли щось піде не так, як-от невдача HTTP-запиту, чи запит до БД, або навіть якщо ресурс зображення не знайдено, Ruby (або ruby gems, що використовуються) виведе виняток на екран, що означає, що ви миттєво дізнаєтеся, що виникла помилка.

Сам PHP досить слабкий з такими кейсами: виклик `file_get_contents()` зазвичай просто принесе вам `FALSE` і попередження. Багато старіших фреймворків PHP, як-от CodeIgniter, просто повертатимуть false, реєструватимуть повідомлення до своїх власних журналів і, можливо, дозволять вам використовувати такий метод, як `$this->upload->get_error()` щоб побачити, що пішло не так. Проблема полягає в тому, що вам потрібно шукати помилку та перевіряти документацію, щоб побачити, який є метод помилки для конкретного класу, замість того, щоб зробити це надзвичайно очевидним.

Інша проблема полягає в тому, що класи автоматично видають помилку на екран і виходять з процесу. Коли ви робите так, ви перешкоджаєте іншому розробнику динамічно обробити цю помилку. Слід створювати винятки, щоб повідомити розробнику про помилку; потім вони можуть вибрати, як його обробити. Наприклад:

```php
<?php
$email = new Fuel\Email;
$email->subject('Моя тема');
$email->body('Ти як?');
$email->to('guy@example.com', 'Якийсь чувак');

try
{
    $email->send();
}
catch(Fuel\Email\ValidationFailedException $e)
{
    // Помилка валідації
}
catch(Fuel\Email\SendingFailedException $e)
{
    // Драйвер не зміг надіслати електронного листа
}
finally
{
    // Виконується незалежно від того, чи було створено виняток, і до відновлення нормального виконання
}
```

### Винятки SPL

Загальний `Exception` клас забезпечує дуже мало контексту для налагодження для розробника; однак, щоб виправити це, можна створити спеціалізований підтип `Exception`:

```php
<?php
class ValidationException extends Exception {}
```

Це означає, що ви можете додати кілька блоків catch і по-різному обробляти різні винятки. Це може призвести до створення *багатьох* користувацьких винятків. Деяких винятків можна уникнути за допомогою винятків SPL, наданих у [Розширення SPL](#standard_php_library).

Якщо, наприклад, ви використовуєте Magic Method `__call()` і викликаєте неіснуючий метод, замість того, щоб створювати новий загальний `Exception` виняток, краще створювати спеціальний виняток саме для цього. Таким чином ви можете просто `throw new BadMethodCallException;`.

-   [Прочитайте про винятки](https://php.org.ua/manual/uk/language.exceptions.md)
-   [Прочитайте про винятки SPL](https://php.org.ua/manual/uk/spl.exceptions.md)
-   [Вкладені винятки в PHP](https://www.brandonsavage.net/exceptional-php-nesting-exceptions-in-php/)

[Догори](#top)

# <a name="security"></a>Безпека

Найкращий ресурс із безпеки PHP, який я знайшов, це [Посібник зі створення безпечного програмного забезпечення PHP за 2018 рік](https://paragonie.com/blog/2017/12/2018-guide-building-secure-php-software) за [Ініціативи Paragon](https://paragonie.com/).

## <a name="web_application_security"></a>Безпека веб-додатків

Для кожного розробника PHP дуже важливо вчитися [основам безпеки веб-додатків](https://paragonie.com/blog/2015/08/gentle-introduction-application-security), який можна розбити на кілька широких тем:

1.  Поділ код-дані.
    -   Коли дані виконуються як код, ви отримуєте SQL-інʼекцію, міжсайтовий скриптінг, локальне/віддалене підключення файлів тощо.
    -   Коли код друкується як дані, ви отримуєте витік інформації (розкриття вихідного коду або, у випадку програм на C, достатньо інформації для обходу [ASLR](http://searchsecurity.techtarget.com/definition/address-space-layout-randomization-ASLR)).
2.  Логіка застосування.
    -   Відсутні елементи керування автентифікацією або авторизацією.
    -   Перевірка введених даних.
3.  Операційне середовище.
    -   Версії PHP.
    -   Сторонні бібліотеки.
    -   Операційна система.
4.  Слабкі сторони криптографії.
    -   [Слабкі випадкові числа](https://paragonie.com/blog/2016/01/on-design-and-implementation-stealth-backdoor-for-web-applications).
    -   [Атаки за допомогою обраного зашифрованого тексту](https://paragonie.com/blog/2015/05/using-encryption-and-authentication-correctly).
    -   [Витік інформації по побічному каналу](http://blog.ircmaxell.com/2014/11/its-all-about-time.html).

Є погані люди, які готові використовувати вашу веб-програму. Важливо вжити необхідних запобіжних заходів для посилення безпеки веб-додатку. На щастя, хороші люди з [відкритого проєкту захисту веб-додатків](https://www.owasp.org/) (OWASP) склали повний список відомих проблем безпеки та методів захисту від них. Цей документ обов’язковий для прочитання кожному розробнику, який піклується про безпеку. Також є ще один хороший посібник із безпеки веб-додатків для PHP: [Вижити в глибині: Безпека PHP](https://phpsecurity.readthedocs.io/en/latest/index.html) від Padraic Brady .

-   [Прочитайте посібник із безпеки OWASP](https://www.owasp.org/index.php/Guide_Table_of_Contents)

## <a name="password_hashing"></a>Хешування пароля

Зрештою кожен створює програму PHP, яка покладається на дані користувача. Імена користувачів і паролі зберігаються в базі даних і пізніше використовуються для автентифікації користувачів під час входу.

Важливо, щоб ви правильно [*хешували*](https://wikipedia.org/wiki/Cryptographic_hash_function) паролі, перш ніж зберігати їх. Хешування та шифрування [дві дуже різні речі](https://paragonie.com/blog/2015/08/you-wouldnt-base64-a-password-cryptography-decoded) які часто плутають.

Хешування є необоротною односторонньою функцією. Хешування створює рядок фіксованої довжини, з якого неможливо відновити інформацію. Це означає, що ви можете порівняти хеш з іншим, щоб визначити, чи вони обидва походять з одного вихідного рядка, чи ні, проте ви не можете визначити оригінальний рядок. Якщо паролі не хешуються і до вашої бази даних отримує доступ неавторизована третя сторона, усі облікові записи користувачів тепер зламано.

На відміну від хешування, шифрування є оборотним (за умови, що у вас є ключ). Шифрування корисне в інших сферах, але це погана стратегія для безпечного зберігання паролів.

Паролі також повинні бути індивідуально [*підсоленими*](https://wikipedia.org/wiki/Salt_(cryptography)) шляхом додавання випадкового рядка до кожного пароля перед хешуванням. Це запобігає атакам зі словником і використанню «райдужних таблиць» (зворотний список критографічних хешів для типових паролів).

Хешування та використання солі є життєво важливими, оскільки часто користувачі використовують той самий пароль для кількох служб, і якість пароля може бути низькою.

Крім того, слід використовувати [спеціалізований алгоритм *хешування пароля*](https://paragonie.com/blog/2016/02/how-safely-store-password-in-2016) замість швидкої криптографічної хеш-функції загального призначення (наприклад, SHA256). Нижче наведено короткий список прийнятних алгоритмів хешування паролів (станом на червень 2018 року):

-   Argon2 (доступний у PHP 7.2 і новіших версіях)
-   Scrypt
-   **Bcrypt** (Встроєно в PHP; див. нижче)
-   PBKDF2 з HMAC-SHA256 або HMAC-SHA512

На щастя, сьогодні в PHP це все реалізовано.

**Хешування паролів за допомогою `password_hash`**

У PHP 5.5 було введено `password_hash()`. Наразі він використовує BCrypt, найнадійніший алгоритм, який зараз підтримує PHP. У майбутньому його буде оновлено, щоб підтримувати більше алгоритмів, якщо це необхідно. Бібліотеку `password_compat` було створено для забезпечення прямої сумісності для PHP >= 5.3.7.

Нижче ми хешуємо рядок, а потім перевіряємо хеш на новий рядок. Оскільки наші два рядки різні («секретний пароль» і «поганий пароль»), то виконається блок із `else`.

```php
<?php
require 'password.php';

$passwordHash = password_hash('secret-password', PASSWORD_DEFAULT);

if (password_verify('bad-password', $passwordHash)) {
    // Правильний пароль
} else {
    // Неправильний пароль
}
```

`password_hash()` подбає про підбір пароля за вас. Сіль зберігається разом з алгоритмом і зберігається як частина хешу. `password_verify()` витягує ці данні, щоб визначити, як перевірити пароль, тому вам не потрібно окреме поле бази даних для зберігання ваших солей.

-   [Дізнатися про `password_hash()`](https://php.org.ua/manual/uk/function.password-hash.md)
-   [`password_compat` для PHP >= 5.3.7 && < 5.5](https://github.com/ircmaxell/password_compat)
-   [Дізнайтеся про хешування стосовно криптографії](https://wikipedia.org/wiki/Cryptographic_hash_function)
-   [Дізнайтеся про солі](https://wikipedia.org/wiki/Salt_(cryptography))
-   [PHP `password_hash()` RFC](https://wiki.php.net/rfc/password_hash)

## <a name="data_filtering"></a>Фільтрування даних

Ніколи (ніколи) не довіряйте зовнішнім даним та даним, які прийшли від користувача. Завжди очищайте та перевіряйте зовнішні дані перед використанням їх у коді. Функції `filter_var()` і `filter_input()` можуть почистити текст і перевіряти текстові формати (наприклад, адреси електронної пошти).

Зовнішні дані можуть бути чим завгодно: `$_GET` і `$_POST` із форми вхідних даних, деякі значення в superglobal `$_SERVER`, тіло запиту HTTP через `fopen('php://input', 'r')`. Пам’ятайте, що зовнішні дані не обмежується лише даними з форми, які надає користувач. Завантажені файли, значення сесій, дані файлів cookie та дані сторонніх веб-сервісів також є сторонніми даними.

Незважаючи на те, що сторонні дані можна зберігати, комбінувати та отримувати до них доступ пізніше, вони все одно є зовнішніми даними. Кожного разу, коли ви обробляєте, виводите, конкатенуєте або включаєте дані у свій код, запитайте себе, чи дані відфільтровано належним чином і чи можна їм довіряти.

Дані можуть бути *профильтровані* по-різному залежно від їх призначення. Наприклад, коли нефільтровані вхідні дані передаються на вихід сторінки HTML, вони можуть виконувати HTML і JavaScript на вашому сайті! Це відоме як Cross-Site Scripting (XSS) і може бути дуже небезпечною атакою. Один із способів уникнути XSS — очистити всі створені користувачем дані перед виведенням на вашу сторінку, видаливши теги HTML за допомогою функції `strip_tags()` або екранування символів зі спеціальним значенням у відповідних об’єктах HTML за допомогою функцій `htmlentities()` або `htmlspecialchars()`.

Іншим прикладом є передача параметрів для виконання в командному рядку. Це може бути надзвичайно небезпечно (і зазвичай погана ідея), але ви можете використовувати вбудовану функцію `escapeshellarg()`  для очищення аргументів виконаної команди.

Останній приклад — використання даних користувача для визначення файлу для завантаження з файлової системи. Це можна використати, змінивши назву файлу на шлях до нього. Вам потрібно видалити рядки `"/"`, `"../"`, [нульові байти](https://php.org.ua/manual/uk/security.filesystem.nullbytes.md) або інші символи шляху до файлу, щоб не можна було завантажити приховані, закриті або конфіденційні файли.

-   [Дізнайтеся про фільтрацію даних](https://php.org.ua/manual/uk/book.filter.md)
-   [Дізнатися про `filter_var`](https://php.org.ua/manual/uk/function.filter-var.md)
-   [Дізнатися про `filter_input`](https://php.org.ua/manual/uk/function.filter-input.md)
-   [Дізнайтеся про обробку нульових байтів](https://php.org.ua/manual/uk/security.filesystem.nullbytes.md)

###  Очищення

Очищення видаляє (або усуває) недозволені або небезпечні символи із зовнішних даних.

Наприклад, вам слід очистити дані, передані користувачем, перед тим, як включати їх в HTML або вставляти їх в необроблений SQL-запит. Коли ви використовуєте зв’язані параметри з [PDO](#databases), воно очистить введені дані замість вас.

Іноді потрібно дозволити певні безпечні HTML-теги у вхідних даних під час включення їх до HTML-сторінки. Це дуже важко зробити і багато хто уникає цього, використовуючи інше більш обмежене форматування, наприклад Markdown або BBCode, хоча такі бібліотеки, як [Очищувач HTML](http://htmlpurifier.org/) існують саме для очищення даних.

[Див. sanitize фільтри](https://php.org.ua/manual/uk/filter.filters.sanitize.md)

### Десеріалізація

Для `unserialize()` небезпечно використовувати дані від користувачів або з інших ненадійних джерел. Це дозволяє зловмисникам створювати екземпляри об’єктів (із визначеними користувачем властивостями), чиї деструктори будуть виконані, **навіть якщо самі обʼєкти не використовуються**. Тому слід уникати десеріалізації ненадійних даних.

Якщо вам абсолютно необхідно десеріалізувати дані з ненадійних джерел, хоча б використовуйте параметр [`allowed_classes`](https://php.org.ua/manual/uk/function.unserialize.md) для обмеження типів об’єктів, які можна десеріалізувати.

### Перевірка

Перевірка гарантує, що зовнішні дані відповідають вашим очікуванням. Наприклад, ви можете підтвердити електронну адресу, номер телефону або вік під час обробки реєстраційного подання.

[Див. Фільтри перевірки](https://php.org.ua/manual/uk/filter.filters.validate.md)

## <a name="configuration_files"></a>Файли конфігурації

Під час створення конфігураційних файлів для ваших додатків передові практики рекомендують дотримуватися одного з таких методів:

-   Рекомендується зберігати конфігураційну інформацію там, де до неї неможливо отримати прямий доступ і отримати її через файлову систему.
-   Якщо вам потрібно зберегти файли конфігурації в корені документа, назвіть файли за допомогою розширення `.php`. Це гарантує, що навіть у разі прямого доступу до сценарію він не буде виводитися як простий текст.
-   Інформацію у файлах конфігурації слід захищати відповідним чином за допомогою шифрування або дозволів файлової системи групи/користувача.
-   Бажано переконатися, що ви не передаєте файли конфігурації, які містять конфіденційну інформацію, напр. паролі або токени API в систему контроля версіями.

## <a name="register_globals"></a>Реєстрація Globals

**ПРИМІТКА:** Починаючи з PHP 5.4.0 `register_globals` налаштування було видалено та більше не може використовуватися. Цей розділ стосується лише тих, хто перебуває в процесі оновлення застарілої програми.

Коли ввімкнено, налаштування конфігурації `register_globals` створює кілька типів змінних (включно з `$_POST`, `$_GET` і `$_REQUEST`), що доступні в глобальній області вашої програми. Це може легко призвести до проблем із безпекою, оскільки ваша програма не може ефективно визначити, звідки надходять дані.

Наприклад: `$_GET['foo']` буде доступний через `$foo`, який може перевизначати оголошені змінні.

Якщо ви використовуєте PHP < 5.4.0 **переконайтеся** що `register_globals` **вимкнено**.

-   [Register\_globals у посібнику PHP](https://php.org.ua/manual/uk/security.globals.md)

## <a name="error_reporting"></a>Звіт про помилку

Реєстрація помилок може бути корисною для пошуку проблемних місць у вашій програмі, але вона також може надати інформацію про структуру вашої програми зовнішньому світу. Щоб ефективно захистити свою програму від проблем, які можуть бути спричинені виведенням цих повідомлень, вам потрібно налаштувати сервер по-різному під час розробки та продакшену (оточення, де працює ваша програма і її використовують клієнти).

### Розробка

Щоб показати всі можливі помилки під час **розробки**, налаштуйте наступні параметри у своєму `php.ini`:

```ini
display_errors = On
display_startup_errors = On
error_reporting = -1
log_errors = On
```

> Передача значення `-1` відображатиме всі можливі помилки, навіть якщо нові рівні та константи будуть додані в майбутніх версіях PHP. Константа `E_ALL` також поводиться таким чином, [починаючи з PHP 5.4](https://php.org.ua/manual/uk/function.error-reporting.md)

Константа рівня помилки `E_STRICT` була введена в 5.3.0 і не є частиною `E_ALL`, однак вона став частиною `E_ALL` у 5.4.0. Що це означає? З точки зору звітування про всі можливі помилки у версії 5.3 це означає, що ви повинні використовувати будь-яке значення `-1` або `E_ALL | E_STRICT`.

**Повідомлення про всі можливі помилки за версією PHP**

-   < 5.3 `-1` або `E_ALL`
-   5.3 `-1` або `E_ALL | E_STRICT`
-   \> 5.3 `-1` або `E_ALL`

### Продакшен

Щоб приховати помилки на вашому середовищі у **продакшену** , налаштуйте свій `php.ini` так:

```ini
display_errors = Off
display_startup_errors = Off
error_reporting = E_ALL
log_errors = On
```

З цими налаштуваннями в робочому стані помилки все одно реєструватимуться в журналах помилок веб-сервера, але не відображатимуться користувачеві. Щоб отримати додаткові відомості про ці параметри, перегляньте посібник PHP:

-   [error\_reporting](https://php.org.ua/manual/uk/errorfunc.configuration#ini.error-reporting)
-   [display\_errors](https://php.org.ua/manual/uk/errorfunc.configuration#ini.display-errors)
-   [display\_startup\_errors](https://php.org.ua/manual/uk/errorfunc.configuration#ini.display-startup-errors)
-   [log\_errors](https://php.org.ua/manual/uk/errorfunc.configuration#ini.log-errors)

[Догори](#top)

# <a name="testing"></a>Тестування

Написання автоматизованих тестів для вашого PHP-коду вважається найкращою практикою та може призвести до створення добре створених програм. Автоматичні тести є чудовим інструментом для того, щоб переконатися, що ваша програма не ламається, коли ви вносите зміни чи додаєте нові функції, і їх не слід ігнорувати.

Існує кілька різних типів інструментів тестування (або фреймворків), доступних для PHP, які використовують різні підходи - усі вони намагаються уникнути ручного тестування та потреби у великих групах забезпечення якості, просто щоб переконатися, що останні зміни не порушили існуючі функціональність.

## <a name="test_driven_development"></a>Розробка, орієнтована на тестування

[Вікіпедія каже, що](https://wikipedia.org/wiki/Test-driven_development):

> Керована тестуванням розробка (TDD) — це процес розробки програмного забезпечення, який базується на повторенні дуже короткого циклу розробки: спочатку розробник пише невдалий автоматизований тестовий приклад, який визначає бажане вдосконалення або нову функцію, потім створює код для проходження цього тесту та остаточно рефакторить новий код до прийнятних стандартів. Кент Бек, якому приписують розробку або «перевідкриття» техніки, заявив у 2003 році, що TDD заохочує простий дизайн і вселяє довіру.

Є кілька різних типів тестування, які ви можете виконати для своєї програми:

### Модульне тестування

Модульне тестування — це підхід до програмування, який забезпечує належну роботу функцій, класів і методів від моменту їх створення до кінця циклу розробки. Перевіряючи значення, що надходять і виходять з різних функцій і методів, ви можете переконатися, що внутрішня логіка працює правильно. Використовуючи Dependency Injection і створюючи «макетні» класи та заглушки, ви можете переконатися, що залежності використовуються правильно для ще кращого покриття тестів.

Коли ви створюєте клас або функцію, ви повинні створити модульний тест для кожної поведінки, яку він повинен мати. На дуже простому рівні ви повинні переконатися, що він видає помилку, якщо ви надсилаєте йому неправильні аргументи, і переконатися, що він працює, якщо ви надсилаєте йому правильні аргументи. Це допоможе гарантувати, що коли ви вносите зміни в цей клас або функцію пізніше в циклі розробки, старі функції продовжуватимуть працювати належним чином. Єдиною альтернативою цьому буде `var_dump()` у test.php, який не є нормальним способом створення програми, неважливо великої чи маленької.

Інше використання модульних тестів - це внесок у відкритий код. Якщо ви можете написати тест, який показує несправну функціональність (тобто невдачу), а потім виправити його та показати, що тест пройдено, виправлення, швидше за все, будуть прийняті. Якщо ви запускаєте проєкт, який приймає пулл-реквести, то вам слід запропонувати тести як вимогу.

[PHPUnit](https://phpunit.de/) це фактична платформа тестування для написання модульних тестів для програм PHP, але є кілька альтернатив:

-   [atoum](https://github.com/atoum/atoum)
-   [Kahlan](https://github.com/crysalead/kahlan)
-   [Peridot](https://peridot-php.github.io/)
-   [SimpleTest](http://simpletest.org)

### Інтеграційне тестування

[Вікіпедія каже, що](https://wikipedia.org/wiki/Integration_testing):

> Інтеграційне тестування (іноді його називають інтеграцією та тестуванням, скорочено «I&T») — це етап тестування програмного забезпечення, на якому окремі модулі програмного забезпечення об’єднуються та тестуються як група. Це відбувається після модульного тестування та перед перевірочним тестуванням. Інтеграційне тестування приймає як вхідні модулі, які пройшли модульне тестування, групує їх у більші агрегати, застосовує тести, визначені в плані інтеграційного тестування до цих агрегатів, і надає як вихід інтегровану систему, готову до системного тестування.

Багато тих самих інструментів, які можна використовувати для модульного тестування, можна використовувати для інтеграційного тестування, оскільки використовуються однакові принципи.

### Функціональне тестування

Іноді також відоме як приймальне тестування, функціональне тестування складається з використання інструментів для створення автоматизованих тестів, які фактично використовують вашу програму, а не просто перевіряють, чи окремі одиниці коду поводяться правильно та чи можуть окремі одиниці правильно спілкуватися один з одним. Ці інструменти зазвичай працюють, використовуючи реальні дані та імітуючи реальних користувачів програми.

#### Інструменти функціонального тестування

-   [Selenium](https://docs.seleniumhq.org/)
-   [Mink](http://mink.behat.org/)
-   [Codeception](https://codeception.com/) - це повноцінна платформа тестування, яка включає інструменти приймального тестування
-   [Storyplayer](https://datasift.github.io/storyplayer/) ц- е повноцінна платформа тестування, яка включає підтримку створення та знищення тестових середовищ на вимогу

## <a name="behavior_driven_development"></a>Розвиток, орієнтований на поведінку

Існує два різних типи розробки, керованої поведінкою (BDD): SpecBDD і StoryBDD. SpecBDD зосереджується на технічній поведінці коду, тоді як StoryBDD зосереджується на бізнесі чи поведінці функцій чи взаємодії. PHP має фреймворки для обох типів BDD.

За допомогою StoryBDD ви пишете зрозумілі історії, які описують поведінку вашої програми. Потім ці історії можна використовувати як фактичні тести для вашої програми. Фреймворк, який використовується в додатках PHP для StoryBDD [Behat](http://behat.org/), був натхненний проєктом Ruby [cucumber](https://cucumber.io/) і реалізує Gherkin DSL для опису поведінки функції.

За допомогою SpecBDD ви пишете специфікації, які описують, як має поводитися ваш фактичний код. Замість того, щоб тестувати функцію або метод, ви описуєте, як ця функція або метод повинні поводитися. PHP пропонує для цієї мети фреймворк [PHPSpec](https://www.phpspec.net/). Цей фреймворк натхненний [проєктом RSpec](https://rspec.info/) для Ruby.

### Посилання BDD

-   [Behat](http://behat.org/), фреймворк StoryBDD для PHP, створена за мотивами Ruby [cucumber](https://cucumber.io/) демонструвати;
-   [PHPSpec](https://www.phpspec.net/), фреймворк SpecBDD для PHP, натхненний Ruby [RSpec](https://rspec.info/) демонструвати;
-   [Codeception](https://codeception.com/) це платформа для повного тестування, яка використовує принципи BDD.

## <a name="complementary_testing_tools"></a>Додаткові засоби тестування

Окрім індивідуальних фреймворків тестування та поведінки, існує також низка загальних фреймворків і допоміжних бібліотек, корисних для будь-якого обраного підходу.

### Посилання на інструменти

-   [Selenium](https://www.seleniumhq.org/) це інструмент автоматизації браузера, який може бути [інтегровано з PHPUnit](https://github.com/giorgiosironi/phpunit-selenium/)
-   [Mockery](https://github.com/padraic/mockery) це Mock Object Framework, з яким можна інтегрувати [PHPUnit](https://phpunit.de/) або [PHPSpec](https://www.phpspec.net/)
-   [Prophecy](https://github.com/phpspec/prophecy) це дуже самовпевнений, але дуже потужний і гнучкий фреймворк для імітації об’єктів PHP. Його інтегровано з [PHPSpec](https://www.phpspec.net/) і можна використовувати з [PHPUnit](https://phpunit.de/).
-   [php-mock](https://github.com/php-mock/php-mock) це бібліотека, яка допомагає імітувати рідні функції PHP.
-   [Infection](https://github.com/infection/infection) є реалізацією PHP [мутаційного тестування](https://en.wikipedia.org/wiki/Mutation_testing) щоб допомогти виміряти ефективність ваших тестів.
-   [PHPUnit Polyfills](https://github.com/Yoast/PHPUnit-Polyfills) це бібліотека, яка дозволяє створювати крос-версійні тести PHPUnit, коли набір тестів потрібно запускати з діапазоном версій PHPUnit.

[Догори](#top)

# <a name="servers_and_deployment"></a>Сервери та розгортання

Програми PHP можна розгортати та запускати на робочих веб-серверах кількома способами.

## <a name="platform_as_a_service"></a>Платформа як послуга (PaaS)

PaaS забезпечує системну та мережеву архітектуру, необхідну для запуску програм PHP в Інтернеті. Це означає, що для запуску PHP-додатків або фреймворків PHP практично немає налаштувань.

Нещодавно PaaS став популярним методом розгортання, розміщення та масштабування PHP-додатків будь-якого розміру. Ви можете знайти список [Постачальники PHP PaaS «Платформа як послуга».](#php_paas_providers) в нашому [розділі ресурсів](#resources).

## <a name="virtual_or_dedicated_servers"></a>Віртуальні або виділені сервери

Якщо ви добре знаєте системне адміністрування або хочете навчитися цьому, віртуальні або виділені сервери нададуть вам повний контроль над робочим середовищем вашої програми.

### nginx і PHP-FPM

PHP, через вбудований у PHP FastCGI Process Manager (FPM), дуже добре поєднується з [nginx](https://nginx.org/), який є легким, високопродуктивним веб-сервером. Він використовує менше пам’яті, ніж Apache, і може краще обробляти більше одночасних запитів. Це особливо важливо на віртуальних серверах, які не мають багато вільної пам’яті.

-   [Докладніше про nginx](https://nginx.org/)
-   [Докладніше про PHP-FPM](https://php.org.ua/manual/uk/install.fpm.md)
-   [Докладніше про безпечне налаштування nginx і PHP-FPM](https://nealpoole.com/blog/2011/04/setting-up-php-fastcgi-and-nginx-dont-trust-the-tutorials-check-your-configuration/)

### Apache і PHP

PHP і Apache мають довгу спільну історію. Apache легко налаштовується і має багато доступних [модулів](https://httpd.apache.org/docs/2.4/mod/) для розширення функціональності. Це популярний вибір для спільних серверів і простого налаштування для фреймворків PHP і програм з відкритим кодом, таких як WordPress. На жаль, за замовчуванням Apache використовує більше ресурсів, ніж nginx, і не може обслуговувати стільки ж відвідувачів одночасно.

Apache має кілька можливих конфігурацій для запуску PHP. Найпоширенішим і найпростішим у налаштуванні є [prefork MPM](https://httpd.apache.org/docs/2.4/mod/prefork.html) з mod\_php5. Хоча він не є найбільш ефективним для використання пам’яті, він найпростіший для роботи та використання. Це, мабуть, найкращий вибір, якщо ви не хочете надто глибоко копатися в аспектах адміністрування сервера. Зауважте, що якщо ви використовуєте mod\_php5 ви ПОВИННІ використовувати prefork MPM.

Крім того, якщо ви хочете вичавити з Apache більше продуктивності та стабільності, ви можете скористатися тією ж системою FPM, що й nginx, і запустити [worker MPM](https://httpd.apache.org/docs/2.4/mod/worker.html) або [event MPM](https://httpd.apache.org/docs/2.4/mod/event.html) з mod\_fastcgi або mod\_fcgid. Ця конфігурація значно ефективніше використовуватиме пам’ять і буде набагато швидшою, але її налаштування вимагає більше роботи.

Якщо ви використовуєте Apache 2.4 або новішої версії, ви можете використовувати [mod\_proxy\_fcgi](https://httpd.apache.org/docs/current/mod/mod_proxy_fcgi.html) щоб отримати чудову продуктивність, яку легко налаштувати.

-   [Докладніше про Apache](https://httpd.apache.org/)
-   [Докладніше про багатопроцесорні модулі](https://httpd.apache.org/docs/2.4/mod/mpm_common.html)
-   [Докладніше про mod\_fastcgi](https://blogs.oracle.com/opal/entry/php_fpm_fastcgi_process_manager)
-   [Докладніше про mod\_fcgid](hhttps://httpd.apache.org/mod_fcgid/)
-   [Докладніше про mod\_proxy\_fcgi](https://httpd.apache.org/docs/current/mod/mod_proxy_fcgi.html)
-   [Докладніше про налаштування Apache і PHP-FPM за допомогою mod\_proxy\_fcgi](https://serversforhackers.com/video/apache-and-php-fpm)

## <a name="shared_servers"></a>Спільні (шаред) сервери

Дякуючи шаред серверам PHP має свою популярність. Важко знайти хост без встановленого PHP, але переконайтеся, що там встановлена остання версія. Спільні сервери дозволяють вам та іншим розробникам розгортати веб-сайти на одній машині. Перевагою цього підходу є дешевизна. Недоліком є ​​те, що ви ніколи не знаєте, який галас збираються здійняти ваші сусідні орендарі; завантаження сервера або відкриття дірок у безпеці є основними проблемами. Якщо бюджет вашого проєкту дозволяє уникнути спільних серверів, то вам слід це зробити.

Щоб переконатися, що ваші спільні сервери пропонують найновіші версії PHP, можете  [глянути версії PHP тут](http://phpversions.info/shared-hosting/).

## <a name="building_and_deploying_your_application"></a>Створення та розгортання вашої програми

Якщо ви вручну змінюєте схему бази даних або виконуєте тести вручну, перш ніж оновлювати файли (вручну), подумайте двічі! З кожним додатковим ручним завданням, необхідним для розгортання нової версії програми, зростає ймовірність потенційно фатальних помилок. Незалежно від того, чи маєте ви справу з простим оновленням, комплексним процесом збирання чи навіть постійною стратегією інтеграції, [автоматизація білдів](https://wikipedia.org/wiki/Build_automation) - твій друг.

Серед завдань, які ви можете автоматизувати, є:

-   Управління залежностями
-   Компіляція, мінімізація ваших активів
-   Запуск тестів
-   Створення документації
-   Упаковка
-   Розгортання

### Інструменти розгортання

Інструменти розгортання можна описати як набір сценаріїв, які виконують типові завдання розгортання програмного забезпечення. Інструмент розгортання не є частиною вашого програмного забезпечення, він впливає на ваше програмне забезпечення «ззовні».

Існує багато доступних інструментів з відкритим кодом, які допоможуть вам з автоматизацією створення та розгортанням, деякі з них написані на PHP, інші – ні. Це не повинно утримувати вас від їх використання, якщо вони краще підходять для конкретної роботи. Ось кілька прикладів:

[Phing](https://www.phing.info/) може керувати процесом упакування, розгортання або тестування з файлу збірки XML. Phing було зроблено на основі [Apache Ant](https://ant.apache.org/). Це надійний інструмент, який існує вже давно, однак його можна було б сприйняти як трохи старомодний через спосіб роботи з конфігурацією (файли XML).

[Capistrano](http://capistranorb.com/) є системою для *програмістів середнього та просунутого рівня*, він дозволяє виконувати команди структурованим, повторюваним способом на одній або кількох віддалених машинах. Він попередньо налаштований для розгортання програм Ruby on Rails, однак ви можете з ним успішно розгортати і системи, написані на PHP. Успішне використання Capistrano залежить від робочого знання Ruby та Rake.

[Ansistrano](https://ansistrano.com) це кілька ролей Ansible для легкого керування процесом розгортання (розгортання та відкат) для програм сценаріїв, таких як PHP, Python і Ruby. Це порт Ansible для [Capistrano](http://capistranorb.com/). Його вже використовувало досить багато компаній, що пишуть на PHP.

[Rocketeer](http://rocketeer.autopergamene.eu/) черпає натхнення та філософію з фреймворку Laravel. Його мета — бути швидким, елегантним і простим у використанні з розумними параметрами за замовчуванням. Він має кілька серверів, кілька етапів, атомарне розгортання та розгортання, яке можна виконувати паралельно. Все в інструменті можна замінити або розширити, і все написано на PHP.

[Deployer](https://deployer.org/) це інструмент розгортання, написаний на PHP. Він простий і функціональний. Функції включають паралельне виконання завдань, атомарне розгортання та підтримку узгодженості між серверами. Доступні рецепти типових завдань для Symfony, Laravel, Zend Framework і Yii. Стаття Юнеса Рафі [просте розгортання програм PHP за допомогою Deployer](https://www.sitepoint.com/deploying-php-applications-with-deployer/) це чудовий посібник із розгортання вашої програми за допомогою цього інструменту.

[Magallanes](https://www.magephp.com/) це ще один інструмент, написаний на PHP із простою конфігурацією, виконаною у файлах YAML. Він підтримує кілька серверів і середовищ, атомарне розгортання та має деякі вбудовані завдання, які можна використовувати для звичайних інструментів і фреймворків.

#### Подальше читання:

-   [Автоматизуйте свій проєкт за допомогою Apache Ant](https://code.tutsplus.com/tutorials/automate-your-projects-with-apache-ant--net-18595)
-   [Розгортання програм PHP](https://deployingphpapplications.com/) - платна книга про кращі практики та інструменти для розгортання PHP.

### Підготовка сервера

Управління та налаштування серверів може бути складним завданням, якщо стикатися з великою кількістю серверів. Існують інструменти для вирішення цієї проблеми, щоб ви могли автоматизувати свою інфраструктуру, щоб переконатися, що у вас є правильні сервери та що вони правильно налаштовані. Вони часто інтегруються з великими провайдерами хмарного хостингу (Amazon Web Services, Heroku, DigitalOcean тощо) для керування екземплярами, що значно полегшує масштабування програми.

[Ansible](https://www.ansible.com/) це інструмент, який керує вашою інфраструктурою за допомогою файлів YAML. Почати роботу з ним просто, і він може керувати складними та великомасштабними програмами. Існує API для керування хмарними інстансами, і він може керувати ними за допомогою динамічної інвентаризації за допомогою певних інструментів.

[Puppet](https://puppet.com/) це інструмент, який має власну мову та типи файлів для керування серверами та конфігураціями. Його можна використовувати в налаштуваннях майстер/клієнт або в режимі «без майстера». У режимі майстер/клієнт клієнти опитуватимуть у центрального майстера(-ів) нову конфігурацію через встановлені проміжки часу та оновлюватимуться за потреби. У режимі без майстра ви самі можете надсилати зміни до своїх вузлів.

[Chef](https://www.chef.io/) це потужна система системної інтеграції на основі Ruby, за допомогою якої ви можете створювати все серверне середовище або віртуальні коробки. Він добре інтегрується з Amazon Web Services через їхню службу OpsWorks.

#### Подальше читання:

-   [Підручник Ansible](https://serversforhackers.com/an-ansible-tutorial)
-   [Ansible для DevOps](https://leanpub.com/ansible-for-devops) - платна книга про все Ansible
-   [Ansible для AWS](https://leanpub.com/ansible-for-aws) - платна книга про інтеграцію Ansible і Amazon Web Services
-   [Серія блогів із трьох частин про розгортання програми LAMP із Chef, Vagrant і EC2](http://www.jasongrimes.org/2012/06/managing-lamp-environments-with-chef-vagrant-and-ec2-1-of-3/)
-   [Chef Cookbook, який встановлює та налаштовує PHP і систему керування пакетами PEAR](https://github.com/chef-cookbooks/php)
-   [Серія відеоуроків Chef](https://www.youtube.com/playlist?list=PL11cZfNdwNyPnZA9D1MbVqldGuOWqbumZ)

### Безперервна інтеграція

> Безперервна інтеграція — це практика розробки програмного забезпечення, коли члени команди часто інтегрують свою роботу, зазвичай кожна особа інтегрує принаймні щодня, що призводить до кількох інтеграцій на день. Багато команд вважають, що такий підхід значно зменшує проблеми інтеграції та дозволяє команді швидше розробляти згуртоване програмне забезпечення.

*– Мартін Фаулер*

Існують різні способи реалізації постійної інтеграції для PHP. [Travis CI](https://travis-ci.org/) зробив чудову роботу, щоб зробити постійну інтеграцію реальністю навіть для невеликих проєктів. Travis CI — це служба постійної інтеграції для спільноти з відкритим кодом. Він інтегрований з GitHub і пропонує першокласну підтримку для багатьох мов, включаючи PHP.

#### Подальше читання:

-   [Постійна інтеграція з Jenkins](https://jenkins.io/)
-   [Постійна інтеграція з PHPCI](https://github.com/dancryer/phpci)
-   [Постійна інтеграція з PHP Censor](https://github.com/php-censor/php-censor)
-   [Постійна інтеграція з Teamcity](https://www.jetbrains.com/teamcity/)

[Догори](#top)

# <a name="virtualization"></a>Віртуалізація

Запуск вашої програми в різних середовищах під час розробки та продакшену може призвести до появи дивних помилок під час запуску. Під час роботи з командою розробників також складно підтримувати різні середовища розробки в актуальному стані з однаковою версією для всіх бібліотек.

Якщо ви розробляєте в Windows і розгортаєте в Linux (або щось інше, що не є Windows) або розробляєте в команді, вам слід розглянути можливість використання віртуальної машини. Це звучить складно, але крім широко відомих середовищ віртуалізації, таких як VMware або VirtualBox, існують додаткові інструменти, які можуть допомогти вам налаштувати віртуальне середовище за кілька простих кроків.

## <a name="vagrant"></a>Vagrant

[Vagrant](https://www.vagrantup.com/) допоможе вам створити ваші віртуальні ящики поверх відомих віртуальних середовищ і налаштувати ці середовища на основі єдиного файлу конфігурації. Їх можна налаштувати вручну, або ви можете використовувати програмне забезпечення для «ініціалізації», наприклад [Puppet](https://puppet.com/) або [Chef](https://www.chef.io/) щоб вони зробили це за вас. Ініціалізація базового блоку — це чудовий спосіб переконатися, що кілька блоків налаштовано однаково, і позбавляє вас від необхідності підтримувати складні списки команд «налаштування». Ви також можете «знищити» свою базову систему та відтворити її без численних дій вручну, що полегшить створення «нової» інсталяції.

Vagrant створює папки для обміну кодом між хостом і віртуальною машиною, що означає, що ви можете створювати та редагувати свої файли на хост-машині, а потім запускати код у своїй віртуальній машині.

### Невелика допомога

Якщо вам потрібна невелика допомога, щоб почати використовувати Vagrant, є деякі служби, які можуть бути корисними:

-   [Puphpet](https://github.com/puphpet/puphpet): простий графічний інтерфейс для налаштування віртуальних машин для розробки PHP. **Сильно зосереджений на PHP**. Крім локальних віртуальних машин, його також можна використовувати для розгортання в хмарних службах. Підготовка здійснюється за допомогою Puppet.
-   [Phansible](http://phansible.com/): надає простий у користуванні інтерфейс, який допомагає створювати Ansible Playbooks для проєктів на основі PHP.

## <a name="docker"></a>Docker

[Docker](https://www.docker.com/) - полегшена альтернатива повній віртуальній машині - називається так тому, що це все про «контейнери». Контейнер — це будівельний блок, який, у найпростішому випадку, виконує одну певну роботу, напр. запуск веб-сервера. «Образ» — це пакет, який ви використовуєте для створення контейнера — у Docker їх є цілий репозіторій.

Типова програма LAMP може мати три контейнери: веб-сервер, процес PHP-FPM і MySQL. Як і у випадку зі спільними папками у Vagrant, ви можете залишити файли програми там, де вони є, і вказати Docker, де їх знайти.

Ви можете генерувати контейнери з командного рядка (див. приклад нижче) або, для зручності обслуговування, створити `docker-compose.yml` файл для вашого проєкту, вказуючи, які контейнери створювати та як вони взаємодіють один з одним.

Docker може допомогти, якщо ви розробляєте кілька веб-сайтів і бажаєте відокремити їх від інсталяції кожного на окремій віртуальній машині, але не маєте необхідного дискового простору чи часу, щоб підтримувати все в актуальному стані. Це ефективно: інсталяція та завантаження відбуваються швидше, вам потрібно зберігати лише одну копію кожного образу. Незважаючи на те, як часто вони використовуються, контейнерам потрібно менше оперативної пам’яті бо вони спільно використовуватимуть те ж саме ядро ​​ОС, тому ви можете мати більше серверів, що працюють одночасно. Друге: щоб зупинити та запустити їх, не потрібно чекати повного завантаження сервера.

### Приклад: запуск PHP-додатків у Docker

Після [встановлення докера](https://docs.docker.com/install/) на вашій машині ви можете запустити веб-сервер однією командою. Далі буде завантажено повнофункціональну інсталяцію Apache з останньою версією PHP, файли скриптів будуть знаходитись у `/path/to/your/php/files` (це буде корінь проєкту), який ви можете переглянути через `http://localhost:8080`:

```console
docker run -d --name my-php-webserver -p 8080:80 -v /path/to/your/php/files:/var/www/html/ php:apache
```

Ця команда ініціалізує та запустить ваш контейнер. Флаг `-d` дозволяє працювати у фоновому режимі. Щоб зупинити і почати його, просто запустіть `docker stop my-php-webserver` і `docker start my-php-webserver` (інші параметри знову не потрібно вказувати).

### Дізнайтеся більше про Docker

Наведена вище команда показує швидкий спосіб запуску базового сервера. Ви можете зробити багато іншого (для цього є тисячі попередньо створених образів у [Docker Hub](https://hub.docker.com/)). Знайдіть час, щоб вивчити термінологію та прочитати [Посібник користувача Docker](https://docs.docker.com/) щоб отримати від нього максимальну користь, і не запускайте випадковий код, який ви завантажили, не перевіривши його безпечність – неофіційні зображення можуть не мати останніх патчів безпеки. Якщо сумніваєтеся, дотримуйтесь [офіційних репозиторіїв](https://hub.docker.com/explore/).

[PHPDocker.io](https://phpdocker.io/generator) сайт автоматично згенерує всі файли, які вам потрібні для повнофункціонального стека LAMP/LEMP, включаючи обрану вами версію PHP і розширення.

-   [Веб-сайт Docker](https://www.docker.com/)
-   [Встановлення Docker](https://docs.docker.com/install/)
-   [Посібник користувача Docker](https://docs.docker.com/)
-   [Docker Hub](https://hub.docker.com/)
-   [Docker Hub - офіційні образи](https://hub.docker.com/explore/)

[Догори](#top)

# <a name="caching"></a>Кешування

PHP досить швидкий сам по собі, але вузькі місця можуть виникати, коли ви встановлюєте віддалені з’єднання, завантажуєте файли тощо. На щастя, існують різні інструменти, доступні для прискорення певних частин вашої програми або скорочення кількості цих різноманітних трудомістких завдань. Тож, почнемо.

## <a name="opcode_cache"></a>Кеш коду операції (OpCache)

Коли виконується файл PHP, його потрібно спочатку скомпілювати у [коди операцій](https://php-legacy-docs.zend.com/manual/php4/en/internals2.opcodes) (інструкції машинної мови для ЦП). Якщо вихідний код не змінено, коди операцій будуть такими ж, тому цей крок компіляції стає марною тратою ресурсів ЦП.

Кеш кодів операцій запобігає надлишковій компіляції, зберігаючи коди операцій у пам’яті та повторно використовуючи їх під час послідовних викликів. Зазвичай спочатку перевіряється підпис або час модифікації файлу на випадок, якщо були якісь зміни.

Цілком ймовірно, що кеш коду операції значно покращить швидкість вашої програми. Починаючи з PHP 5.5 ми маємо [Zend OPcache](https://php.org.ua/manual/uk/book.opcache.md). Залежно від вашого пакета/дистрибутива PHP, зазвичай його ввімкнено за замовчанням – перевірте опцію конфігурації [opcache.enable](https://php.org.ua/manual/uk/opcache.configuration.php#ini.opcache.enable) у функції `phpinfo()`. Для попередніх версій є аналогічне розширення PECL.

Докладніше про кеші кодів операцій:

-   [Zend OPcache](https://php.org.ua/manual/uk/book.opcache) (у комплекті з PHP з версії 5.5)
-   [ Zend OPcache/ZendOptimizerPlus](https://github.com/zendtech/ZendOptimizerPlus)
-   [APC](https://php.org.ua/manual/uk/book.apcu.md) - PHP 5.4 і раніше
-   [XCache](https://xcache.lighttpd.net/)
-   [WinCache](https://www.iis.net/downloads/microsoft/wincache-extension) (розширення для MS Windows Server)
-   [список прискорювачів PHP у Вікіпедії](https://wikipedia.org/wiki/List_of_PHP_accelerators)
-   [Попереднє завантаження PHP](https://php.org.ua/manual/uk/opcache.preloading.md) - PHP >= 7.4

## <a name="object_caching"></a>Кешування об'єктів

Бувають випадки, коли може бути корисним кешувати окремі об’єкти у вашому коді, наприклад, з даними, які дорого отримати, або викликами бази даних, коли результат навряд чи зміниться. Ви можете використовувати програмне забезпечення для кешування об’єктів, щоб зберігати ці частини даних у пам’яті для надзвичайно швидкого доступу пізніше. Якщо ви збережете ці елементи в сховищі даних після їх отримання, а потім витягнете їх безпосередньо з кешу для наступних запитів, ви зможете значно підвищити продуктивність, а також зменшити навантаження на сервери бази даних.

Багато популярних рішень для кешування байт-коду також дозволяють кешувати власні дані, тому є ще більше причин скористатися ними. APCu, XCache та WinCache надають API для збереження даних із вашого PHP-коду в кеш пам’яті.

Найпоширенішими системами кешування об’єктів у пам’яті є APCu та memcached. APCu є чудовим вибором для кешування об’єктів, він містить простий API для додавання ваших власних даних до кеш пам’яті та дуже простий у налаштуванні та використанні. Єдине реальне обмеження APCu полягає в тому, що він прив’язаний до сервера, на якому встановлено. З іншого боку, Memcached встановлюється як окрема служба, і до неї можна отримати доступ через мережу, що означає, що ви можете зберігати об’єкти в надшвидкісному сховищі даних у центральному місці, і багато різних систем можуть отримувати з нього дані.

Зауважте, що під час запуску PHP як програми (Fast-)CGI на веб-сервері кожен процес PHP матиме власний кеш, тобто дані APCu не розподіляються між вашими робочими процесами. У цих випадках ви можете розглянути можливість використання натомість memcached, оскільки він не прив’язаний до процесів PHP.

У мережевій конфігурації APCu зазвичай перевершує memcached з точки зору швидкості доступу, але memcached зможе швидше та більше масштабуватися. Якщо ви не очікуєте, що ваша програма буде працювати на кількох серверах, або не потребуєте додаткових функцій, які пропонує memcached, тоді APCu, мабуть, найкращий вибір для кешування об’єктів.

Приклад логіки використання APCu:

```php
<?php
// перевірте, чи є дані, збережені як 'expensive_data' в кеші
$data = apc_fetch('expensive_data');
if ($data === false) {
    // дані відсутні в кеші; зберегти результат дорогого визову для подальшого використання
    apc_add('expensive_data', $data = get_expensive_data());
}

print_r($data);
```

Зауважте, що до PHP 5.5 APC надає можливість кешувати як об’єкти, так і байт-коди. APCu — це проєкт переведення кешу об’єктів APC у PHP 5.5+, оскільки PHP тепер має вбудований кеш байт-кодів (OPcache).

### Дізнайтеся більше про популярні системи кешування об’єктів:

-   [APCu](https://github.com/krakjoe/apcu)
-   [Memcached](https://memcached.org/)
-   [Redis](https://redis.io/)
-   [API XCache](https://xcache.lighttpd.net/wiki/XcacheApi)
-   [Функції WinCache](https://php.org.ua/manual/uk/ref.wincache.md)

[Догори](#top)

# <a name="documenting"></a>Документування вашого коду

## <a name="phpdoc"></a>PHPDoc

PHPDoc — це неформальний стандарт для коментування PHP коду. Доступно *багато* різних [тегів](https://docs.phpdoc.org/latest/guide/references/phpdoc/tags/index.html). Повний список тегів і приклади можна знайти у [Посібнику PHPDoc](https://docs.phpdoc.org/latest/index.html).

Нижче наведено приклад того, як ви можете документувати клас за допомогою кількох методів:

```php
<?php
/**
 * @author A Name <a.name@example.com>
 * @link http://www.phpdoc.org/docs/latest/index.html
 */
class DateTimeHelper
{
    /**
     * @param mixed $anything Усе, що ми можемо перетворити на об’єкт \DateTime
     *
     * @throws \InvalidArgumentException
     *
     * @return \DateTime
     */
    public function dateTimeFromAnything($anything)
    {
        $type = gettype($anything);

        switch ($type) {
            // Деякий код, який намагається повернути об’єкт \DateTime
        }

        throw new \InvalidArgumentException(
            "Failed Converting param of type '{$type}' to DateTime object"
        );
    }

    /**
     * @param mixed $date Усе, що ми можемо перетворити на об’єкт \DateTime
     *
     * @return void
     */
    public function printISO8601Date($date)
    {
        echo $this->dateTimeFromAnything($date)->format('c');
    }

    /**
     * @param mixed $date Усе, що ми можемо перетворити на об’єкт \DateTime
     */
    public function printRFC2822Date($date)
    {
        echo $this->dateTimeFromAnything($date)->format('r');
    }
}
```

Документація по класу в цілому має свого [@author](https://docs.phpdoc.org/latest/guide/references/phpdoc/tags/author.html) і [@link](https://docs.phpdoc.org/latest/guide/references/phpdoc/tags/link.html). Тег [@author](https://docs.phpdoc.org/latest/guide/references/phpdoc/tags/author.html) використовується для документування автора коду та може повторюватись для документування кількох авторів. Тег [@link](https://docs.phpdoc.org/latest/guide/references/phpdoc/tags/link.html) використовується для посилання на веб-сайт, що вказує на зв’язок між веб-сайтом і кодом.

Усередині класу перший метод має тег [@param](https://docs.phpdoc.org/latest/guide/references/phpdoc/tags/param.html), що документує тип, назву та опис параметра, який передається в метод. Крім того, він має теги [@return](https://docs.phpdoc.org/latest/guide/references/phpdoc/tags/return.html) і [@throws](https://docs.phpdoc.org/latest/guide/references/phpdoc/tags/throws.html) для документування типу повернення та будь-які винятки, які можуть бути створені відповідно.

Другий і третій способи дуже схожі і мають єдиний тег [@param](https://docs.phpdoc.org/latest/guide/references/phpdoc/tags/param.html), так само як і перший метод. Важливою відмінністю між блоком документів другого та третього методів є включення/виключення тегу [@return](https://docs.phpdoc.org/latest/guide/references/phpdoc/tags/return.html). `@return void` чітко повідомляє нам, що повернення не передбачено; історично якщо не вказувати `@return void` , то це також поідобляє, що повернення немає.

[Догори](#top)

# <a name="resources"></a>Ресурси

## <a name="from_the_source"></a>Від Джерела

-   [Веб-сайт PHP орігінал](https://php.net/)
-   [Веб-сайт PHP Українською](https://php.org.ua/)
-   [Документація PHP](https://php.org.ua/manual/uk/docs.md)
-   [Документація PHP Українською](https://php.org.ua/manual/uk/index.md)

## <a name="people_to_follow"></a>Люди, за якими слід слідкувати

Важко знайти цікавих і обізнаних членів PHP-спільноти, коли ви тільки починаєте. Ви можете знайти скорочений список членів PHP-спільноти, який допоможе вам почати, за адресами:

-   [https://www.ogprogrammer.com/2017/06/28/how-to-get-connected-with-the-php-community/](https://www.ogprogrammer.com/2017/06/28/how-to-get-connected-with-the-php-community/)
-   [https://twitter.com/CalEvans/lists/phpeople](https://twitter.com/CalEvans/lists/phpeople)

## <a name="php_paas_providers"></a>Постачальники PHP PaaS

-   [AppFog](https://www.ctl.io/appfog/)
-   [Amezmo](https://www.amezmo.com)
-   [AWS Elastic Beanstalk](https://aws.amazon.com/elasticbeanstalk/)
-   [Cloudways](https://www.cloudways.com/)
-   [Divio](https://www.divio.com/php/)
-   [Engine Yard Cloud](https://www.engineyard.com/features)
-   [fortrabbit](https://www.fortrabbit.com/)
-   [Google App Engine](https://cloud.google.com/appengine/docs/php/)
-   [Heroku](https://devcenter.heroku.com/categories/php-support)
-   [IBM Cloud](https://console.bluemix.net/docs/runtimes/php/getting-started.html#getting_started)
-   [Jelastic](https://jelastic.com/)
-   [Microsoft Azure](https://azure.microsoft.com/)
-   [Nanobox](https://nanobox.io/)
-   [Pivotal Web Services](https://run.pivotal.io/)
-   [Platform.sh](https://platform.sh/)
-   [Red Hat OpenShift](https://www.openshift.com/)

Щоб дізнатися, які версії працюють на цих хостах PaaS, перейдіть до [PHP Versions](http://phpversions.info/paas-hosting/).

## <a name="frameworks"></a>Фреймворки

Замість того, щоб заново винаходити велосипед, багато розробників PHP використовують фреймворки для створення веб-додатків. Фреймворки абстрагують від багатьох проблем низького рівня та надають корисні, прості у використанні інтерфейси для виконання звичайних завдань.

Вам не потрібно використовувати фреймворк для кожного проєкту. Іноді звичайний PHP є правильним шляхом, але якщо вам потрібна фреймворк, то доступні три основні типи:

-   Мікрофреймворки
-   Full-Stack Frameworks
-   Компонентні фреймворки

Мікрофреймворки — це, по суті, оболонка для якнайшвидшого маршрутизації HTTP-запиту до зворотного виклику, контролера, методу тощо, і іноді постачається з кількома додатковими бібліотеками для допомоги в розробці, такими як базові оболонки бази даних тощо. Вони широко використовуються для створення віддалених HTTP-служб.

Багато фреймворків додають значну кількість функцій на додаток до того, що доступно в мікрофреймворку; вони називаються Full-Stack Frameworks. Вони часто постачаються в комплекті з ORM, пакетами автентифікації тощо.

Компонентні фреймворки — це колекції спеціалізованих і одноцільових бібліотек. Різні фреймворки на основі компонентів можна використовувати разом, щоб створити фреймворк із мікро- або повним стеком.

## <a name="components"></a>Компоненти

Як згадувалося вище, «Компоненти» є ще одним підходом до спільної мети створення, розповсюдження та впровадження спільного коду. Існують різні сховища компонентів, два основних з яких:

-   [Packagist](#composer_and_packagist)
-   [PEAR](#pear)

Обидва ці репозиторії мають пов’язані з ними інструменти командного рядка, які допомагають у процесах інсталяції та оновлення, і докладніше пояснюються e розділі [Управління залежностями](#dependency_management) .

Існують також фреймворки на основі компонентів і постачальники компонентів, які взагалі не пропонують фреймворків. Ці проєкти надають ще одне джерело пакетів, які в ідеалі майже не залежать від інших пакетів або певних фреймворків.

Наприклад, ви можете використовувати [Пакет перевірки FuelPHP](https://github.com/fuelphp/validation), без необхідності використовувати саму структуру FuelPHP.

-   [Aura](http://auraphp.com/framework/)
-   Компоненти CakePHP
    -   [Collection](https://github.com/cakephp/collection)
    -   [Database](https://github.com/cakephp/database)
    -   [Datasource](https://github.com/cakephp/datasource)
    -   [Event](https://github.com/cakephp/event)
    -   [I18n](https://github.com/cakephp/i18n)
    -   [ORM](https://github.com/cakephp/orm)
-   [FuelPHP](https://github.com/fuelphp)
-   [Hoa Project](https://github.com/hoaproject)
-   [Symfony Components](https://symfony.com/doc/current/components/index.html)
-   [The League of Extraordinary Packages](https://thephpleague.com/)
-   Компоненти Illuminate Laravel
    -   [IoC Container](https://github.com/illuminate/container)
    -   [Eloquent ORM](https://github.com/illuminate/database)
    -   [Queue](https://github.com/illuminate/queue)

*Laravelʼівські компонени [Illuminate](https://github.com/illuminate) буде краще відокремлити від структури Laravel. Наразі вище наведено лише компоненти, які найкраще відокремити від самого фреймворку Laravel.*

## <a name="other_resources"></a>Інші корисні ресурси

### Шпаргалки

-   [PHP шпаргалки](http://phpcheatsheets.com/) - для порівняння змінних, арифметики та тестування змінних у різних версіях PHP.
-   [Сучасна шпаргалка PHP](https://github.com/smknstd/modern-php-cheatsheet) - документує сучасні (PHP 7.0+) ідіоми в єдиному документі.
-   [Шпаргалки безпеки OWASP](https://www.owasp.org/index.php/OWASP_Cheat_Sheet_Series) - надає стислу колекцію високоцінної інформації щодо конкретних тем безпеки додатків.

### Більше найкращих практик

-   [Найкращі практики PHP](https://phpbestpractices.org/)
-   [Чому ви повинні використовувати підтримувані версії PHP](https://kinsta.com/blog/php-versions/)

### Новини навколо спільнот PHP і веб-розробників

Ви можете підписатися на щотижневі інформаційні бюлетені, щоб бути в курсі нових бібліотек, останніх новин, подій і загальних оголошень, а також додаткових ресурсів, які публікуються час від часу:

-   [Щотижневик PHP](http://www.phpweekly.com)
-   [JavaScript Weekly](https://javascriptweekly.com/)
-   [Frontend Focus](https://frontendfoc.us/)
-   [Mobile Web Weekly](https://mobiledevweekly.com/)

Є також тижневики на інших платформах, які можуть вас зацікавити; ось [список деяких](https://github.com/jondot/awesome-weekly).

### Всесвіт PHP

-   [Блог розробника PHP](https://blog.phpdeveloper.org/)

## <a name="videos"></a>Відеоуроки

### Канали YouTube

-   [PHP Academy](https://www.youtube.com/user/phpacademy)
-   [The New Boston](https://www.youtube.com/user/thenewboston)
-   [Sherif Ramadan](https://www.youtube.com/user/businessgeek)
-   [Level Up Tuts](https://www.youtube.com/user/LevelUpTuts)

### Платні відео

-   [Стандарти та найкращі практики](https://teamtreehouse.com/library/php-standards-and-best-practices)
-   [Навчання PHP із Pluralsight](https://www.pluralsight.com/search?q=php)
-   [Навчання PHP на Lynda.com](https://www.lynda.com/search?q=php)
-   [Навчання PHP на Tutsplus](https://code.tutsplus.com/categories/php/courses)
-   [Ларакасти](https://laracasts.com/)

## <a name="books"></a>Книги

Існує багато книг про PHP; на жаль, деякі з них зараз досить старі та вже не точні. Зокрема, уникайте книг про «PHP 6», версію, яка ніколи не існувала. Наступним великим випуском PHP після 5.6 був “PHP 7”, [частково через це](https://wiki.php.net/rfc/php6).

Цей розділ має бути живим документом для рекомендованих книг про розробку PHP загалом. Якщо ви хочете, щоб ваша книга була додана, надішліть PR, і вона буде перевірена на відповідність.

### Безкоштовні книги

-   [PHP Pandas](http://daylerees.com/php-pandas/) - Має на меті навчити всіх, як бути веб-розробником.
-   [PHP Правильний шлях](https://leanpub.com/phptherightway/) - Цей веб-сайт англійською, доступний у вигляді книги, абсолютно безкоштовно.
-   [Використання Libsodium у проєктах PHP](https://paragonie.com/book/pecl-libsodium) - Посібник із використання розширення PHP Libsodium для сучасної, безпечної та швидкої криптографії.

### Платні книги

-   [Створюйте API, які ви не будете ненавидіти](https://apisyouwonthate.com/) – Усім потрібен API, тож вам, ймовірно, варто навчитися їх створювати.
-   [Сучасний PHP](http://shop.oreilly.com/product/0636920033868.do) - Охоплює сучасні функції PHP, найкращі практики, тестування, налаштування, розгортання та налаштування середовища розробника.
-   [Створення безпечних програм PHP](https://leanpub.com/buildingsecurephpapps) - Вивчіть основи безпеки, які старший розробник зазвичай отримує протягом багатьох років досвіду, і все це зведено в один швидкий і простий посібник
-   [Модернізація застарілих програм у PHP](https://leanpub.com/mlaphp) - Контролюйте свій код за допомогою низки невеликих конкретних кроків
-   [Захист PHP: основні поняття](https://leanpub.com/securingphp-coreconcepts) - Посібник із деяких найпоширеніших термінів безпеки що надає деякі приклади використання у повсякденному PHP
-   [Масштабування PHP](http://www.scalingphpbook.com/) - Припиніть грати в системного адміністратора та поверніться до програмування
-   [Сигналізація PHP](https://leanpub.com/signalingphp) - Сигнали PCNLT чудово допомагають під час написання сценаріїв PHP, які запускаються з командного рядка.
-   [Мінімум життєздатних тестів](https://leanpub.com/minimumviabletests) - Багаторічний проповідник тестування PHP Кріс Харт'єс розповідає про те, що, на його думку, є мінімумом, який вам потрібно знати, щоб почати.
-   [Доменно-керований дизайн у PHP](https://leanpub.com/ddd-in-php) - Дивіться реальні приклади, написані на PHP, які демонструють архітектурні стилі проєктування, керовані доменом (шестикутна архітектура, CQRS або джерело подій), тактичні шаблони проєктування та інтеграцію обмеженого контексту.

[Догори](#top)

# <a name="community"></a>Спільнота

Спільнота PHP така ж різноманітна і велика, її учасники готові та бажають підтримати нових PHP-програмістів. Подумайте про те, щоб приєднатися до вашої місцевої групи користувачів PHP (PUG) або відвідати більші конференції PHP, щоб дізнатися більше про найкращі практики, наведені тут. Ви можете тусуватися на IRC на каналі #phpc [irc.freenode.com](https://webchat.freenode.net/?channels=phpc) і долучайтесь до облікового запису у Twitter [@phpc](https://twitter.com/phpc). Виходьте, знайомтеся з новими розробниками, вивчайте нові теми та, перш за все, заводьте нових друзів! Інші ресурси спільноти включають [StackOverflow](https://stackoverflow.com/questions/tagged/php).

[Прочитайте офіційний календар подій PHP](https://php.net/cal)

## <a name="user_groups"></a>Групи користувачів PHP (PUG)

Якщо ви живете у великому місті, швидше за все, поблизу є група користувачів PHP. Ви можете легко знайти свого місцевого PUG за адресою [PHP.ug](https://php.ug/). Можете глянути інші альтернативні джерела на [Meetup.com](https://www.meetup.com/find/) або загуглите `php user group near me` за допомогою вашої улюбленої пошукової системи (тобто. [Google](https://www.google.com/search?q=php+user+group+near+me)). Якщо ви живете в меншому місті, там може не бути місцевого PUG. Якщо це так - зробіть перший крок!

Окремо варто відзначити дві глобальні групи користувачів: [NomadPHP](https://nomadphp.com/) і [PHPWomen](https://twitter.com/PHPWomen). [NomadPHP](https://nomadphp.com/) пропонує двічі на місяць онлайн-зустрічі груп користувачів із презентаціями деяких із найкращих доповідачів спільноти PHP. [PHPWomen](https://twitter.com/PHPWomen) це неексклюзивна група користувачів, спочатку націлена на жінок у світі PHP. Членство відкрите для всіх, хто підтримує більш різноманітну спільноту. PHPWomen забезпечує мережу підтримки, наставництва та навчання, і загалом сприяє створенню «дружньої до жінок» та професійної атмосфери.

[Прочитайте про групи користувачів у PHP Wiki](https://wiki.php.net/usergroups)

## <a name="conferences"></a>Конференції PHP

Спільнота PHP також проводить більші регіональні та національні конференції в багатьох країнах світу. На цих великих заходах зазвичай виступають відомі члени PHP-спільноти, тож це чудова можливість навчитися безпосередньо від лідерів галузі.

[Знайдіть конференцію PHP](https://www.php.net/conferences/)

## <a name="elephpants"></a>ElePHPants

[ElePHPant](https://php.net/elephpant) - це той прекрасний талісман проєкту PHP із зображенням слона. Спочатку він був розроблений для проєкту PHP у 1998 році [Вінсентом Понтьє](http://www.elroubio.net/) - духовний батько тисяч elePHPants у всьому світі. А через десять років також народилися чарівні плюшеві іграшки-слоники. Тепер elePHPants присутні на багатьох PHP-конференціях і разом із багатьма PHP-розробниками за комп’ютерами для розваги та натхнення.

[Інтерв'ю з Вінсентом Понт'є](https://7php.com/elephpant/)

## <a name="credits"></a>Створено та підтримується

-   [Джош Локхарт](https://joshlockhart.com)
-   [Філ Стерджен](https://philsturgeon.uk/)
-   [Учасники проєкту](https://github.com/codeguy/php-the-right-way/graphs/contributors)
-   Переклад і доповнення - [Igor Ivashchenko](https://www.linkedin.com/in/lisdev)

[Ліцензія](https://creativecommons.org/licenses/by-nc-sa/3.0/)  

PHP: правильний шлях від [Джоша Локхарт](https://joshlockhart.com) має ліцензію [Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License](https://creativecommons.org/licenses/by-nc-sa/3.0/).  
За мотивами твору в [www.phptherightway.com](https://www.phptherightway.com).
