---
commit: b39a71025af2be4109c3857fd74acc9a220d7a38
---

# <a name="top"></a>[PHP _Правильний шлях_](/)

Останнє оновлення: 2022-06-22 14:52:52 +0000

Останнє оновлення перекладу: 2022-07-18 10:25:52 +0000

[Поділитися Twitter](https://twitter.com/intent/tweet?text=PHP+The+Right+Way+Українською&url=https%3A%2F%2Fphp.org.ua/php-the-right-way&hashtags=PHP)

# Зміст

- [Ласкаво просимо](#welcome)
  - [Переклади](#translations)
  - [Як зробити внесок](#how_to_contribute)
- [Початок роботи](#getting_started)
  - [Використовуйте поточну стабільну версію (8.1)](#use_the_current_stable_version)
  - [Вбудований веб-сервер](#builtin_web_server)
  - [Налаштування Mac](#mac_setup)
  - [Установка Windows](#windows_setup)
  - [Загальна структура каталогу](#common_directory_structure)
- [Посібник зі стилю коду](#code_style_guide)
- [Основні моменти мови](#language_highlights)
  - [Парадигми програмування](#programming_paradigms)
  - [Простори імен](#namespaces)
  - [Стандартна бібліотека PHP](#standard_php_library)
  - [Інтерфейс командного рядка](#command_line_interface)
  - [Xdebug](#xdebug)
- [Керування залежностями](#dependency_management)
  - [Composer і packagist](#composer_and_packagist)
  - [PEAR](#pear)
- [Практики кодування](#coding_practices)
  - [Основи](#the_basics)
  - [Дата й час](#date_and_time)
  - [Патерни проєктування](#design_patterns)
  - [Робота з UTF-8](#php_and_utf8)
  - [Інтернаціоналізація та локалізація](#i18n_l10n)
- [Ін'єкція залежності](#dependency_injection)
  - [Основна концепція](#basic_concept)
  - [Складність проблеми](#complex_problem)
  - [Контейнери](#containers)
  - [Додаткова інформація](#dependency_injection_more)
- [Бази даних](#databases)
  - [Розширення MySQL](#mysql_extension)
  - [Розширення PDO](#pdo_extension)
  - [Взаємодія з базами даних](#databases_interacting)
  - [Шари абстракції](#databases_abstraction_layers)
- [Шаблони](#templating)
  - [Переваги](#templating_benefits)
  - [Прості шаблони PHP](#plain_php_templates)
  - [Компільовані шаблони](#compiled_templates)
  - [Додаткова інформація](#templating_further_reading)
- [Помилки та винятки](#errors_and_exceptions)
  - [Помилки](#errors)
  - [Винятки](#exceptions)
- [Безпека](#security)
  - [Безпека веб-додатків](#web_application_security)
  - [Хешування пароля](#password_hashing)
  - [Фільтрування даних](#data_filtering)
  - [Файли конфігурації](#configuration_files)
  - [Реєстрація Globals](#register_globals)
  - [Звіт про помилку](#error_reporting)
- [Тестування](#testing)
  - [Розробка, орієнтована на тестування](#test_driven_development)
  - [Розробка, керована поведінкою](#behavior_driven_development)
  - [Додаткові інструменти тестування](#complementary_testing_tools)
- [Сервери та розгортання](#servers_and_deployment)
  - [Платформа як послуга (PaaS)](#platform_as_a_service)
  - [Віртуальні або виділені сервери](#virtual_or_dedicated_servers)
  - [Спільні сервери](#shared_servers)
  - [Створення та розгортання вашої програми](#building_and_deploying_your_application)
- [Віртуалізація](#virtualization)
  - [Vagrant](#vagrant)
  - [Docker](#docker)
- [Кешування](#cache)
  - [Opcode кеш](#opcode_cache)
  - [Кешування об'єктів](#object_caching)
- [Документування вашого коду](#documenting)
  - [PHPDoc](#phpdoc)
- [Ресурси](#resources)
  - [З джерела](#from_the_source)
  - [Люди, на яких варто підписатись](#people_to_follow)
  - [Постачальники PHP PaaS](#php_paas_providers)
  - [Фреймворки](#frameworks)
  - [Компоненти](#components)
  - [Інші корисні ресурси](#other_resources)
  - [Відеоуроки](#videos)
  - [Книги](#books)
- [Спільнота](#community)
  - [Групи користувачів](#user_groups)
  - [Конференції](#conferences)
  - [Слони](#elephpants)
- [Створено та підтримується](#credits)

# <a name="welcome"></a>Ласкаво просимо

В Інтернеті є багато застарілої інформації, яка веде нового PHP
програміста в оману, поширюючи погані практики та небезпечний код. _PHP: Right Way_ —
це легкий для читання короткий довідник для популярної мови програмування PHP.
Також тут ви знайдете стандарти, посилання на авторитетні навчальні посібники в Інтернеті та
на інформацію, яку учасники цієї спільноти вважають найкращою практикою на даний момент.

_Немає канонічного способу використання PHP_. Цей веб-сайт має на меті представити
нових розробників PHP до деяких тем, які вони, можливо, не торкались до цього
моменту, і має на меті дати досвідченим професіоналам кілька свіжих ідей щодо
тем, якими вони займалися роками, ніколи не переглядаючи їх. Цей
веб-сайт також не підкаже вам, які інструменти використовувати, а натомість запропонує
пропозиції щодо кількох варіантів із поясненням, коли це можливо, а також
відмінності в підходах і варіанти використання.

Це живий документ, і він буде постійно оновлюватись, дадаючи корисну інформацію та приклади.

## <a name="translations"></a> Переклади

_PHP: The Right Way_ перекладається багатьма різними мовами:

- [англійською](http://www.phptherightway.com)
- [Español](http://phpdevenezuela.github.io/php-the-right-way)
- [Français](http://eilgin.github.io/php-the-right-way/)
- [Індонезія](http://id.phptherightway.com)
- [Італійський](http://it.phptherightway.com)
- [Polski](http://pl.phptherightway.com)
- [Português do Brasil](http://br.phptherightway.com)
- [Руманська](https://bgui.github.io/php-the-right-way/)
- [Slovenščina](http://sl.phptherightway.com)
- [Srpski](http://phpsrbija.github.io/php-the-right-way/)
- [Türkçe](http://hkulekci.github.io/php-the-right-way/)
- [български](http://bg.phptherightway.com)
- [Русский язык](http://getjump.github.io/ru-php-the-right-way)
- [Українська](https://php.org.ua/) - цей посібник
- [Українська](http://iflista.github.io/php-the-right-way/)
- [العربية](https://adaroobi.github.io/php-the-right-way/)
- [فارسى](http://novid.github.io/php-the-right-way/)
- [ภาษาไทย](https://apzentral.github.io/php-the-right-way/)
- [한국어판](http://modernpug.github.io/php-the-right-way)
- [日本語](http://ja.phptherightway.com)
- [简体中文](https://laravel-china.github.io/php-the-right-way/)
- [繁體中文](https://laravel-taiwan.github.io/php-the-right-way)

## <a name="book"></a> Книга

Найновіша версія _PHP: The Right Way_ також доступна в
форматі PDF, EPUB і MOBI [на Leanpub](https://leanpub.com/phptherightway)

## <a name="how_to_contribute"></a> Як зробити внесок

Допоможіть зробити цей веб-сайт найкращим ресурсом для нових PHP-програмістів!
[Зробіть внесок GitHub](https://github.com/ukrainesoft/php-the-right-way/edit/master/README.md)

[На початок](#top)

# <a name="getting_started"></a> Починаємо

## <a name="use_the_current_stable_version"></a> Використовуйте поточну стабільну версію (8.1)

Якщо ви починаєте працювати з PHP, почніть з поточної стабільної версії
[PHP 8.1](http://php.net/downloads.php). PHP 8.x додає багато
[нових функцій](#language_highlights) порівняно зі старішими версіями 7.x і 5.x
версії. PHP був значною мірою переписаний, і тепер значно
швидше, ніж старі версії. PHP 8 — це велике оновлення мови, він
містить багато нових функцій і оптимізацій.

Можно спробуйте швидко оновити з останньої стабільної версії PHP 5.6
[яка вже не підтримується](http://php.net/supported-versions.php).
Оновити легко, оскільки існує не так багато [проблем зворотної сумісності](http://php.net/manual/migration81.incompatible.php). Якщо ви не впевнені, у якій версії є функція, ви можете перевірити
документацію PHP на веб-сайті [php.net](http://php.net/manual/).

## <a name="builtin_web_server"></a> Вбудований веб-сервер

З PHP 5.4 або новішої версії ви можете почати вивчати PHP без інсталяції та
налаштування повноцінного веб-сервера. Щоб запустити сервер, запустіть
наступну команда з вашого терміналу в кореневій папці вашого проекту:

```sh
php -S localhost:8000
```

- [Дізнайтеся про вбудований веб-командний рядок сервер](http://php.net/features.commandline.webserver)

## <a name="mac_setup"></a> Налаштування Mac

macOS постачається з вже встановленим PHP, але зазвичай він трохи відстає від
останної версії. Є кілька способів інсталювати останню версію PHP
версію для macOS.

### Встановіть PHP через Homebrew

[Homebrew](https://brew.sh/) - це менеджер пакетів для macOS, який допомагає
легко встановити PHP і різні розширення. Ядро Homebrew
репозиторій містить «формули» для PHP 5.6, 7.0, 7.1, 7.2, 7.3, 7.4, 8.0
і PHP 8.1. Встановіть останню версію за допомогою цієї команди:

```sh
brew встановити php@8.1
```

Ви можете переключатися між версіями PHP Homebrew, змінюючи змінну `PATH`.
Як варіант, ви можете використовувати
[brew-php-switcher](https://github.com/philcook/brew-php-switcher) та
автоматично змінювати версії PHP.

Ви також можете перемикатися між версіями PHP вручну, від’єднавши та
підключення потрібної версії:

```sh
brew unlink php
brew link --overwrite php@8.0
```

```sh
brew unlink php
brew link --overwrite php@8.1
```

### Встановіть PHP через Macports

Проект [MacPorts](https://www.macports.org/install.php) є
ініціативою спільноти з відкритим кодом для створення простої у використанні системи для
компіляції, інсталяції та оновлення командного рядка, X11 та програмне забезпечення Aqua
з відкритим вихідним кодом на основі операційної системи OS X.

MacPorts підтримує попередньо скомпільовані файли, тому вам не потрібно перекомпілювати
кожну залежність. Це врятує ваше життя, якщо у вашій системі не встановлено жодного пакета.

На цьому етапі ви можете встановити `php54`, `php55`, `php56`, `php70`,
`php71`, `php72`, `php73`, `php74`, `php80` або `php81` за допомогою
команди `port install`, наприклад:

```sh
sudo port install php74
sudo port install php81
```

І ви можете запустити команду `select`, щоб переключити ваш активний PHP:

```sh
sudo port select --set php php81
```

### Встановіть PHP через phpbrew

[phpbrew](https://github.com/phpbrew/phpbrew) — інструмент для встановлення
і керування кількома версіями PHP. Це може бути дуже корисно, якщо дві
різні програми/проекти вимагають різних версій PHP, а також
ви не використовуєте віртуальні машини.

### Встановіть PHP за допомогою бінарного інсталятора Liip

Іншим популярним варіантом є [php-osx.liip.ch](https://php-osx.liip.ch/)
який надає один метод встановлення для версій від 5.3 до
7.3. Він не перезаписує файли PHP, встановлені Apple, але
встановлює все в окремому місці (/usr/local/php5).

### Скомпілювати з вихідного коду

Ще один варіант, який дає вам можливість контролювати вашу версію PHP - це
[скомпілювати його для себе](https://secure.php.net/install.macosx.compile). В такому разі
переконайтеся, що встановлено
[Xcode](https://github.com/kennethreitz/osx-gcc-installer) або Apple
substitute ["Інструменти командного рядка для XCode"](https://developer.apple.com/downloads),
який можна завантажити з Apple Центру розробників Mac.

### Універсальні інсталятори

Перераховані вище рішення в основному обробляють сам PHP, а не постачають
такі речі, як [Apache](https://httpd.apache.org/),
[Nginx](https://www.nginx.com/) або сервер SQL. Рішення «все в одному».
наприклад [MAMP](https://www.mamp.info/en/downloads/) і
[XAMPP](https://www.apachefriends.org/index.html) - встановлять ці й
інші частини програмного забезпечення для вас й будуть зв’язати їх усі разом,
але легкість налаштування передбачає компроміс гнучкості.

## <a name="windows_setup"></a> Налаштування Windows

Ви можете завантажити бінарні файли з
[windows.php.net/download](http://windows.php.net/download/). Після
вилучення PHP, рекомендується встановити
[PATH](http://www.windows-commandline.com/set-path-command-line/) в
корінь папки PHP (де знаходиться php.exe), щоб ви могли виконати
PHP з будь-якого місця.

Для навчання та локальної розробки ви можете використовувати вбудований веб-сервер
з PHP 5.4+, тому вам не потрібно турбуватися про його налаштування. Якщо ти
хотів би «все-в-одному», який включає повномасштабний веб-сервер і
MySQL також, й інші такі інструменти, то оберіть
[XAMPP](http://www.apachefriends.org/en/xampp.html),
[EasyPHP](http://www.easyphp.org/), [OpenServer](http://open-server.ru/)
чи [WAMP](http://www.wampserver.com/en/). Це допоможе отримати у Windows
швидко працююче середовище розробки. Тим не менш, ці інструменти будуть
дещо відрізнятися від того, що буде на реальному сервері,
тому будьте обережні з навколишнім середовищем, якщо ви працюєте в Windows і
розгортаєте в Linux.

Якщо вам потрібно запустити робочу систему на Windows, то IIS7 може
забезпечити найстабільнішу та найкращу продуктивність. Ви можете використовувати
[phpmanager](http://phpmanager.codeplex.com/) (плагін GUI для IIS7) що
спрощуює налаштування та керування PHP. IIS7 поставляється з вбудованим FastCGI
і готовий до роботи, вам просто потрібно налаштувати PHP як обробник. Для
підтримки та додаткових ресурсів є [окрема область на iis.net](http://php.iis.net/) для PHP.

Як правило, ваша програма працює в різноманітному середовищі
розробки та продакшені, що може призвести до появи дивних помилок.
Якщо ви розробляєте в Windows і розгортаєте в Linux (або
все, що не відноситься до Windows), то вам слід розглянути можливість використання
[віртуальних машин](#virtualization_title).

Кріс Танкерслі має дуже корисну публікацію в блозі про те, які інструменти він використовує для
робити [Розробка PHP за допомогою Windows](http://ctankersley.com/2016/11/13/developing-on-windows-2016/).

## <a name="common_directory_structure"></a> Загальна структура каталогу

Поширене запитання тих, хто починає писати вебсайти: «куди я покладу свої файли?»
Роками відповідь була постійно «там, де знаходиться `DocumentRoot`».
Хоча ця відповідь є не завершеною, це чудове місце для початку.

З міркувань безпеки конфігураційні файли не повинні бути доступні для a
відвідувачі сайту; тому загальнодоступні сценарії зберігаються в public
каталозі і приватні конфігурації та дані зберігаються за межами цього
каталогу.

Для кожної команди, CMS або фреймворку, в якому хтось працює, є стандартна структура
каталогу і вона використовується кожною з них по-своєму. Однак, якщо хтось починає проект сам,
знати, яку структуру файлової системи використовувати, може бути складно.

[Пол М. Джонс](http://paul-m-jones.com/) зробив фантастичне
дослідження загальних практик десятків тисяч проектів github
у сфері PHP. Він склав стандартні файли і структури каталогу в
[Стандартний пакет PHP Skeleton](https://github.com/php-pds/skeleton),
на основі цього дослідження. У цій структурі каталогу `DocumentRoot` має
вказувати на `public/`,
модульні тести мають бути в каталозі `tests/`, а код сторонніх розробників
бібліотеки встановлених через [composer](#composer_and_packagist), має бути
у каталозі vendor/. Для інших файлів і каталогів, дотримання
[PHP Skeleton](https://github.com/php-pds/skeleton) має сенс для всіх учасників проекту.

[На початок](#top)

# <a name="code_style_guide"></a> Керівництво по стилю коду

Спільнота PHP є великою та різноманітною, складається з незліченної кількості
бібліотек, фреймворків та компонентів. Це звичайне явище для розробників PHP
вибрати декілька з них і об’єднати їх в один проект.
Важливо, щоб код PHP відповідав (якомога ближче) загальному код
стайлу, щоб полегшити розробникам комбінування та поєднання різних бібліотек
у своїх проектів.

[Framework Interop Group](https://www.php-fig.org/) запропонувала та
затвердила низку рекомендацій щодо стилю. Не всі вони стосуються
код стайлу, але ті, які це роблять, є
[PSR-1](https://www.php-fig.org/psr/psr-1/),
[PSR-12](https://www.php-fig.org/psr/psr-12/) і
[PSR-4](https://www.php-fig.org/psr/psr-4/). Ці рекомендації є
простим набором правил, які вже використовують багато проектів, як Drupal, Zend, Symfony,
Переймаються Laravel, CakePHP, phpBB, AWS SDK, FuelPHP, Lithium тощо.
Ви можете використовувати їх для власних проектів або продовжувати використовувати власний
особистий стиль (що не є гарною практикою програмування)

В ідеалі ви повинні написати код PHP, який відповідає відомому стандарту.
Це може бути будь-яка комбінація PSR або один із стандартів кодування
виробництва PEAR або Zend. Це означає, що інші розробники можуть легко читати та
працювати з вашим кодом, і програми, які реалізують компоненти, можуть
мати узгодженість навіть при роботі з великою кількістю коду сторонніх розробників.

- [Читати про PSR-1](https://www.php-fig.org/psr/psr-1/)
- [Прочитайте про PSR-12](https://www.php-fig.org/psr/psr-12/)
- [Прочитайте про PSR-4](https://www.php-fig.org/psr/psr-4/)
- [Прочитайте про PEAR Стандарти Кодування](https://pear.php.net/manual/en/standards.php)
- [Прочитайте про Symfony Coding Style](https://symfony.com/doc/current/contributing/code/standards.html)

Ви можете використовувати
[PHP_CodeSniffer](https://pear.php.net/package/PHP_CodeSniffer/) та
перевірити код на відповідність будь-якій із цих рекомендацій за допомогою плагінів для
текстових редакторів, такі як [Sublime phpcs](https://github.com/benmatselby/sublime-phpcs), який надасть
вам зворотній зв'язок у реальному часі.

Ви можете виправити макет коду автоматично, використовуючи один з наведених нижче інструментів

- [PHP Coding Standards Fixer](https://cs.symfony.com/) який має дуже добре перевірену кодову базу.
- Крім того, [PHP Code Beautifier і Fixer](https://github.com/squizlabs/PHP_CodeSniffer/wiki/Fixing-Errors-Automatically)
  інструмент, який входить до складу PHP_CodeSniffer, можна використовувати для налаштування вашого коду відповідно.

І ви можете запустити phpcs вручну з оболонки:

```sh
phpcs -sw --standard=PSR1 file.php
```

Він покаже помилки та опише, як їх виправити. Це також може бути корисним
щоб включити цю команду в git hook. Таким чином, гілки, які містять
порушення вибраного стандарту не можуть увійти до сховища, доки
ці порушення не усунуто.

Якщо у вас є PHP_CodeSniffer, ви можете виправити проблеми з компонуванням коду автоматично за допомогою
[PHP Code Beautifier і Fixer](https://github.com/squizlabs/PHP_CodeSniffer/wiki/Fixing-Errors-Automatically).

```sh
phpcbf -w --standard=PSR1 file.php
```

Іншим варіантом є використання [стандартів кодування PHP Fixer](https://cs.symfony.com/).
Він покаже, які саме помилки структури коду мали до того, як програма їх виправила.

```sh
php-cs-fixer fix -v --rules=@PSR1 file.php
```

Англійська мова є переважною для всіх назв символів та кодової інфраструктури.
Коментарі можуть бути написані будь-якою мовою, легкою для читання всіма поточними
і майбутніми сторонами, які можуть працювати над кодовою базою.

Нарешті, хороший додатковий ресурс для написання чистого коду PHP
[Чистий код PHP](https://github.com/jupeter/clean-code-php).

[На початок](#top)

# <a name="language_highlights"></a> Основні моменти мови

## <a name="programming_paradigms"></a> Парадигми програмування

PHP — це гнучка, динамічна мова, яка підтримує різноманітні
техніки програмування. З роками він різко еволюціонував,
зокрема додавання надійної об’єктно-орієнтованої моделі в PHP 5.0 (2004),
анонімні функції та простори імен у PHP 5.3 (2009), а також трейти в PHP
5.4 (2012).

### Об'єктно-орієнтоване програмування

PHP має дуже повний набір функцій об’єктно-орієнтованого програмування
включаючи підтримку класів, абстрактних класів, інтерфейсів,
успадкування, конструктори, клонування, винятки тощо.

- [Читати про об'єктно-орієнтований PHP](https://secure.php.net/language.oop5)
- [Читати про трейти](https://secure.php.net/language.oop5.traits)

### Функціональне програмування

PHP підтримує першокласні функції, тобто функція може бути
присвоєна змінній. Можуть бути як визначені користувачем, так і вбудовані функції
на які посилається змінна та які викликаються динамічно. Функції можуть бути
передані як аргументи іншим функціям (функція під назвою _функція вищого порядку_) і
функції можуть повертати інші функції.

Підтримується рекурсія: функція може викликати саму себе.
Але більшість коду PHP зосереджено на ітераціях.

Відтоді з’явилися нові анонімні функції (з підтримкою замикань).
PHP 5.3 (2009).

У PHP 5.4 додано можливість прив’язувати замикання до області видимості об’єкта, а також
покращена підтримка викликів, щоб їх можна було використовувати
майже у всіх випадках взаємозамінні з анонімними функціями.

- Продовжуйте читати про [Функціональне програмування в PHP](https://phptherightway.com/pages/Functional-Programming.html)
- [Читати про анонімні функції](https://secure.php.net/functions.anonymous)
- [Прочитайте про клас Closure](https://secure.php.net/class.closure)
- [Детальніше у розділі замикання RFC](https://wiki.php.net/rfc/closures)
- [Читати про Callables](https://secure.php.net/language.types.callable)
- [Прочитайте про динамічний виклик функцій за допомогою `call_user_func_array()`](https://secure.php.net/function.call-user-func-array)

### Метапрограмування

PHP підтримує різні форми метапрограмування за допомогою таких механізмів, як
Reflection API і Magic Methods. Існує багато магічних методів
таких як `__get()`, `__set()`, `__clone()`, `__toString()`,
`__invoke()` тощо, які дозволяють розробникам підключатися до поведінки класу.
Розробники Ruby часто кажуть, що PHP бракує `method_missing`, але така поведінка
може бути додана завдяки `__call()` і `__callStatic()`.

- [Читати про магічні методи](https://secure.php.net/language.oop5.magic)
- [Читати про Reflection](https://secure.php.net/intro.reflection)
- [Читати про перевантаження](https://secure.php.net/language.oop5.overloading)

## <a name="namespaces"></a> Простори імен

Як згадувалося вище, спільнота PHP має багато розробників, які створюють
багато коду. Це означає, що PHP-код однієї бібліотеки може використовувати те саме
ім'я класу як інше. Коли обидві бібліотеки використовуються одночасно
без простору імен, вони стикаються і спричиняють проблеми.

_Простори імен_ вирішують цю проблему. Як описано в довідці PHP, простори імен можна
порівняти з каталогами операційної системи: два файли з однаковою назвою можуть співіснувати окремо
у різних папках. Подібним чином можуть співіснувати два класи PHP з однаковою назвою
в окремих просторах імен PHP. Ось так просто.

Для вас важливо створити namespace для свого коду, щоб його могли використовувати
іншими розробниками, не боячись зіткнення з іншими бібліотеками.

Один із рекомендованих способів використання просторів імен викладено в
[PSR-4](https://www.php-fig.org/psr/psr-4/), метою якого є надання
стандартних імен файл, класу і namespace, щоб дозволити лего підключити ваш код.

У жовтні 2014 року PHP-FIG позначив застарілим попереднє автозавантаження стандартом
[PSR-0](https://www.php-fig.org/psr/psr-0/).
PSR-0 і PSR-4 все ще цілком придатні для використання. Останній вимагає PHP 5.3 та більше,
в той час я проєкти на PHP 5.2 й меньше реалізують PSR-0.

Якщо ви збираєтеся використовувати стандартний автозавантажувач для нової програми або
пакет, загляньте в PSR-4.

- [Прочитайте про простори імен](https://secure.php.net/language.namespaces)
- [Прочитайте про PSR-0](https://www.php-fig.org/psr/psr-0/)
- [Прочитайте про PSR-4](https://www.php-fig.org/psr/psr-4/)

## <a name="standard_php_library"></a> Стандартна бібліотека PHP

Стандартна бібліотека PHP (SPL) - вже укомплектована в PHP і забезпечує
колекцію класів та інтерфейсів. Ван складається в основному з
зазвичай необхідних структур даних (стек, черга, купа тощо),
й ітераторів, які можуть проходити через ці структури даних або ваші власні
класи, які реалізують інтерфейси SPL.

- [Прочитайте про SPL](https://secure.php.net/book.spl)
- [Відеокурс СПЛ на Lynda.com (платно)](https://www.lynda.com/PHP-tutorials/Up-Running-Standard-PHP-Library/175038-2.html)

## <a name="command_line_interface"></a> Інтерфейс командного рядку

PHP був створений для написання веб-додатків, але також корисний для
створення сценаріїв програм інтерфейсу командного рядка (CLI). Командний рядок PHP
може допомогти автоматизувати типові завдання, як-от тестування, розгортання, адміністрування програми тощо.

Програми CLI PHP є потужними, оскільки ви можете використовувати код своєї програми
безпосередньо без необхідності створювати та захищати веб-графічний інтерфейс користувача. Просто
звичайно **не** розміщувати свої сценарії CLI PHP у загальнодоступному веб-корені!

Спробуйте запустити PHP з командного рядка:

```sh
php -i
```

Параметр `-i` надрукує вашу конфігурацію PHP так само, як і
Функція [`phpinfo()`](https://secure.php.net/function.phpinfo).

Параметр «-a» забезпечує інтерактивну оболонку, подібну до IRB або Ruby
інтерактивна оболонка python. Існує ряд інших корисних
[команд параметри рядка](https://secure.php.net/features.commandline.options).

Давайте напишемо просту програму CLI «Hello, $name». Щоб спробувати, створіть a
файл із назвою `hello.php`, як показано нижче.

```php
<?php
if ($argc !== 2) {
    echo "Використання: php hello.php <ім'я>" . PHP_EOL;
    exit(1);
}
$name = $argv[1];
echo "Привіт, $name" . PHP_EOL;
```

PHP встановлює дві спеціальні змінні на основі аргументів вашого скрипту.
[`$argc`](https://secure.php.net/reserved.variables.argc) є
цілочисельна змінна, що містить аргумент _count_ і
[`$argv`](https://secure.php.net/reserved.variables.argv) — це
змінна, що містить масив із _значенням_ кожного аргументу. Перший аргумент
завжди ім’я вашого файлу сценарію PHP, у цьому випадку `hello.php`.

Вираз `exit()` використовується з ненульовим числом, щоб дозволити оболонці
знати, що команда не виконана. Можна знайти типові коди виходу
[на сайті gsp](https://www.gsp.com/cgi-bin/man.cgi?section=3&topic=sysexits).

Щоб запустити наш сценарій, наведений вище, з командного рядка:

```sh
php hello.php
Використання: php hello.php <ім'я>
php hello.php Мир
Привіт Мир
```

- [Дізнайтеся про запуск PHP із командного рядка](https://secure.php.net/features.commandline.options)

## <a name="xdebug"></a> Xdebug

Одним із найкорисніших інструментів у розробці програмного забезпечення є дебаггер.
Він дозволяє відстежувати виконання вашого коду та контролювати
вміст стека. Xdebug, налагоджувач PHP, можна використовувати
через різні IDE для забезпечення точок зупину та перевірки стека. Це також
дозволяє таким інструментам, як PHPUnit і KCacheGrind, виконувати охоплення коду,
аналіз і його профілювання.

Якщо ви опинилися в безвиході, та й готові вдатися до
`var_dump()`/`print_r()`, і ви все ще не можете знайти рішення - можливо
потрібно використовувати дебагер.

[Встановлення Xdebug](https://xdebug.org/docs/install) може бути трохи складним, але
однією з його найважливіших функцій є «Віддалене налагодження» - якщо ви
розробити код локально, а потім захочете протестувати його всередині віртуальної машини або на іншому сервері,
віддалене налагодження - це функція, яку ви захочете увімкнути одразу.

Традиційно ви змінюєте свій VHost Apache або файл .htaccess за допомогою
таких значення:

```ini
php_value xdebug.remote_host 192.168.?.?
php_value xdebug.remote_port 9000
```

«Віддалений хост» і «віддалений порт» відповідатимуть вашому локальному
комп’ютеру на порт, на якому ви налаштували IDE для прослуховування. Потім
ви вмикаєте вашу IDE на режим «прослуховування з’єднань»
і завантажуєте вашу URL-адресу:

```sh
http://your-website.example.com/index.php?XDEBUG_SESSION_START=1
```

Ваша IDE тепер перехоплюватиме поточний стан під час виконання сценарію,
що дозволяє встановлювати контрольні точки та перевіряти значення в пам’яті.

Графічні налагоджувачі дозволяють дуже легко переглядати код, перевіряти його
змінні та код оцінки щодо живого середовища виконання. Багато IDE мають
вбудовану підтримка або підтримка плагінів для графічного налагодження за допомогою Xdebug.
MacGDBp — це безкоштовний автономний графічний інтерфейс Xdebug із відкритим кодом для Mac.

- [Докладніше про Xdebug](https://xdebug.org/docs/)
- [Докладніше про MacGDBp](https://www.bluestatic.org/software/macgdbp/)

[На початок](#top)

# <a name="dependency_management"></a> Керування залежностями

Є маса бібліотек PHP, фреймворків і компонентів на ваш вибір.
Ваш проект, ймовірно, використовуватиме декілька з них — це проект
залежності. Донедавна PHP не мав хорошого способу для керування
ціма залежностями проєкту. Навіть якщо ви керували ними вручну, вам би все одно
довелося потурбуватися про автозавантажувачі. Зараз це вже не проблема.

Зараз існує дві основні системи керування пакетами для PHP -
[Composer](#composer_and_packagist) і [PEAR](#pear). Композитор є
на даний момент найпопулярнішим менеджером пакунків для PHP, до цього PEAR був
основним менеджером пакунків у використанні.

## <a name="composer_and_packagist"></a> Composer і Packagist

Composer — рекомендований менеджер залежностей для PHP. Перелічіть свої
залежності проекту у файлі `composer.json` і з кількома простими
командами, Composer автоматично завантажить ваш проект необхідні
залежності та налаштує автозавантаження для вас. Composer аналогічний NPM
у світі node.js або Bundler у світі Ruby.

Існує безліч бібліотек PHP, які сумісні з Composer
і готові до використання у вашому проекті. Ці «пакети» перераховані на
[Packagist](https://packagist.org/), офіційне сховище для
бібліотек PHP, які сумісні з Composer.

### Як встановити Composer

Найбезпечніший спосіб завантажити composer —
[дотримуватись офіційної інструкції](https://getcomposer.org/download/).
Це дозволить перевірити інсталятор на пошкодження і на зміни. Інсталятор встановлює
бінарний файл `composer.phar` у вашому _поточному робочому каталозі_.

```sh
php -r "copy('https://getcomposer.org/installer', 'composer-setup.php');"
php composer-setup.php
php -r "unlink('composer-setup.php');"
```

Ми рекомендуємо інсталювати Composer _глобально_ (наприклад, зробив копію в
`/usr/local/bin`). Для цього виконайте наступну команду:

```sh
mv composer.phar /usr/local/bin/composer
```

**Примітка:** Якщо вищевказане не вдається через дозволи, додайте префікс `sudo`.

Щоб запустити локально встановлений Composer, скористайтеся `php composer.phar`,
якщо встановили його глобально - то `composer`.

#### Встановлення на Windows

Для користувачів Windows найпростішим способом почати роботу є використання
Інсталятор [ComposerSetup](https://getcomposer.org/Composer-Setup.exe),
який виконує глобальне встановлення та налаштовує ваш `$PATH`, щоб ви могли
просто викличте `composer` з будь-якого каталогу у вашому командному рядку.

### Як визначити та встановити залежності

Composer відстежує залежності вашого проекту у файлі під назвою
`composer.json`. Ви можете керувати ним вручну, якщо хочете, або скористайтеся Composer.
Команда `composer require` додає залежність проекту та якщо
у вас немає файлу `composer.json`, його буде створено. Ось
приклад, який додає [Twig](https://twig.symfony.com/) як залежність
ваш проект.

```sh
composer require twig/twig:^2.0
```

Крім того, команда `composer init` проведе вас через це
створення повного файлу `composer.json` для вашого проекту. Так чи інакше, один раз
ви створили свій файл `composer.json`, який можете вказати Composer
завантажте та встановіть ваші залежності в каталог `vendor/`.
Це також стосується завантажених вами проектів, які вже є у файлі
файл `composer.json`:

```sh
composer install
```

Далі додайте цей рядок до основного файлу PHP вашої програми; це вкаже PHP
що треба використовувати автозавантажувач Composer для залежностей вашого проекту.

```php
<?php
require 'vendor/autoload.php';
```

Тепер ви можете використовувати ваші залежності проекту, і вони будуть автоматично завантажені
при запиті.

### Оновлення ваших залежностей

Composer створює файл під назвою `composer.lock`, який зберігає точні дані для
`composer install`. Якщо ви ділитеся своїм проектом з іншими, переконайтеся, що
файл `composer.lock` включено, щоб під час запуску
`composer install` вони отримають ті самі версії, що й ви. Щоб оновити свої
залежності, запустіть `composer update`. Не використовуйте `composer update` для розгорнення проєкту,
лише `composer install`, інакше ви можете отримати різні версії пакетів на серверах.

Це найбільш корисно, коли ви гнучко визначаєте вимоги до версії.
Наприклад, вимога до версії `~1.8` означає «щось новіше, ніж
`1.8.0`, але менше ніж `2.0.x-dev`». Ви також можете використовувати символ підстановки `*`
як у `1.8.*`. Тепер команда Composer `composer update` оновить усі
ваші залежності до найновішої версії, яка відповідає вашим обмеженням.

### Сповіщення про оновлення

Щоб отримувати сповіщення про випуск нових версій, ви можете зареєструватися
на [libraries.io](https://libraries.io/). Це веб-сервіс, який може контролювати
залежності та надсилати вам сповіщення про оновлення.

### Перевірка ваших залежностей на наявність проблем із безпекою

[Безпека локального PHP Checker](https://github.com/fabpot/local-php-security-checker) є
інструментом командного рядка, який перевірить ваш файл `composer.lock` і повідомить
вас, якщо вам потрібно оновити будь-які ваші залежності.

### Обробка глобальних залежностей за допомогою Composer

Composer також може обробляти глобальні залежності та їхні бінарні файли. Використання
є простим, все, що вам потрібно зробити, це додати до вашої команди префікс
`global`. Якщо, наприклад, ви хочете встановити PHPUnit і мати його
доступним глобально, потрібно виконати таку команду:

```sh
composer global require phpunit/phpunit
```

Це створить папку `~/.composer`, де будуть зберігатися всі ваші глобальні залежності.
Щоб бінарні файли встановлених пакетів були доступні всюди,
додайте папку `~/.composer/vendor/bin` до змінної свого `$PATH` (опціонально).

- [Дізнайтеся про Composer](https://getcomposer.org/doc/00-intro.md)

## <a name="pear"></a> PEAR

Ветеранський менеджер пакетів, який подобається деяким розробникам PHP
[PEAR](https://pear.php.net/). Він поводиться подібно до Composer, але має
деякі помітні відмінності.

PEAR вимагає, щоб кожен пакет мав певну структуру, що означає
що автор пакунка повинен підготувати його для використання з PEAR.
Використання проекту, який не був підготовлений для роботи з PEAR, неможливо.

PEAR встановлює пакети глобально, тобто після їх одноразового встановлення
вони доступні для всіх проектів на цьому сервері. Це може бути добре, якщо
багато проектів покладаються на той самий пакет з тією самою версією, але можуть
призвести до проблем, якщо виникають конфлікти версій між двома проектами.

### Як встановити PEAR

Ви можете встановити PEAR, завантаживши інсталятор `.phar` і виконавши його.
У документації PEAR детально описано [інструкції](https://pear.php.net/manual/installation.getting.php) для
кожна операційної операційної системи.

Якщо ви використовуєте Linux, ви також можете переглянути свій дистрибутивний
менеджер пакетів. Debian і Ubuntu, наприклад, мають відповідний `php-pear`
пакет.

### Як встановити пакет

Якщо пакет указано в [пакетах PEAR list](https://pear.php.net/packages.php), ви можете встановити його за допомогою зазначення офіційної назви:

```sh
pear install foo
```

Якщо пакет розміщено на іншому каналі, вам потрібно `discover`
канал і також вказати його під час встановлення. Дивіться
[інструкцію](https://pear.php.net/manual/guide.users.commandline.channels.php)
для отримання додаткової інформації на цю тему.

- [Дізнайтеся про PEAR](https://pear.php.net/)

Якщо ви вже використовуєте [Composer](#composer_and_packagist) і ви
хотіли б встановити код PEAR, для цього можна використовувати Composer
ваші залежності від PEAR. У цьому прикладі буде встановлено код із
`pear2.php.net`:

```json
{
  "repositories": [
    {
      "type": "pear",
      "url": "https://pear2.php.net"
    }
  ],
  "require": {
    "pear-pear2/PEAR2_Text_Markdown": "*",
    "pear-pear2/PEAR2_HTTP_Request": "*"
  }
}
```

Перший розділ `"repositories"` буде використано, щоб повідомити Composer що він
має «ініціалізувати» (або «відкрити» в термінології PEAR) репозиторій pear.
Тоді розділ `require` матиме префікс імені пакета таким чином:

```
pear-channel/Package
```

Префікс "pear" жорстко закодований, щоб уникнути будь-яких конфліктів. Назва
може бути такою ж, як і назва іншого постачальника пакунків, наприклад, тоді
коротку назву каналу (або повну URL-адресу) можна використовувати для посилання на канал
із пакетом.

Коли цей код буде встановлено, він буде доступний у вашому каталозі `vendor`
та автоматично доступний через автозавантажувач Composer:

```
vendor/pear-pear2.php.net/PEAR2_HTTP_Request/pear2/HTTP/Request.php
```

Щоб використовувати цей пакет PEAR, просто посилайтеся на нього так:

```php
<?php
$request = new pear2\HTTP\Request();
```

- [Дізнайтеся більше про використання PEAR з Composer](https://getcomposer.org/doc/05-repositories.md#pear)

[На початок](#top)

# <a name="coding_practices"></a> Практики кодування

## <a name="the_basics"></a> Основи

PHP — це велика мова, яка надає можливість програмістам усіх рівнів
створити код не тільки швидко, але й ефективно. Однак, поки просуваючись
через мову ми часто забуваємо основи, які вивчили спочатку
(або пропускаємо) на користь коротких шляхів і/або шкідливих звичок. Щоб допомогти боротися
з цією поширеною проблемою, цей розділ має на меті нагадати програмістам про
основні практики кодування в PHP.

- Продовжуйте читати на [Основи](https://phptherightway.com/pages/The-Basics.html)

## <a name="date_and_time"></a> Дата і час

У PHP є клас під назвою `DateTime`, який допомагає вам читати, писати,
порівняння або обчислення з датою та часом. Існує багато
функцій окрім класу `DateTime`, пов’язаних із часом, але це гарний
об'єктно-орієнтований інтерфейс для найбільш поширених застосувань. `DateTime` може обробляти час і
часові зони, але це вже виходить за рамки цього короткого вступу.

Щоб розпочати роботу з DateTime, перетворіть необроблений рядок дати й часу на
об’єкт із фабричним методом `createFromFormat()` або виконайте `new DateTime` для
отримання поточної дати та часу. Використовуйте метод `format()` для перетворення `DateTime`
у рядок для виведення.

```php
<?php
$raw = '22. 11. 1968';
$start = DateTime::createFromFormat('d. m. Y', $raw);

echo 'Start date: ' . $start->format('Y-m-d') . PHP_EOL;

```

Обчислення за допомогою DateTime можливе за допомогою класу `DateInterval`.
`DateTime` має такі методи, як `add()` і `sub()`, які приймають `DateInterval`
як аргумент. Не пишіть код, який очікує однакову кількість
секунд кожного дня. Перехід на літній час та часовий пояси
порушить вашу бізнес логіку. Натомість використовуйте інтервали дат. Щоб розрахувати
різниці дат використовуйте метод `diff()` - час повернеться новим
`DateInterval`, який дуже легко відобразити.

```php
<?php
// створити копію $start і додати один місяць і 6 днів
$end = clone $start;
$end->add(new DateInterval('P1M6D'));

$diff = $end->diff($start);
echo 'Різниця: ' . $diff->format('%m місяць, %d днів (загалом: %a днів)') . PHP_EOL;
// Різниця: 1 місяць, 6 днів (загалом: 37 днів)
```

Ви можете використовувати стандартні порівняння об’єктів DateTime:

```php
<?php
if ($start < $end) {
    echo "Start is before the end!" . PHP_EOL;
}
```

Останній приклад для демонстрації класу `DatePeriod`. Це зазвичай використовують, щоб
повторювати повторювані події. Він може приймати два об’єкти `DateTime`, початок
і кінець, а також інтервал, протягом якого буде повернуто всі події між ними.

```php
<?php
// виводити всі четверги між $start і $end
$periodInterval = DateInterval::createFromDateString('first thursday');
$periodIterator = new DatePeriod($start, $periodInterval, $end, DatePeriod::EXCLUDE_START_DATE);
foreach ($periodIterator as $date) {
    // виведення кожної дати в періоді
    echo $date->format('Y-m-d') . ' ';
}
```

Популярним розширенням PHP API є [Carbon](https://carbon.nesbot.com/). Він
успадковує все в класі DateTime, тому містить мінімальний код, але додаткові функції включають підтримку локалізації
способи додавання, віднімання та форматування об’єкта `DateTime`, а також засоби перевірки вашого коду, імітуючи дату й час за вашим вибором.

- [Читати про DateTime](https://secure.php.net/book.datetime)
- [Прочитайте про форматування дати](https://secure.php.net/function.date) (прийнятні параметри формату дати)

## <a name="design_patterns"></a> Патерни проектування

Коли ви створюєте свою програму, корисно використовувати поширені
шаблони у вашому коді та загальні шаблони для загальної структури
вашого проекту. Використання загальних шаблонів є корисним, оскільки це допомагае
легше керувати своїм кодом і дозволяє іншим розробникам швидко зрозуміти
як все поєднується і працює.

Якщо ви використовуєте фреймворк, то більшість коду вищого рівня та структура проекту
буде базуватися на структурі цьому фреймворку, тому багато рішень вже приймаються за вас.
Але це все ще залежить від вас, щоб вибрати
найкращі шаблони, яким слід слідувати в коді, який ви створюєте поверх фреймворку.
Якщо, з іншого боку, ви не використовуєте фреймворк для створення свого коду,
тоді ви повинні знайти шаблони, які найкраще відповідають типу
й розміру програми, яку ви створюєте.

Ви можете дізнатися більше про шаблони проектування PHP і переглянути робочі приклади на:

- [Refactoring Guru](https://refactoring.guru/)
- [DesignPatternsPHP](https://designpatternsphp.readthedocs.io/)

## <a name="php_and_utf8"></a> Робота з UTF-8

_Цей розділ спочатку був написаний [Alex Cabal](https://alexcabal.com/) у [PHP Best Практики](https://phpbestpractices.org/#utf-8) і використовувався як основа для наших власних порад щодо UTF-8_.

### Однострокового тексту немає. Будьте уважними, детальними та послідовними.

Зараз PHP не підтримує Unicode на низькому рівні. Є способи
переконайтеся, що рядки UTF-8 обробляються нормально, але це нелегко, і це
вимагає вивчення майже всіх рівнів веб-програми, від HTML до
SQL в PHP. Ми прагнемо до короткого практичного підсумку.

### UTF-8 на рівні PHP

Основні операції з рядками, як-от об’єднання двох рядків і
присвоєння рядків змінним не потребує нічого особливого для UTF-8.
Однак більшість рядкових функцій, як-от `strpos()` і `strlen()`, потребують
особливої уваги. Ці функції часто мають відповідні `mb_*`:
наприклад, `mb_strpos()` і `mb_strlen()`. Ці рядки `mb_*` є
доступні для вас через [розширення](https://secure.php.net/book.mbstring), яке
призначено для роботи з рядками Unicode.

Ви повинні використовувати функції `mb_*` щоразу, коли працюєте з Unicode
рядком. Наприклад, якщо ви використовуєте `substr()` у рядку UTF-8, є
велика ймовірність, що результат міститиме деякі спотворені півсимволи.
Правильною функцією для використання буде багатобайтовий аналог,
`mb_substr()`.

Якщо ви про це забудете хоча б раз, ваш рядок Unicode має шанс бути
спотвореним під час подальшої обробки.

Не всі рядкові функції мають відповідний `mb_*`. Якщо його немає
для того, що ви хочете зробити, то вам може не пощастити.

Ви повинні використовувати функцію `mb_internal_encoding()` у верхній частині кожного
скрипта PHP, який ви пишете (або у верхній частині вашого глобального сценарію включення), і
функцію `mb_http_output()` відразу після неї, якщо ваш скрипт виводить у
браузер. Явне визначення кодування вашого
рядка в кожному сценарії позбавлять вас від багатьох головних болів у майбутньому.

Крім того, багато функцій PHP, які працюють із рядками, мають
необов'язковий параметр, що дозволяє вказати кодування символів. Ви
маєте завжди явно вказувати UTF-8, коли надається така опція. Наприклад, для `htmlentities()`
має сенс задати опцію для кодування символів, і
завжди слід вказувати UTF-8, якщо ви маєте справу з такими рядками. Зверніть увагу, що з
PHP 5.4.0, UTF-8 є стандартним кодуванням для `htmlentities()` і
`htmlspecialchars()`.

Нарешті, якщо ви створюєте розподілену програму і не можете переконайтеся,
що розширення `mbstring` буде ввімкнено, тоді використовуйте
[symfony/polyfill-mbstring](https://packagist.org/packages/symfony/polyfill-mbstring).
Цей пакет буде використовувати розширення `mbstring`, якщо воне доступне, і звичайні функції роботи
з строками, якщо ні.

### UTF-8 на рівні бази даних

Якщо ваш скрипт PHP отримує доступ до MySQL, є ймовірність, що ваші рядки зможуть це зробити
зберігатися як рядки не-UTF-8 у базі даних, навіть якщо ви дотримуєтесь усіх
запобіжні заходи вище.

Щоб переконатися, що ваші рядки переходять із PHP на MySQL як UTF-8, переконайтеся, що ваш
у базі даних і таблицях встановлено набір символів `utf8mb4` і
зіставлення, і що ви використовуєте набір символів `utf8mb4` у PDO
рядок підключення. Перегляньте приклад коду нижче. Це _критично
важливо_.

Зауважте, що ви повинні використовувати набір символів `utf8mb4` для повної UTF-8
підтримка, а не набір символів `utf8`! Чому.

### UTF-8 на рівні браузера

Використовуйте функцію `mb_http_output()`, щоб переконатися, що ваш скрипт PHP
виводить рядки UTF-8 у ваш браузер.

Відповідь HTTP має повідомити браузеру, що це
сторінку слід розглядати як UTF-8. Сьогодні прийнято встановлювати
набір символів у заголовку відповіді HTTP таким чином:

```php
<?php
header('Content-Type: text/html; charset=UTF-8')
```

Історичним підходом до цього було включення [charset `<meta>`
тег](http://htmlpurifier.org/docs/enduser-utf8.html) на вашій сторінці
тег <head>.

```php
<?php
// Повідомте PHP, що ми використовуємо рядки UTF-8 до кінця сценарію
mb_internal_encoding('UTF-8');
$utf_set = ini_set('default_charset', 'utf-8');
if (!$utf_set) {
throw new Exception('не вдалося встановити default_charset на utf-8, переконайтеся, що його встановлено у вашій системі!');
}

// Повідомте PHP, що ми будемо виводити UTF-8 у браузер
mb_http_output('UTF-8');

// Наш тестовий рядок UTF-8
$string = 'El síla erin lû e-govaned vîn.';

// Певним чином трансформувати рядок за допомогою багатобайтової функції
// Зверніть увагу, як ми скоротили рядок на символі, відмінному від Ascii, для демонстраційних цілей
$string = mb_substr($string, 0, 15);

// Підключення до бази даних для збереження перетвореного рядка
// Для отримання додаткової інформації дивіться приклад PDO в цьому документі
// Зверніть увагу на `charset=utf8mb4` в назві джерела даних (DSN)
$link = new PDO(
'mysql:host=ваше ім'я хоста;dbname=ваша база даних;charset=utf8mb4',
'Ваше ім'я користувача',
'Ваш пароль',
масив(
PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,
PDO::ATTR_PERSISTENT => false
)
);

// Зберігаємо наш перетворений рядок як UTF-8 у нашій базі даних

$handle = $link->prepare('вставити в ElvishSentences (Id, Body, Priority) значення (за замовчуванням, :body, :priority)');
$handle->bindParam(':body', $string, PDO::PARAM_STR);
$пріоритет = 45;
$handle->bindParam(':priority', $priority, PDO::PARAM_INT); // явно вказуємо pdo очікувати int
$handle->execute();

// Отримати рядок, який ми щойно зберегли, щоб підтвердити, що він був збережений правильно
$handle = $link->prepare('вибрати * з ElvishSentences, де Id = :id');
$id = 7;
$handle->bindParam(':id', $id, PDO::PARAM_INT);
$handle->execute();

// Зберігаємо результат в об’єкт, який ми виведемо пізніше в нашому HTML
// Цей об’єкт не вб’є вашу пам’ять, оскільки він своєчасно отримує дані
$результат = $handle->fetchAll(\PDO::FETCH_OBJ);

// Приклад оболонки, яка дозволяє вам передавати дані в html
функція escape_to_html($dirty){
echo htmlspecialchars($dirty, ENT_QUOTES, 'UTF-8');
}

header('Content-Type: text/html; charset=UTF-8'); // Немає потреби, якщо для вашого default_charset уже встановлено значення utf-8
?><!doctype html>
<html>
<голова>
<meta charset="UTF-8">
<title>Тестова сторінка UTF-8</title>
</head>
<тіло>
<?php
foreach($result as $row){
escape_to_html($row->Body); // Це має правильно вивести наш трансформований рядок UTF-8 у браузер
}
?>
</body>
</html>
```

### Подальше читання

- [Посібник PHP: String
  Операції](https://secure.php.net/language.operators.string)
- [Посібник PHP: функції рядків](https://secure.php.net/ref.strings)
- [`strpos()`](https://secure.php.net/function.strpos)
- [`strlen()`](https://secure.php.net/function.strlen)
- [`substr()`](https://secure.php.net/function.substr)
- [Посібник PHP: багатобайтовий рядок
  Функції](https://secure.php.net/ref.mbstring)
- [`mb_strpos()`](https://secure.php.net/function.mb-strpos)
- [`mb_strlen()`](https://secure.php.net/function.mb-strlen)
- [`mb_substr()`](https://secure.php.net/function.mb-substr)
- [`mb_internal_encoding()`](https://secure.php.net/function.mb-internal-encoding)
- [`mb_http_output()`](https://secure.php.net/function.mb-http-output)
- [`htmlentities()`](https://secure.php.net/function.htmlentities)
- [`htmlspecialchars()`](https://secure.php.net/function.htmlspecialchars)
  - [Переповнення стека: Які фактори роблять PHP
    Unicode-incompatible?](https://stackoverflow.com/questions/571694/what-factors-make-php-unicode-incompatible)
- [Переповнення стека: найкращі практики PHP і MySQL з міжнародними
  рядки](https://stackoverflow.com/questions/140728/best-practices-in-php-and-mysql-with-international-strings)
- [Як підтримувати повний Юнікод у MySQL
  бази даних](https://mathiasbynens.be/notes/mysql-utf8mb4)
- [Перенесення Юнікоду в PHP за допомогою Portable
  UTF-8](https://www.sitepoint.com/bringing-unicode-to-php-with-portable-utf8/)
- [Переповнення стека: DOMDocument loadHTML не кодує UTF-8
  правильно](https://stackoverflow.com/questions/8218230/php-domdocument-loadhtml-not-encoding-utf-8-correctly)

## <a name="i18n_l10n"></a> Інтернаціоналізація (i18n) і локалізація (l10n)

_Застереження для новачків: i18n і l10n є нумеронімами, різновидом
абревіатура, де цифри використовуються для скорочення слів - у нашому випадку,
інтернаціоналізація стає i18n, а локалізація - l10n._

Перш за все, нам потрібно визначити ці два схожі поняття та інші
пов'язані речі:

- **Інтернаціоналізація** - це коли ви організовуєте свій код так, щоб він міг бути
  адаптовано до різних мов або регіонів без рефакторингу. Це
  дія зазвичай виконується один раз - бажано на початку
  або вам, імовірно, знадобляться значні зміни в
  джерело!
- **Локалізація** відбувається, коли ви адаптуєте інтерфейс (переважно) за допомогою
  переклад вмісту на основі попередньої роботи i18n. Це зазвичай
  виконується щоразу, коли нова мова чи регіон потребують підтримки
  оновлюється, коли додаються нові елементи інтерфейсу, як це і потрібно
  доступний усіма підтримуваними мовами.
- **Множина** визначає правила, необхідні між distinct
  мови для взаємодії рядків, що містять числа та лічильники.
  Наприклад, в англійській мові, коли у вас є лише один предмет, це так
  однина, а все, що відрізняється від цього, називається множиною; множина
  у цій мові позначається додаванням S після деяких слів і
  іноді змінює його частини. Іншими мовами, наприклад російською
  або сербська, є дві форми множини, крім однини -
  ви навіть можете знайти мови із загалом чотирма, п’ятьма чи шістьма формами,
  як-от словенська, ірландська чи арабська.

## Загальні способи реалізації

Найпростіший спосіб інтернаціоналізації програмного забезпечення PHP — використання файлів-масивів
і використання цих рядків у шаблонах, наприклад
`<h1><?=$TRANS['title_about_page']?></h1>`. Цей шлях, однак, навряд чи
рекомендовано для серйозних проектів, оскільки це створює деякі проблеми з обслуговуванням
вздовж дороги - деякі можуть з'явитися на самому початку, наприклад
плюралізація. Тому, будь ласка, не пробуйте це, якщо ваш проект міститиме
більше ніж пару сторінок.

Найбільш класичним способом, який часто використовують як еталон для i18n і l10n, є a
[Інструмент Unix під назвою `gettext`](https://en.wikipedia.org/wiki/Gettext). Це
датується 1995 роком і досі є повною реалізацією для
програмне забезпечення для перекладу. Досить легко почати бігти, перебуваючи на місці
спортивні потужні допоміжні інструменти. Йтиметься про Gettext
говорити тут. Крім того, щоб допомогти вам не плутатися з командним рядком, ми
представить чудову програму з графічним інтерфейсом користувача, яку можна легко використовувати
оновіть джерело l10n

### Інші інструменти

Використовуються загальні бібліотеки, які підтримують Gettext та інші
реалізації i18n. Деякі з них можуть здатися простішими в установці або
спортивні додаткові функції або формати файлів i18n. У цьому документі ми
зосередьтеся на інструментах, що надаються з ядром PHP, але тут ми перерахуємо інші
для завершення:

- [aura/intl](https://github.com/auraphp/Aura.Intl): забезпечує
  інструменти інтернаціоналізації (I18N), зокрема пакетно-орієнтовані
  переклад повідомлень для кожної мови. Він використовує формати масивів для повідомлень.
  Не надає екстрактора повідомлень, але надає розширені можливості
  форматування повідомлення за допомогою розширення `intl` (включаючи множину
  повідомлення).
- [oscarotero/Gettext](https://github.com/oscarotero/Gettext): Gettext
  підтримка OO інтерфейсу; містить покращені допоміжні функції,
  потужні екстрактори для кількох форматів файлів (деякі з них ні
  підтримується командою `gettext`), а також може експортуватися в
  інші формати, крім файлів `.mo/.po`. Може бути корисним, якщо вам потрібно
  інтегрувати ваші файли перекладу в інші частини системи,
  як інтерфейс JavaScript.
- [symfony/переклад](https://symfony.com/doc/current/components/translation.html):
  підтримує багато різних форматів, але рекомендує використовувати verbose
  XLIFF. Не містить допоміжних функцій і вбудованого екстрактора,
  але підтримує заповнювачі за допомогою внутрішнього `strtr()`.
- [laminas/laminas-i18n](https://docs.laminas.dev/laminas-i18n/):
  підтримує файли масивів і INI, або формати Gettext. Реалізує a
  рівень кешування, щоб позбавити вас від кожного разу читати файлову систему. Це
  також містить помічники перегляду та фільтри введення з урахуванням локалі
  валідатори. Однак він не має екстрактора повідомлень.

Інші фреймворки також включають модулі i18n, але вони недоступні
за межами їхніх кодових баз:

- [Laravel](https://laravel.com/docs/master/localization) підтримує
  файли основного масиву, не має автоматичного екстрактора, але містить `@lang`
  помічник для файлів шаблонів.
- [Yii](https://www.yiiframework.com/doc/guide/2.0/en/tutorial-i18n)
  підтримує масив, Gettext і переклад на базі даних, а також
  містить екстрактор повідомлень. Це підтримується
  Розширення [`Intl`](https://secure.php.net/manual/intro.intl.php),
  доступний з PHP 5.3 і базується на [ICU
  проект](http://www.icu-project.org); це дозволяє запускати Yii
  потужні заміни, як-от написання чисел, форматування дат,
  час, інтервали, валюта та порядкові номери.

Якщо ви вирішите вибрати одну з бібліотек, які не пропонують екстрактори,
ви можете використовувати формати gettext, щоб ви могли використовувати оригінал
інструментарій gettext (включаючи Poedit), як описано в решті
розділ.

## Gettext

### Установка

Можливо, вам знадобиться інсталювати Gettext і відповідну бібліотеку PHP за допомогою
ваш менеджер пакетів, наприклад `apt-get` або `yum`. Після встановлення увімкніть
додавши `extension=gettext.so` (Linux/Unix) або
`extension=php_gettext.dll` (Windows) до вашого `php.ini`.

Тут ми також будемо використовувати [Poedit](https://poedit.net) для створення
файли перекладу. Ймовірно, ви знайдете його в пакеті вашої системи
менеджер; він доступний для Unix, Mac і Windows і може бути
[завантажено безкоштовно на їх веб-сайті](https://poedit.net/download) як
Ну.

### Структура

#### Типи файлів

Під час роботи з gettext ви зазвичай маєте справу з трьома файлами.
Основними з них є файли PO (Portable Object) і MO (Machine Object),
перший - це список доступних для читання «перекладених об’єктів», а другий,
відповідний двійковий файл, який буде інтерпретовано gettext під час виконання
локалізація. Існує також файл POT (шаблон), який просто містить
усі існуючі ключі з ваших вихідних файлів, і їх можна використовувати як посібник
створювати та оновлювати всі PO-файли. Ці файли шаблонів - ні
обов’язково: залежно від інструменту, який ви використовуєте для виконання l10n, ви можете йти
чудово лише з файлами PO/MO. У вас завжди буде одна пара PO/MO
файлів на мову та регіон, але лише один POT на домен.

### Домени

Бувають випадки у великих проектах, коли вам може знадобитися розлучитися
переклади, коли ті самі слова передають різне значення, задане a
контекст. У таких випадках ви розділяєте їх на різні _домени_. Вони
це, в основному, іменовані групи файлів POT/PO/MO, де міститься назва файлу
згаданий _домен перекладу_. Малі та середні проекти, як правило,
для спрощення використовуйте лише один домен; його назва довільна, але ми будемо
використовувати «main» для наших зразків коду. в
[Symfony](https://symfony.com/doc/current/components/translation.html)
проекти, наприклад, домени використовуються для розділення перекладу для
повідомлення перевірки.

#### Код мови

Локаль — це просто код, який ідентифікує одну версію мови. Це
визначається відповідно до [ISO
639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) і [ISO
3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) характеристики:
дві малі літери для мови, необов’язково після них
підкреслення та дві великі літери, що ідентифікують країну або регіон
код. Для [рідкісних
мови](https://www.gnu.org/software/gettext/manual/gettext.html#Rare-Language-Codes),
використовуються три букви.

Деяким мовцям частина країни може здатися зайвою. Насправді деякі
мови мають діалекти в різних країнах, наприклад, австрійська німецька
(`de_AT`) або бразильською португальською (`pt_BR`). Друга частина звикла
розрізняти ті діалекти - коли його немає, його беруть
як «загальну» або «гібридну» версію мови.

### Структура каталогу

Щоб використовувати Gettext, нам потрібно буде дотримуватися певної структури
папки. Спочатку вам потрібно буде вибрати довільний корінь для вашого l10n
файлів у вашому вихідному сховищі. У ньому буде папка для
кожну необхідну мову та фіксовану папку `LC_MESSAGES`, яка міститиме
усі ваші пари PO/MO. приклад:

```sh
<корінь проекту>
├─ src/
├─ шаблони/
└─ локалі/
├─ форум.пот
├─ site.pot
├─ de/
│ └─ LC_MESSAGES/
│ ├─ forum.mo
│ ├─ forum.po
│ ├─ site.mo
│ └─ site.po
├─ es_ES/
│ └─ LC_MESSAGES/
│ └─ ...
├─ пт/
│ └─ ...
├─ pt_BR/
│ └─ ...
└─ pt_PT/
└─ ...
```

### Форми множини

Як ми сказали у вступі, різні мови можуть грати
різні правила множини. Однак gettext рятує нас від цієї неприємності один раз
знову. Під час створення нового файлу `.po` вам доведеться оголосити
[множина
правила](http://docs.translatehouse.org/projects/localization-guide/en/latest/l10n/pluralforms.html)
для цієї мови, і перекладені твори, які чутливі до множини, будуть
мати різну форму для кожного з цих правил. Під час виклику Gettext в
код, вам доведеться вказати номер, пов'язаний з реченням, і
він розробить правильну форму для використання - навіть з використанням рядка
заміна при необхідності.

Правила множини включають кількість доступних множин і логічний тест
з `n`, що визначило б, до якого правила потрапляє задане число
(початок рахунку з 0). Наприклад:

- Англійська: `nplurals=2; plural=(n != 1);` - два правила, перше, якщо N є
  одне, друге правило інакше
- бразильська португальська: `nplurals=2; plural=(n > 1);` - два правила,
  по-друге, якщо N більше за одиницю, по-перше, інакше

Тепер, коли ви зрозуміли, як працюють правила множини - і якщо ви
не зробив, подивіться докладніше пояснення на [LingoHub
підручник](https://lingohub.com/blog/2013/07/php-internationalization-with-gettext-tutorial/#Plurals)
-, ви можете скопіювати потрібні з a
[список](http://docs.translatehouse.org/projects/localization-guide/en/latest/l10n/pluralforms.html)
замість того, щоб писати їх від руки.

Під час виклику Gettext для локалізації речень із лічильниками,
вам також доведеться надати відповідний номер. Gettext буде
визначте, яке правило має діяти, і використовуйте правильну локалізацію
версія. Вам потрібно буде додати до файлу `.po` інше речення
для кожного визначеного правила множини.

### Приклад реалізації

Після всієї цієї теорії давайте трохи практики. Ось уривок
файлу `.po` - не заперечуйте щодо його формату, а загалом
вміст замість цього; пізніше ви дізнаєтеся, як це легко редагувати:

msgstr ""
msgstr ""
"Мова: pt_BR
"
"Тип вмісту: text/plain; charset=UTF-8
"
"Форми множини: nмножини=2; множина=(n > 1);
"

msgstr "Зараз ми перекладаємо деякі рядки"
msgstr "Наш переклад агори рядків"

msgstr "Вітаємо, %1$s! Ваш останній візит був %2$s"
msgstr "Ой, %1$s! Останнє відвідування для %2$s"

msgstr "Лише одне непрочитане повідомлення"
msgid_plural "%d непрочитаних повідомлень"
msgstr[0] "Немає повідомлення"
msgstr[1] "%d повідомлень немає"

````

Перший розділ працює як заголовок, маючи `msgid` і `msgstr`
особливо порожній. Описує кодування файлів, форми множини та інше
речі, які менш актуальні. Другий розділ перекладається просто
рядок з англійської на бразильську португальську, а третій виконує
те саме, але з використанням заміни рядка з

переклад може містити ім'я користувача та дату відвідування. Останній розділ
є зразком форм множини, що відображає однину та множину
версія як `msgid` англійською мовою та їх відповідні переклади як
`msgstr` 0 і 1 (за числом, заданим правилом множини). там,
також використовується заміна рядка, тому число можна побачити безпосередньо в
речення, використовуючи `%d`. Форми множини завжди мають два `msgid`
(однина та множина), тому радимо не використовувати складну мову як
джерело перекладу.

### Обговорення ключів l10n

Як ви могли помітити, ми використовуємо як ідентифікатор джерела фактичне речення
англійською. Цей `msgid` використовується в усіх ваших `.po`
файли, тобто інші мови матимуть той самий формат і однакові
поля `msgid`, але перекладені рядки `msgstr`.

Якщо говорити про ключі перекладу, то тут є дві основні «школи»:

1. *`msgid` як реальне речення*. Основні переваги:
- якщо є частини програмного забезпечення, неперекладені в жодному з них

Приклад: якщо ви перекладаєте напам'ять з англійської на
Іспанська, але потрібна допомога з перекладом на французьку, ви можете опублікувати
нова сторінка з відсутніми французькими реченнями та частинами
натомість веб-сайт відображатиметься англійською мовою;
- перекладачу набагато легше зрозуміти, про що йде мова
і виконайте правильний переклад на основі `msgid`;
- це дає вам «безкоштовний» l10n для однієї мови - початкової;
- Єдиний недолік: якщо вам потрібно змінити фактичний текст,
вам потрібно буде замінити той самий `msgid` на кількох
мовні файли.
2. *`msgid` як унікальний, структурований ключ*. Це описало б
речення роль у додатку в структурованому вигляді, в т.ч
шаблон або частина, де розміщено рядок замість його вмісту.
- це чудовий спосіб упорядкувати код, розділивши
текстовий вміст із логіки шаблону.
- однак це може створити проблеми для перекладача
пропустити контекст. Файл вихідної мови потрібен як a
основа для інших перекладів. Приклад: розробник би
в ідеалі мати файл `en.po`, який би читали перекладачі
зрозуміти, що писати у `fr.po`, наприклад.
- відсутні переклади відображатимуть на екрані безглузді клавіші
(`top_menu.welcome` замість `Привіт, користуваче!` у згаданому
неперекладена французька сторінка). То добре це як би сила
переклад повинен бути завершений перед публікацією - однак, погано, як
проблеми з перекладом були б надзвичайно жахливими в інтерфейсі.
Деякі бібліотеки, однак, включають опцію вказати заданий
мова як «запасний варіант», маючи подібну поведінку, як і інші
підхід.

[Gettext
посібник](https://www.gnu.org/software/gettext/manual/gettext.html) переваги
перший підхід, оскільки він, загалом, легший для перекладачів і
користувачів у разі виникнення проблем. Так ми будемо працювати і тут.
Однак [Symfony
документація](https://symfony.com/doc/current/components/translation/usage.html#creating-translations)
віддає перевагу перекладу на основі ключових слів, щоб дозволити незалежні зміни
усі переклади без впливу на шаблони.

### Щоденне використання

У типовій програмі ви використовуєте деякі функції Gettext під час
написання статичного тексту на ваших сторінках. Потім ці речення з’являться в
файли `.po`, перекладаються, компілюються у файли `.mo`, а потім використовуються
Gettext під час відтворення фактичного інтерфейсу. Враховуючи це, давайте зав’яжемо
разом те, що ми обговорювали досі в покроковому прикладі:

#### 1. Зразок файлу шаблону, включаючи кілька різних викликів gettext

``` php
<?php include 'i18n_setup.php' ?>

<h1><?=sprintf(gettext('Ласкаво просимо, %s!'), $name)?></h1>
<!-- код із таким відступом лише для розбірливості -->
<?php if ($unread): ?>
<h2><?=sprintf(
ngettext('Лише одне непрочитане повідомлення',
'%d непрочитаних повідомлень',
$непрочитане),
$непрочитане)?>
</h2>
<?php endif ?>
</div>

<h1><?=gettext('Introduction')?></h1>
<p><?=gettext('Ми зараз перекладаємо деякі рядки')?></p>
````

- [`gettext()`](https://secure.php.net/manual/function.gettext.php)
  просто перетворює `msgid` у відповідний `msgstr` для a
  задана мова. Існує також скорочена функція `_()`, яка працює
  так само;
- [`ngettext()`](https://secure.php.net/manual/function.ngettext.php)
  робить те саме, але з правилами множини;
- також є
  [`dgettext()`](https://secure.php.net/manual/function.dgettext.php)
  і
  [`dngettext()`](https://secure.php.net/manual/function.dngettext.php),
  що дозволяє замінити домен для одного виклику. Детальніше
  конфігурацію домену в наступному прикладі.

#### 2. Зразок файлу налаштування (`i18n_setup.php`, як використано вище), вибір правильної мови та налаштування Gettext

```php
<?php
/**
* Перевіряє, чи даний $locale підтримується проектом
* @param рядок $locale
* @return bool
*/
функція valid($locale) {

}

//встановлення вихідної/замовчованої мови для інформаційних цілей
$lang = 'en_US';

if (isset($_GET['lang']) && valid($_GET['lang'])) {
// локаль можна змінити за допомогою рядка запиту
$lang = $_GET['lang']; //ви повинні продезінфікувати це!
setcookie('lang', $lang); //зберігається в файлі cookie, тому його можна використовувати повторно
} elseif (isset($_COOKIE['lang']) && valid($_COOKIE['lang'])) {
// якщо натомість присутній файл cookie, давайте просто збережемо його
$lang = $_COOKIE['lang']; //ви повинні продезінфікувати це!
} elseif (isset($_SERVER['HTTP_ACCEPT_LANGUAGE'])) {
// за замовчуванням: пошук мов, які, за словами браузера, приймає користувач
$langs = explode(',', $_SERVER['HTTP_ACCEPT_LANGUAGE']);
array_walk($langs, функція (&$lang) { $lang = strtr(strtok($lang, ';'), ['-' => '_']); });
foreach ($langs як $browser_lang) {
if (valid($browser_lang)) {
$lang = $browser_lang;
перерву;
}
}
}

// тут ми визначаємо глобальну системну локаль з урахуванням знайденої мови
putenv("LANG=$lang");

// це може бути корисним для функцій дати (LC_TIME) або форматування грошей (LC_MONETARY), наприклад
setlocale(LC_ALL, $lang);

// це змусить Gettext шукати ../locales/<lang>/LC_MESSAGES/main.mo
bindtextdomain('main', '../locales');

// вказує, у якому кодуванні має бути прочитаний файл
bind_textdomain_codeset('main', 'UTF-8');

// якщо ваша програма має додаткові домени, як уже згадувалося раніше, вам також слід прив’язати їх тут
bindtextdomain('форум', '../локалі');
bind_textdomain_codeset('форум', 'UTF-8');

// тут ми вказуємо домен за замовчуванням, на який відповідатимуть виклики gettext().
textdomain('main');

// це буде шукати рядок у forum.mo замість main.mo
// echo dgettext('forum', 'Ласкаво просимо назад!');
?>
```

#### 3. Підготовка перекладу до першого запуску

Одна з великих переваг Gettext над власною структурою i18n
packages — це великий і потужний формат файлів. «О, чувак, це так
досить важко зрозуміти та редагувати вручну, простий масив буде
легше!» Не помиляйтеся, такі програми, як [Poedit](https://poedit.net)
готові допомогти - _багато_. Ви можете отримати програму від [їх
веб-сайт](https://poedit.net/download), він безкоштовний і доступний для всіх
платформи. Це досить простий інструмент, до якого можна звикнути, і він дуже потужний
один одночасно - використовуючи всі доступні функції Gettext. Це
посібник базується на PoEdit 1.8.

Під час першого запуску вам слід вибрати в меню «Файл \> Створити…». Ви будете
відразу буде запропоновано вибрати мову: тут ви можете вибрати/відфільтрувати
мовою, на яку ви бажаєте перекладати, або скористайтеся згаданим нами форматом
перед, наприклад `en_US` або `pt_BR`.

Тепер збережіть файл, використовуючи ту структуру каталогів, яку ми згадували
Ну. Потім вам слід натиснути «Витягти з джерел», і ось ви
налаштувати різні параметри для завдань видобування та перекладу.
Пізніше ви зможете знайти їх у «Каталог \> Властивості»:

- Вихідні шляхи: тут ви повинні включити всі папки з проекту
  де викликається `gettext()` (і братів і сестер) - це зазвичай ваш
  папки шаблонів/переглядів. Це єдине обов'язкове налаштування;
- Властивості перекладу:
- Назва та версія проекту, команда та адреса електронної пошти команди: корисно
  інформація, яка міститься в заголовку файлу .po;
- Форми множини: ось ці правила, про які ми згадували раніше - є
  посилання там також із зразками. Ви можете залишити його з
  типовий параметр у більшості випадків, оскільки PoEdit уже містить a
  зручна база даних правил множини для багатьох мов.
- Кодування: UTF-8, бажано;
- Набір кодів вихідного коду: встановіть тут набір символів, який використовується вашим
  кодова база - можливо, також UTF-8, правда?
- Ключові слова джерела: базове програмне забезпечення знає, як `gettext()` і
  подібні виклики функцій виглядають у кількох мовах програмування,
  але ви також можете створити власні функції перекладу. Це буде
  тут ви додасте ці інші методи. Про це йтиметься пізніше
  у розділі «Поради».

Після встановлення цих точок він запустить сканування ваших вихідних файлів
щоб знайти всі виклики локалізації. Після кожного сканування відображатиметься PoEdit
короткий виклад того, що було знайдено та що було видалено з вихідних файлів.
Нові записи будуть подані порожніми в таблицю перекладу, і ви почнете
вводячи локалізовані версії цих рядків. Збережіть його та .mo
файл буде (повторно) скомпільовано в ту саму папку, і ta-dah: ваш проект
є інтернаціоналізованим.

#### 4. Переклад рядків

Як ви могли помітити раніше, існує два основних типи локалізації
рядки: прості та з формами множини. Перші мають
просто два поля: джерело та локалізований рядок. Вихідний рядок не може
бути зміненими, оскільки Gettext/Poedit не містять повноважень змінювати ваші
вихідні файли - вам слід змінити саме джерело та повторно сканувати файли.
Порада: ви можете клацнути правою кнопкою миші рядок перекладу, і він підкаже вам
вихідні файли та рядки, де цей рядок використовується. З іншого
рука, рядки форми множини включають два поля, щоб показати два джерела
рядки та вкладки, щоб ви могли налаштувати різні кінцеві форми.

Щоразу, коли ви змінюєте свої джерела та потребуєте оновлення перекладів,
просто натисніть «Оновити», і Poedit повторно відсканує код, видаливши неіснуючий
записи, об’єднуючи ті, що змінилися, і додаючи нові. Це також може
спробуйте вгадати деякі переклади на основі інших, які ви зробили. Ті
відгадки та змінені записи отримають маркер «Нечіткі»,
вказуючи, що його потрібно перевірити, у списку з’являється золотий колір. Це також
корисно, якщо у вас є команда перекладачів і хтось намагається писати
щось, у чому вони не впевнені: просто позначте Fuzzy та ще когось
перегляну пізніше.

Нарешті, радимо залишити «Переглянути \> Неперекладені записи спочатку»
позначені, оскільки це _дуже_ допоможе вам не забути жодного запису. З того
меню, ви також можете відкрити частини інтерфейсу користувача, які дозволяють вийти
контекстна інформація для перекладачів, якщо це необхідно.

### Поради та підказки

#### Можливі проблеми з кешуванням

Якщо ви використовуєте PHP як модуль на Apache (`mod_php`), ви можете зіткнутися
проблеми з файлом `.mo`, який кешується. Це буває вперше
прочитати, а потім, щоб оновити його, вам може знадобитися перезапустити сервер. Увімкнено
Для Nginx і PHP5 зазвичай потрібно лише кілька оновлень сторінки
оновити кеш перекладу, а на PHP7 це рідко потрібно.

#### Додаткові допоміжні функції

Як вважають за краще багато людей, замість нього простіше використовувати `_()`
`gettext()`. Багато спеціальних бібліотек i18n із фреймворків щось використовують
також подібно до `t()`, щоб зробити перекладений код коротшим. Однак це
це єдина функція, яка має ярлик. Можливо, ви захочете додати
ваш проект деякі інші, такі як `__()` або `_n()` для `ngettext()`, або
можливо, дивовижний `_r()`, який об’єднав би виклики `gettext()` і `sprintf()`.
Інші бібліотеки, такі як [oscarotero’s
Gettext](https://github.com/oscarotero/Gettext) також надає помічник
подібні функції.

У таких випадках вам потрібно буде вказати утиліті Gettext, як це зробити
видобути рядки з цих нових функцій. Не бійся; Це є
дуже легко. Це лише поле у файлі `.po` або екран налаштувань
Поредіть. У редакторі цей параметр знаходиться всередині «Каталог \> Властивості \>
Вихідні ключові слова». Пам’ятайте: Gettext уже знає стандартні функції
для багатьох мов, тому не бійтеся, якщо цей список здасться порожнім. ти
необхідно включити туди специфікації цих нових функцій,
наступний [конкретний
формат](https://www.gnu.org/software/gettext/manual/gettext.html#Language-specific-options):

- якщо ви створюєте щось на зразок `t()`, яке просто повертає
  переклад для рядка, ви можете вказати його як `t`. Gettext буде
  знати, що єдиним аргументом функції є рядок, який потрібно перекласти;
- якщо функція має більше одного аргументу, ви можете вказати, в якому
  один перший рядок - і, якщо потрібно, також форма множини.
  Наприклад, якщо ми викличемо нашу функцію так:
  `__('one user', '%d users', $number)', специфікація буде `**:1,2`, що означає, що перша форма є першим аргументом, а друга форма - це другий аргумент. Якщо ваш номер приходить як замість першого аргументу специфікацією буде `**:2,3`, що вказує на
  перша форма є другим аргументом і так далі.

Після включення цих нових правил у файл `.po` буде виконано нове сканування
у ваших нових рядках так само легко, як і раніше.

### Посилання

- [Вікіпедія: і18н і
  l10n](https://en.wikipedia.org/wiki/Internationalization_and_localization)

- [Вікіпедія: Gettext](https://en.wikipedia.org/wiki/Gettext)
- [LingoHub: інтернаціоналізація PHP за допомогою gettext
  підручник](https://lingohub.com/blog/2013/07/php-internationalization-with-gettext-tutorial/)
- [Посібник PHP:
  Gettext](https://secure.php.net/manual/book.gettext.php)
- [Gettext
  Посібник](https://www.gnu.org/software/gettext/manual/gettext.html)

[На початок](#top)

# <a name="dependency_injection"></a> Ін'єкція залежності

З [Вікіпедії](https://wikipedia.org/wiki/Dependency_injection):

Ін’єкція залежностей — це шаблон розробки програмного забезпечення, який дозволяє
видалення жорстко закодованих залежностей і дає можливість змінювати
їх, чи то під час виконання, чи під час компіляції.

Ця цитата робить концепцію набагато складнішою, ніж вона
насправді є. Dependency Injection надає компонент із його
залежностей через впровадження конструктора, виклики методів або
налаштування властивостей. Це так просто.

## <a name="basic_concept"></a> Основна концепція

Ми можемо продемонструвати концепцію простим, але наївним прикладом.

Тут ми маємо клас `Database`, якому потрібен адаптер для спілкування з
бази даних. Ми створюємо екземпляр адаптера в конструкторі та створюємо
важка залежність. Це ускладнює тестування та означає «базу даних».
клас дуже тісно пов'язаний з адаптером.

```php
<?php
namespace Database;

class Database
{
protected $adapter;

public function __construct()
{
$this->adapter = new MySqlAdapter;
}
}

class MysqlAdapter {}
```

Цей код можна переробити для використання ін’єкції залежностей, а отже
послабити залежність.

```php
<?php
namespace Database;

class Database
{
    protected $adapter;

    public function __construct(MySqlAdapter $adapter)
    {
        $this->adapter = $adapter;
    }
}

class MysqlAdapter {}
```

Тепер ми надаємо класу `Database` його залежність, а не
створюючи його сам. Ми навіть могли б створити метод, який би приймав
аргумент залежності та встановіть його таким чином, або якщо `$adapter`
властивість була `публічною`, ми могли встановити її безпосередньо.

## <a name="complex_problem"></a> Складність проблеми

Якщо ви коли-небудь читали про ін’єкцію залежностей, напевно
можна побачити терміни _«Інверсія контролю»_ або _«Інверсія залежності».
Принцип»_. Це тип проблеми, які Dependency Injection вирішує.

### Інверсія керування

Інверсія контролю - це, як сказано, «інвертування контролю» системи
зберігаючи організаційний контроль повністю відокремленим від наших об’єктів. в
з точки зору впровадження залежностей, це означає послаблення наших залежностей шляхом
контролюючи та створюючи їх в іншому місці системи.

Роками фреймворки PHP досягали інверсії керування,
однак постало питання, яку частину контролю ми інвертуємо,
і куди? Наприклад, фреймворки MVC зазвичай надають a
супероб'єкт або базовий контролер, на який повинні поширюватися інші контролери
отримати доступ до своїх залежностей. Це **є** інверсія контролю,
однак замість того, щоб послабити залежності, цей метод просто переїхав
їх.

Впровадження залежностей дозволяє нам більш елегантно вирішити цю проблему за допомогою
лише впроваджуючи потрібні нам залежності, коли вони нам потрібні, без
необхідність будь-яких жорстко закодованих залежностей взагалі.

### S.O.L.I.D.

#### Принцип єдиної відповідальності

Принцип єдиної відповідальності стосується акторів і високого рівня
архітектура. У ньому сказано, що «клас повинен мати лише одну причину
змінити». Це означає, що кожен клас повинен нести _лише_ відповідальність
над окремою частиною функціональних можливостей програмного забезпечення. The
Найбільша перевага цього підходу полягає в тому, що він дозволяє покращити код
_повторне використання_. Розробляючи наш клас для виконання лише однієї речі, ми можемо використовувати
(або повторно використовувати) його в будь-якій іншій програмі, не змінюючи його.

#### Принцип відкритості/закритості

Принцип відкритості/закритості стосується дизайну класу та розширення функцій.
У ньому зазначено, що «сутності програмного забезпечення (класи, модулі, функції тощо)
має бути відкритим для розширення, але закритим для модифікації». Це означає
що ми повинні проектувати наші модулі, класи та функції таким чином, щоб
коли потрібна нова функція, ми не повинні змінювати існуючу
коду, а замість того, щоб написати новий код, який використовуватиметься існуючим кодом.

реалізуйте та дотримуйтеся _інтерфейсів_, а потім введіть підказку проти них
інтерфейси замість конкретних класів.

Найбільша перевага цього підходу полягає в тому, що ми можемо дуже легко розширити
наш код із підтримкою чогось нового без необхідності змін
наявного коду, що означає, що ми можемо скоротити час перевірки якості та ризик для
істотно зменшується негативний вплив на додаток. Ми можемо
розгортайте новий код швидше та з більшою впевненістю.

#### Принцип підстановки Ліскова

Принцип заміни Ліскова стосується підтипу та успадкування. Це
стверджує, що «дочірні класи ніколи не повинні порушувати тип батьківського класу
визначення». Або, словами Роберта С. Мартіна, «Підтипи повинні бути
замінні для своїх базових типів».

Наприклад, якщо у нас є інтерфейс FileInterface, який визначає
`embed()`, і ми маємо класи `Audio` і `Video`, які обидва
реалізувати інтерфейс `FileInterface`, то ми можемо очікувати, що
використання методу `embed()` завжди виконуватиме те, що ми маємо намір.
Якщо пізніше ми створимо клас `PDF` або клас `Gist`, які реалізують
Інтерфейс `FileInterface`, ми вже знаємо та розуміємо, що таке
підійде метод `embed()`. Найбільша перевага цього підходу полягає в тому, що
у нас є можливість створювати гнучкі та легко настроювані програми,
оскільки коли ми змінюємо один об’єкт типу (наприклад, `FileInterface`) на
нам не потрібно нічого змінювати в нашій програмі.

#### Принцип поділу інтерфейсу

Принцип сегрегації інтерфейсу (ISP) про це
комунікація _бізнес-логіка-клієнт_. Там зазначено, що «Немає клієнта
має бути змушений залежати від методів, які він не використовує». Це означає що
замість єдиного монолітного інтерфейсу, який узгоджується
класи, які потрібно реалізувати, замість цього ми повинні надати набір менших,
специфічні для концепції інтерфейси, які відповідний клас реалізує один або
більше.

Наприклад, клас "Автомобіль" або "Автобус" буде цікавий a
метод `steeringWheel()`, але клас `Motorcycle` або `Tricycle`
ні. І навпаки, цікавим буде клас "Мотоцикл" або "Трицикл".
у методі `handlebars()`, але клас `Car` або `Bus` не буде. там
немає необхідності підтримувати всі ці типи транспортних засобів
як `steeringWheel()`, так і `handlebars()`, тому ми повинні
розбити вихідний інтерфейс.

#### Принцип інверсії залежностей

Принцип інверсії залежностей стосується усунення жорстких зв’язків між
дискретні класи, щоб можна було використовувати нову функціональність, передаючи a
різний клас. У ньому зазначено, що слід _«Залежити від абстракцій. робити
не залежить від конкрементів»._. Простіше кажучи, це означає нашу залежність
повинні бути інтерфейсами/контрактами або абстрактними класами, а не конкретними
реалізації. Ми можемо легко змінити наведений вище приклад, щоб слідувати цьому
принцип.

```php
<?php
namespace Database;

class Database
{
protected $adapter;

public function __construct(AdapterInterface $adapter)
{
$this->adapter = $adapter;
}
}

інтерфейс AdapterInterface {}

клас MysqlAdapter реалізує AdapterInterface {}
```

Зараз клас `Database` має кілька переваг залежно від
інтерфейс, а не конкреція.

Вважайте, що ми працюємо в команді і адаптер працює
на колега. У нашому першому прикладі нам довелося б дочекатися сказаного
колега завершити адаптер, перш ніж ми зможемо належним чином познущатися над ним для наших
модульні тести. Тепер, коли залежність є інтерфейсом/контрактом, ми можемо
радісно висміювати цей інтерфейс, знаючи, що наш колега створить його
адаптер на основі цього контракту.

Ще більшою перевагою цього методу є те, що наш код тепер набагато більше
масштабований. Якщо через рік ми вирішимо, що хочемо перейти на a
іншого типу бази даних, ми можемо написати адаптер, який реалізує
оригінальний інтерфейс і вводить його замість цього, більше не потрібно було б рефакторингу
необхідні, оскільки ми можемо гарантувати, що адаптер відповідає набору контракту
через інтерфейс.

## <a name="containers"></a> Контейнери

Перше, що вам слід зрозуміти про впровадження залежностей
Контейнери — це не те саме, що впровадження залежностей.
Контейнер — це зручна утиліта, яка допомагає нам реалізувати залежність
Ін'єкції, однак, вони можуть бути і часто використовуються неправильно для реалізації
анти-шаблон, розташування служби. Впровадження контейнера DI як служби
Можливо, локатор у ваших класах створює більш жорстку залежність від
контейнер, ніж залежність, яку ви замінюєте. Це також створює ваш код
набагато менш прозорий і, зрештою, важче перевірити.

Більшість сучасних фреймворків мають власний контейнер ін’єкції залежностей
що дозволяє об’єднати ваші залежності
конфігурація. На практиці це означає, що ви можете писати
код програми, який є таким же чистим і відокремленим, як і структура
побудований на.

## <a name="dependency_injection_more"></a> Подальше читання

- [Що таке залежність Ін’єкція?](http://fabien.potencier.org/article/11/what-is-dependency-injection)
- [Ін’єкція залежності: Ананалогія](https://mwop.net/blog/260-Dependency-Injection-An-analogy.html)
- [Ін'єкція залежності: Га?](https://code.tutsplus.com/tutorials/dependency-injection-huh--net-26903)
- [Введення залежностей як інструмент для тестування](https://medium.com/philipobenito/dependency-injection-as-a-tool-for-testing-902c21c147f1)

[На початок](#top)

# <a name="databases"></a> Бази даних

Багато разів ваш код PHP використовуватиме базу даних для збереження інформації. ти
мати кілька варіантів підключення та взаємодії з вашою базою даних. The
рекомендованим варіантом **до PHP 5.1.0** було використання власних драйверів, таких як
[mysqli](https://secure.php.net/mysqli),
[pgsql](https://secure.php.net/pgsql),
[mssql](https://secure.php.net/mssql) тощо.

Рідні драйвери чудові, якщо ви використовуєте лише _одну_ базу даних у своїй
але якщо, наприклад, ви використовуєте MySQL і трохи
MSSQL, або вам потрібно підключитися до бази даних Oracle, тоді ви це зробите
не можна використовувати ті самі драйвери. Вам потрібно буде вивчити абсолютно нове
API для кожної бази даних — і це може стати безглуздим.

## <a name="mysql_extension"></a> Розширення MySQL

Розширення [mysql](https://secure.php.net/mysqli) для PHP є
неймовірно старий і був замінений двома іншими розширеннями:

- [mysqli](https://secure.php.net/mysqli)
- [pdo](https://secure.php.net/pdo)

Мало того, що розвиток давно зупинився на
[mysql](https://secure.php.net/mysqli), але він був [застарілим у PHP
5.5.0](https://secure.php.net/migration55.deprecated), і **було
[офіційно видалено в PHP
7.0](https://secure.php.net/manual/migration70.removed-exts-sapis.php)**.

Щоб не копатися в налаштуваннях `php.ini`, щоб побачити, яким модулем ви є
одним із варіантів є пошук `mysql_*` у обраному редакторі.
Якщо з’являються такі функції, як `mysql_connect()` і `mysql_query()`,
тоді `mysql` використовується.

якомога швидше призведе до більших труднощів, коли PHP 7.x
оновлення відбувається. Найкращий варіант - замінити використання mysql на
[mysqli](https://secure.php.net/mysqli) або
[PDO](https://secure.php.net/pdo) у ваших програмах у ваших власних
розклади розробки, щоб потім вас не поспішали.

**Якщо ви оновлюєте [mysql](https://secure.php.net/mysqli) до
[mysqli](https://secure.php.net/mysqli), остерігайтеся ледачих посібників з оновлення, які
пропонуємо вам просто знайти та замінити `mysql_*` на `mysqli_*`. ні
лише те, що це надмірне спрощення, воно втрачає переваги
які надає mysqli, наприклад зв’язування параметрів, яке також пропонується
в [PDO](https://secure.php.net/pdo).**

- [Підготовлено MySQLi
  Заяви](https://websitebeaver.com/prepared-statements-in-php-mysqli-to-prevent-sql-injection)
- [PHP: Вибір API для
  MySQL](https://secure.php.net/mysqlinfo.api.choosing)

## <a name="pdo_extension"></a> Розширення PDO

[PDO](https://secure.php.net/pdo) — це абстракція підключення до бази даних
бібліотека — вбудована в PHP, починаючи з версії 5.1.0 — яка забезпечує загальний інтерфейс
спілкуватися з багатьма різними базами даних. Наприклад, можна використовувати
в основному ідентичний код для взаємодії з MySQL або SQLite:

```php
<?php
// PDO + MySQL
$pdo = new PDO('mysql:host=example.com;dbname=database', 'user', 'password');
$statement = $pdo->query("SELECT some_field FROM some_table");
$row = $statement->fetch(PDO::FETCH_ASSOC);
echo htmlentities($row['some_field']);

// PDO + SQLite
$pdo = new PDO('sqlite:/path/db/foo.sqlite');
$statement = $pdo->query("SELECT some_field FROM some_table");
$row = $statement->fetch(PDO::FETCH_ASSOC);
echo htmlentities($row['some_field']);
```

PDO не перекладатиме ваші запити SQL або емулюватиме відсутні функції; це
призначений виключно для підключення до кількох типів баз даних з однаковими
API.

Що ще важливіше, `PDO` дозволяє безпечно вводити сторонні дані (наприклад,
IDs) у ваші SQL-запити, не турбуючись про впровадження SQL-ін’єкції в базу даних
напади. Це можливо за допомогою операторів PDO та зв’язаних параметрів.

Припустімо, скрипт PHP отримує числовий ідентифікатор як параметр запиту.
Цей ідентифікатор слід використовувати для отримання запису користувача з бази даних. Це є
`неправильний` спосіб зробити це:

```php
<?php
$pdo = new PDO('sqlite:/path/db/users.db');
$pdo->query("ВИБРАТИ ім'я FROM користувачів WHERE id = " . $_GET['id']); // <-- НІ!
```

Це жахливий код. Ви вставляєте необроблений параметр запиту в a
SQL запит. Це дозволить вам зламати миттєво, використовуючи практику
під назвою [SQL Injection](http://wiki.hashphp.org/Validation). Просто уяви
якщо хакер передає винахідливий параметр `id`, викликаючи URL-адресу, як
`http://domain.com/?id=1%3BDELETE+FROM+users`. Це встановить
`$_GET['id']` змінна `1;DELETE FROM users`, яка видаляє всі
ваші користувачі! Натомість вам слід очистити введений ідентифікатор за допомогою прив’язки PDO
параметри.

```php
<?php
$pdo = new PDO('sqlite:/path/db/users.db');
$stmt = $pdo->prepare('ВИБРАТИ ім'я FROM користувачів WHERE id = :id');
$id = filter_input(INPUT_GET, 'id', FILTER_SANITIZE_NUMBER_INT); // <-- спочатку фільтруйте дані (див. [Фільтрування даних](#data_filtering)), особливо важливо для ВСТАВЛЕННЯ, ОНОВЛЕННЯ тощо.
$stmt->bindParam(':id', $id, PDO::PARAM_INT); // <-- Автоматично очищається для SQL PDO
$stmt->виконати();
```

Це правильний код. Він використовує зв’язаний параметр у заяві PDO. Це
усуває зовнішній вхідний ідентифікатор перед тим, як його буде введено в базу даних
запобігання потенційним атакам SQL-ін’єкцій.

Для записів, таких як INSERT або UPDATE, особливо важливо все ще
Спочатку [відфільтруйте свої дані](#data_filtering) і очистіть їх для інших
речі (видалення тегів HTML, JavaScript тощо). PDO лише дезінфікує
це для SQL, а не для вашої програми.

- [Докладніше про PDO](https://secure.php.net/book.pdo)

Ви також повинні знати, що підключення до бази даних споживають ресурси та
було нечувано, що ресурси були вичерпані, якщо зв’язки були
не неявно закриті, однак це було більш поширеним в інших мовах.
Використовуючи PDO, ви можете неявно закрити з’єднання, знищивши
об’єкт, переконавшись, що всі решта посилань на нього видалено, тобто встановлено
до NULL. Якщо ви не зробите цього явно, PHP автоматично закриється
підключення, коли ваш сценарій закінчується - якщо, звичайно, ви не використовуєте
постійні зв'язки.

- [Дізнайтеся про PDO
  підключення](https://secure.php.net/pdo.connections)

## <a name="databases_interacting"></a> Взаємодія з базами даних

Коли розробники вперше починають вивчати PHP, вони часто змішують їх
взаємодія бази даних із їхньою логікою представлення, використовуючи код, який
може виглядати так:

```php
<ul>
<?php
foreach ($db->query('SELECT * FROM table') as $row) {
echo "<li>".$row['field1']." - ".$row['field1']."</li>";
}
?>
</ul>
```

Це погана практика з багатьох причин, головним чином тому, що це важко зробити
налагодження, важко перевірити, важко читати, і він збирається вивести багато
якщо ви не обмежите їх.

Хоча є багато інших рішень для цього - залежно від того, чи ви
надавайте перевагу [ООП](#об'єктно-орієнтоване програмування) або [функціональний
програмування](#functional-programming) - має бути певний елемент
поділ.

Розглянемо найпростіший крок:

```php
<?php
функція getAllFoos($db) {
return $db->query('SELECT * FROM table');
}

$результати = getAllFoos($db);
foreach ($results as $row) {
echo "<li>".$row['field1']." - ".$row['field1']."</li>"; // ПОГАНО!!
}
```

Це хороший початок. Помістіть ці два елементи в два різні файли та
у вас є чисте розділення.

Створіть клас, щоб розмістити цей метод, і у вас буде «модель». Створити
простий файл `.php` для розміщення логіки презентації, і у вас є
«Погляд», що дуже близько
[MVC](https://code.tutsplus.com/tutorials/mvc-for-noobs--net-10488) - a
загальна архітектура ООП для більшості [фреймворків](#frameworks).

**foo.php**

```php
<?php
$db = new PDO('mysql:host=localhost;dbname=testdb;charset=utf8mb4', 'ім'я користувача', 'пароль');

// Зробіть свою модель доступною
include 'models/FooModel.php';

// Створення екземпляра
$fooModel = new FooModel($db);
// Отримати список Foos
$fooList = $fooModel->getAllFoos();

// Показати вигляд
включати 'views/foo-list.php';
```

**models/FooModel.php**

```php
<?php
клас FooModel
{
protected $db;

public function __construct(PDO $db)
{
$this->db = $db;
}

public function getAllFoos() {
return $this->db->query('SELECT * FROM table');
}
}
```

**views/foo-list.php**

```php
<?php foreach ($fooList як $row): ?>
<li><?= $row['field1'] ?> - <?= $row['field1'] ?></li>
<?php endforeach ?>
```

Це, по суті, те саме, що робить більшість сучасних фреймворків,
хоча трохи більше вручну. Можливо, вам не доведеться робити все це кожен раз
часу, але змішуючи забагато логіки презентації та бази даних
взаємодія може стати справжньою проблемою, якщо ви колись цього захочете
[unit-test](#unit-testing) ваша програма.

## <a name="databases_abstraction_layers"></a> Шари абстракції

Багато фреймворків надають власний рівень абстракції, який може чи ні
сидіти поверх [PDO](https://secure.php.net/book.pdo). Це часто
емулювати функції для однієї системи бази даних, яких немає в іншій
загортання ваших запитів у методи PHP, надаючи вам справжню базу даних
абстракцію замість просто абстракції з’єднання, що PDO
забезпечує. Це, звичайно, додасть трохи накладних витрат, але якщо ви
створення портативної програми, яка повинна працювати з MySQL,
PostgreSQL і SQLite, тоді невеликі накладні витрати будуть того варті
заради чистоти коду.

Деякі шари абстракції були створені за допомогою
[PSR-0](https://www.php-fig.org/psr/psr-0/) або
[PSR-4](https://www.php-fig.org/psr/psr-4/) стандарти простору імен, тому можна
встановлюється в будь-якій програмі, яка вам подобається:

- [Атлас](https://atlasphp.io)
- [Aura SQL](https://github.com/auraphp/Aura.Sql)
  - [Вчення2
    DBAL](https://www.doctrine-project.org/projects/dbal.html)
- [Propel](http://propelorm.org/)
- [Zend-db](https://packages.zendframework.com/docs/latest/manual/en/index.html#zendframework/zend-db)

[На початок](#top)

# <a name="templating"></a> Створення шаблонів

Шаблони забезпечують зручний спосіб відокремлення вашого контролера від
логіку домену з вашої логіки презентації. Шаблони зазвичай містять
HTML вашої програми, але також може використовуватися для інших форматів,
наприклад XML. Шаблони часто називають «видами», які складають
**частина** другого компонента
[model-view-controller](https://phptherightway.com/pages/Design-Patterns.html#model-view-controller)
(MVC) шаблон архітектури програмного забезпечення.

## <a name="templating_benefits"></a> Переваги

Головною перевагою використання шаблонів є чітке розділення, яке вони створюють
між логікою презентації та рештою програми.
Шаблони несуть виключну відповідальність за відображення форматованого вмісту.
Вони не відповідають за пошук даних, збереження чи інше
комплексні завдання. Це призводить до чистішого та читабельнішого коду
особливо корисно в командному середовищі, де розробники працюють над
код на стороні сервера (контролери, моделі) і дизайнери працюють над
клієнтський код (розмітка).

Шаблони також покращують організацію коду презентації. Шаблони
зазвичай розміщуються в папці «views», кожна з яких визначена в одній
файл. Такий підхід заохочує повторне використання коду з більшими блоками коду
розбиваються на менші частини, які можна багаторазово використовувати, які часто називають частковими. для
наприклад, верхній і нижній колонтитул вашого сайту можна визначити як шаблони,
які потім включаються перед і після кожного шаблону сторінки.

Нарешті, залежно від бібліотеки, яку ви використовуєте, шаблони можуть запропонувати більше
безпека шляхом автоматичного блокування створеного користувачами вмісту. Деякі
бібліотеки навіть пропонують пісочниці, де є лише дизайнери шаблонів
надано доступ до змінних і функцій із білого списку.

## <a name="plain_php_templates"></a> Прості шаблони PHP

Звичайні шаблони PHP — це просто шаблони, які використовують рідний код PHP. Вони
є природним вибором, оскільки PHP насправді є мовою шаблонів.
Це просто означає, що ви можете поєднувати PHP-код з іншим кодом, наприклад
HTML. Це вигідно розробникам PHP, оскільки немає нового синтаксису
навчитися, вони знають доступні їм функції та їхні редактори коду
вже мають підсвічування синтаксису PHP і вбудоване автозавершення.
Крім того, звичайні шаблони PHP, як правило, дуже швидкі, оскільки не мають етапу компіляції
необхідно.

Кожен сучасний фреймворк PHP використовує певну систему шаблонів, більшість із них
які за замовчуванням використовують звичайний PHP. Поза рамками, як бібліотеки
[Пласти](http://platesphp.com/) або
[Aura.View](https://github.com/auraphp/Aura.View) полегшує роботу з
звичайні шаблони PHP простіше, пропонуючи сучасну функціональність шаблонів
такі як успадкування, макети та розширення.

### Простий приклад звичайного шаблону PHP

Використання бібліотеки [Plates](http://platesphp.com/).

```php
<?php // user_profile.php ?>

<?php $this->insert('header', ['title' => 'Профіль користувача']) ?>

<h1>Профіль користувача</h1>
<p>Вітаємо, <?=$this->escape($name)?></p>

<?php $this->insert('footer') ?>
```

### Приклад простих шаблонів PHP із використанням успадкування

Використання бібліотеки [Plates](http://platesphp.com/).

```php
<?php // template.php ?>

<html>
<голова>
<title><?=$title?></title>
</head>
<тіло>

<головний>
<?=$this->section('content')?>
</main>

</body>
</html>
```

```php
<?php // user_profile.php ?>

<?php $this->layout('template', ['title' => 'Профіль користувача']) ?>

<h1>Профіль користувача</h1>
<p>Вітаємо, <?=$this->escape($name)?></p>
```

## <a name="compiled_templates"></a> Компільовані шаблони

Хоча PHP перетворився на зрілу об’єктно-орієнтовану мову, він
[не покращився
багато](http://fabien.potencier.org/article/34/templating-engines-in-php)
як мова шаблонів. Скомпільовані шаблони, на кшталт
[Twig](https://twig.symfony.com/),
[Brainy](https://github.com/box/brainy), або
[Smarty](https://www.smarty.net/)\*, заповніть цю прогалину, запропонувавши новий
синтаксис, спеціально розроблений для створення шаблонів. Від автоматичного
Ескейпінг, успадкування та спрощені структури керування, скомпільовані
шаблони розроблено таким чином, щоб їх було легше писати, зрозуміліше читати та безпечніше
використовувати. Зібрані шаблони можна навіть використовувати для різних користувачів
мови, [Mustache](https://mustache.github.io/) є хорошим прикладом
це. Оскільки ці шаблони повинні бути скомпільовані, є невеликий
втрата продуктивності, однак це дуже мінімально за умови належного кешування
використовується.

_\*Хоча Smarty пропонує автоматичний вихід, ця функція НЕ ввімкнена
за замовчуванням._

### Простий приклад скомпільованого шаблону

Використання бібліотеки [Twig](https://twig.symfony.com/).

```html-jinja
{% включають 'header.html' з {'title': 'Профіль користувача'} %}

<h1>Профіль користувача</h1>
<p>Привіт, {{ name }}</p>

{% включають 'footer.html' %}
```

### Приклад скомпільованих шаблонів із використанням успадкування

Використання бібліотеки [Twig](https://twig.symfony.com/).

```html-jinja
// template.html

<html>
<голова>
<title>{% block title %}{% endblock %}</title>
</head>
<тіло>

<головний>
{% block content %}{% endblock %}
</main>

</body>
</html>
```

```html-jinja
// user_profile.html

{% розширює "template.html" %}

{% block title %}Профіль користувача{% endblock %}
{% block content %}
<h1>Профіль користувача</h1>
<p>Привіт, {{ name }}</p>
{% endblock %}
```

## <a name="templating_further_reading"></a> Подальше читання

### Статті та посібники

- [Двигуни шаблонів в PHP](http://fabien.potencier.org/article/34/templating-engines-in-php)
- [Вступ до представлень і шаблонів у CodeIgniter](https://code.tutsplus.com/tutorials/an-introduction-to-views-templating-in-codeigniter--net-25648)
- [Початок роботи з PHP Шаблони](https://www.smashingmagazine.com/2011/10/getting-started-with-php-templating/)
- [Запустіть власну систему шаблонів PHP](https://code.tutsplus.com/tutorials/roll-your-own-templating-system-in-php--net-16596)
- [Майстер Сторінки](https://laracasts.com/series/laravel-from-scratch/episodes/7)
- [Робота з шаблонами в Symfony 2](https://code.tutsplus.com/tutorials/working-with-templates-in-symfony-2--cms-21172)
- [Безпечніше писати Шаблони](https://github.com/box/brainy/wiki/Writing-Safe-Templates)

### Бібліотеки

- [Aura.View](https://github.com/auraphp/Aura.View) _(рідний)_
- [Blade](https://laravel.com/docs/blade) _(зібрано, структура
  конкретний)_
- [Brainy](https://github.com/box/brainy) _(зібрано)_
- [Dwoo](http://dwoo.org/) _(зібрано)_
- [Latte](https://github.com/nette/latte) _(зібрано)_
- [Вуса](https://github.com/bobthecow/mustache.php) _(зібрано)_
- [PHPTAL](https://phptal.org/) _(зібрано)_
- [Пласти](http://platesphp.com/) _(рідний)_
- [Smarty](https://www.smarty.net/) _(зібрано)_
- [Twig](https://twig.symfony.com/) _(зібрано)_
- [Zend\View](https://framework.zend.com/manual/2.3/en/modules/zend.view.quick-start.html)
  _(нативний, специфічний для фреймворку)_

[На початок](#top)

# <a name="errors_and_exceptions"></a> $adapter

## <a name="errors"></a> Помилки

У багатьох мовах програмування з «значною кількістю винятків» завжди, коли щось піде
неправильно буде створено виняток. Це, звичайно, життєздатний спосіб зробити
речі, але PHP — це мова програмування з «виключеннями». Поки це
дійсно є винятки, і більше ядра починає їх використовувати, коли
працюючи з об’єктами, більша частина самого PHP намагатиметься продовжувати обробку
незалежно від того, що станеться, якщо не станеться фатальна помилка.

Наприклад:

```sh
$ php -a
php > echo $foo;
Примітка: невизначена змінна: foo у коді оболонки php у рядку 1
```

Це лише повідомлення про помилку, і PHP із задоволенням продовжить роботу. Це може бути
заплутує тих, хто приходить із мов із «значною кількістю винятків», тому що
наприклад, посилання на відсутню змінну в Python викличе
виняток:

```sh
$ python
>>> надрукувати foo
Traceback (останній останній виклик):
Файл "<stdin>", рядок 1, у <module>
NameError: ім'я 'foo' не визначено
```

Єдина реальна відмінність полягає в тому, що Python злякається через будь-яку дрібницю
так, щоб розробники могли бути дуже впевнені в будь-якій потенційній проблемі або
edge-case перехоплюється, тоді як PHP продовжить обробку, якщо
трапляється щось надзвичайне, після чого видається помилка та
повідомте про це.

### Серйозність помилки

PHP має кілька рівнів серйозності помилок. Три найпоширеніші типи
повідомлення - це помилки, повідомлення та попередження. Вони мають різні рівні
тяжкості; `E_ERROR`, `E_NOTICE` і `E_WARNING`. Помилки фатальні
помилки під час виконання та зазвичай спричинені помилками у вашому коді та потребами
потрібно виправити, оскільки вони призведуть до припинення виконання PHP. Повідомлення мають рекомендаційний характер
повідомлення, викликані кодом, який може або не може викликати проблеми під час
виконання сценарію, виконання не зупинено. Попередження несмертельні
помилки, виконання сценарію не буде зупинено.

Ще один тип повідомлень про помилки, які повідомляються під час компіляції, — це `E_STRICT`
повідомлення. Ці повідомлення використовуються для пропозиції змін до вашого коду
допомогти забезпечити найкращу взаємодію та пряму сумісність із
майбутні версії PHP.

### Зміна поведінки звітів про помилки PHP

Повідомлення про помилки можна змінити за допомогою налаштувань PHP та/або функції PHP
дзвінки. Використовуючи вбудовану функцію PHP `error_reporting()`, ви можете встановити
рівень помилок за тривалістю виконання сценарію проходженням
одна із попередньо визначених констант рівня помилки, тобто якщо ви тільки хочете
див. Помилки та попередження, але не Повідомлення, тоді ви можете налаштувати, що:

```php
<?php
error_reporting(E_ERROR | E_WARNING);
```

Ви також можете контролювати, чи відображатимуться помилки на екрані
(добре для розробки) або приховане, і зареєстроване (добре для виробництва). для
більше інформації про це див. [Помилка
Звітування](#error_reporting).

### Вбудоване придушення помилок

Ви також можете наказати PHP придушувати певні помилки за допомогою контролю помилок
Оператор `@`. Ви ставите цей оператор на початку виразу,
і будь-яка помилка, яка є прямим результатом виразу, замовчується.

```php
<?php
echo @$foo['bar'];
```

Це виведе `$foo['bar']`, якщо воно існує, але просто поверне a
null і нічого не друкувати, якщо ключ змінної `$foo` або ` 'bar`` цього не робить існують. Без оператора керування помилками цей вираз можна створити a  `Примітка PHP: Невизначена змінна: foo` або
Помилка «Примітка PHP: невизначений індекс: панель».

Це може здатися хорошою ідеєю, але є кілька небажаних
компроміси. PHP обробляє вирази з використанням `@` менш продуктивним способом
ніж вирази без `@`. Передчасна оптимізація може бути коренем
усіх аргументів програмування, але особливо продуктивність
важливо для вашої програми/бібліотеки, важливо розуміти
наслідки роботи оператора контролю помилок.

По-друге, оператор контролю помилок **повністю** ковтає помилку.
Помилка не відображається, і помилка не надсилається до журналу помилок.
Крім того, стандартні/виробничі системи PHP не мають можливості вимкнути помилку
оператор управління. Можливо, ви маєте рацію щодо помилки, яку бачите
нешкідлива, інша, менш нешкідлива помилка буде так само мовчазною.

Якщо є спосіб уникнути оператора придушення помилок, вам слід
розглянути це. Наприклад, наш код вище можна переписати так:

```php
<?php
// Нульовий оператор об'єднання
echo $foo['bar'] ?? '';
```

Одним із випадків, коли придушення помилок може мати сенс, є `fopen()`
не вдається знайти файл для завантаження. Ви можете перевірити існування
файл, перш ніж спробувати його завантажити, але якщо файл буде видалено після
перевірте та перед `fopen()` (що може здатися неможливим, але може
трапиться), тоді `fopen()` поверне false _і_ видасть помилку. Це є
потенційно щось має вирішити PHP, але це один випадок, коли помилка
придушення може здатися єдиним дійсним рішенням.

Раніше ми згадували, що стандартну систему PHP неможливо вимкнути
оператор контролю помилок. однак,
[Xdebug](https://xdebug.org/docs/basic) має `xdebug.scream` ini
параметр, який вимкне оператор контролю помилок. Ви можете встановити це
через ваш файл `php.ini` з наступним.

```ini
xdebug.scream = On
```

Ви також можете встановити це значення під час виконання за допомогою функції `ini_set`

```php
<?php
ini_set('xdebug.scream', '1')
```

Розширення PHP «[Scream](https://secure.php.net/book.scream)» пропонує
Функціональність подібна до Xdebug, хоча налаштування ini у Scream є
під назвою `scream.enabled`.

Це найбільш корисно, коли ви налагоджуєте код і підозрюєте, що
інформаційна помилка придушена. Використовуйте scream обережно та як a
тимчасовий засіб налагодження. Є багато бібліотечного коду PHP, який може бути не таким
робота з вимкненим оператором контролю помилок.

- [Контроль помилок
  Оператори](https://secure.php.net/language.operators.errorcontrol)
- [SitePoint](https://www.sitepoint.com/)
- [Xdebug](https://xdebug.org/docs/basic)
- [Крик](https://secure.php.net/book.scream)

### ErrorException

PHP цілком здатний бути програмним забезпеченням із «значною кількістю винятків».
мовою, і для перемикання потрібно лише кілька рядків коду.
По суті, ви можете викидати свої «помилки» як «винятки», використовуючи
Клас `ErrorException`, який розширює клас `Exception`.

Це звичайна практика, яку впроваджує велика кількість сучасних
такі фреймворки, як Symfony і Laravel. У режимі налагодження _(або режимі розробника)_
обидва ці фреймворки відображатимуть гарне та чисте _трасування стеку_.

Є також деякі пакети, доступні для покращення помилок і винятків
обробка та звітність. Як [Ой!](https://filp.github.io/whoops/),
який постачається разом зі стандартною установкою Laravel і може використовуватися в
будь-який каркас також.

Ви можете впоратися з помилками як винятками в розробці
краще, ніж звичайний результат, і якщо ви бачите виняток під час
розробки, ви можете загорнути це в оператор catch із конкретним
інструкції, як впоратися з ситуацією. Кожен виняток, який ви ловите
миттєво робить вашу програму трохи надійнішою.

Більше інформації про це та докладні відомості про те, як використовувати `ErrorException` з
обробку помилок можна знайти за адресою [ErrorException
Клас](https://secure.php.net/class.errorexception).

- [Контроль помилок
  Оператори](https://secure.php.net/language.operators.errorcontrol)
- [Попередньо визначені константи для помилок
  Обробка](https://secure.php.net/errorfunc.constants)
- [`error_reporting()`](https://secure.php.net/function.error-reporting)
- [Звітування](#error_reporting)

## <a name="exceptions"></a> Винятки

Винятки становлять стандартну частину більшості популярних мов програмування,
але програмісти PHP часто не помічають їх. Такі мови, як Ruby
надзвичайно важкі, тому щоразу, коли щось піде не так, наприклад
помилка HTTP-запиту, помилковий запит до БД або навіть зображення
ресурс не знайдено, Ruby (або використовувані дорогоцінні камені) викине an
виняток на екрані означає, що ви миттєво дізнаєтеся, що є помилка.

Сам PHP досить слабкий із цим і викликом `file_get_contents()`
як правило, ви отримуєте лише `FALSE` і попередження. Багато старіших PHP
такі фреймворки, як CodeIgniter, просто повертатимуть false, реєструйте повідомлення
їх власних журналів і, можливо, дозволить вам використовувати такий метод, як
`$this->upload->get_error()`, щоб побачити, що пішло не так. Проблема тут
що ви повинні піти шукати помилку та перевірити документи, щоб побачити, що
метод помилки призначений для цього класу, замість того, щоб зробити його надзвичайно
очевидний.

Інша проблема полягає в тому, що класи автоматично видають помилку
і вийдіть із процесу. Коли ви робите це, ви зупиняєте іншого розробника
від можливості динамічно обробляти цю помилку. Винятки повинні бути
кидається, щоб повідомити розробнику про помилку; потім вони можуть вибрати, як
впоратися з цим. наприклад:

```php
<?php
$email = new Fuel\Email;
$email->subject('Моя тема');
$email->body('Як ти, біса?');
$email->to('guy@example.com', 'Some Guy');

спробувати
{
$email->send();
}
catch(Fuel\Email\ValidationFailedException $e)
{
// Помилка перевірки
}
catch(Fuel\Email\SendingFailedException $e)
{
// Драйвер не зміг надіслати електронний лист
}
нарешті
{
// Виконується незалежно від того, чи був викинутий виняток, і до відновлення нормального виконання
}
```

### Винятки SPL

Загальний клас `Exception` надає дуже мало контексту для налагодження
розробник; однак, щоб виправити це, можна створити a
спеціалізований тип `Exception` за допомогою підкласу загального `Exception`
клас:

```php
<?php
class ValidationException extends Exception {}
```

Це означає, що ви можете додати кілька блоків catch і обробляти різні
Винятки різні. Це може призвести до створення _багато_
спеціальні винятки, деяких з яких можна було б уникнути за допомогою SPL
Винятки надані в [розширенні SPL](#standard_php_library).

Якщо, наприклад, ви використовуєте магічний метод `__call()` і недійсний метод
тоді запитується замість викидання стандартного винятку, який є
vague, або створення спеціального винятку саме для цього, ви можете просто
`генерувати нове виключення BadMethodCallException;`.

- [Читати про винятки](https://secure.php.net/language.exceptions)
- [Прочитайте про винятки SPL](https://secure.php.net/spl.exceptions)
- [Вкладені винятки в
  PHP](https://www.brandonsavage.net/exceptional-php-nesting-exceptions-in-php/)

[На початок](#top)

# <a name="security"></a> Безпека

Найкращий ресурс із безпеки PHP, який я знайшов, це [The 2018 Guide to
Створення безпечного PHP
Програмне забезпечення](https://paragonie.com/blog/2017/12/2018-guide-building-secure-php-software)
від [Paragon Initiative](https://paragonie.com/).

## <a name="web_application_security"></a> Безпека веб-додатків

Для кожного розробника PHP дуже важливо вивчити [основи веб безпеки](https://paragonie.com/blog/2015/08/gentle-introduction-application-security), які можна розбити на декілька широких тем:

1. Розділення код-дані.

- Коли дані виконуються як код, ви отримуєте SQL Injection, Cross-Site
  Сценарії, включення локальних/віддалених файлів тощо.
- Коли код друкується як дані, ви отримуєте витік інформації (джерело
  розкриття коду або, у випадку програм на C, достатньо
  інформацію для обходу
  [ASLR](http://searchsecurity.techtarget.com/definition/address-space-layout-randomization-ASLR)).

2. Логіка застосування.

- Відсутні елементи керування автентифікацією або авторизацією.
- Перевірка введених даних.

3. Операційне середовище.

- Версії PHP.
- Сторонні бібліотеки.
- Операційна система.

4. Слабкі сторони криптографії.
   - [Слабкий випадков
     номери](https://paragonie.com/blog/2016/01/on-design-and-implementation-stealth-backdoor-for-web-applications).
   - [Виб.-шифр
     атаки](https://paragonie.com/blog/2015/05/using-encryption-and-authentication-correctly).

- [Інформація про бічний канал
  витоки](http://blog.ircmaxell.com/2014/11/its-all-about-time.html).

Є погані люди, готові та готові використовувати вашу веб-програму.
Важливо вжити необхідних запобіжних заходів, щоб зміцнити павутину
безпека програми. На щастя, добрі люди в [The Open Web
Проект безпеки додатків](https://www.owasp.org/) (OWASP).
склав вичерпний список відомих проблем безпеки та методів
захистіть себе від них. Це обов’язково для прочитання
розробник, який піклується про безпеку. [Вижити в глибині: PHP
Безпека](https://phpsecurity.readthedocs.io/en/latest/index.html) автором
Padraic Brady також є ще одним хорошим посібником із безпеки веб-додатків
PHP.

- [Прочитайте безпеку OWASP
  Посібник](https://www.owasp.org/index.php/Guide_Table_of_Contents)

## <a name="password_hashing"></a> Хешування пароля

Зрештою кожен створює програму PHP, яка покладається на вхід користувача.
Імена користувачів і паролі зберігаються в базі даних і потім використовуються
аутентифікувати користувачів під час входу.

Важливо, щоб ви правильно
[_хеш_](https://wikipedia.org/wiki/Cryptographic_hash_function)
паролі, перш ніж зберігати їх. Хешування та шифрування — це [двоє дуже
інший
речі](https://paragonie.com/blog/2015/08/you-wouldnt-base64-a-password-cryptography-decoded)
які часто плутають.

Хешування є необоротною односторонньою функцією. Це виробляє a
рядок фіксованої довжини, який неможливо звернути. Це означає, що ви можете
порівняйте хеш з іншим, щоб визначити, чи вони обидва походять від
той самий вихідний рядок, але ви не можете визначити вихідний рядок. Якщо
паролі не хешуються, а доступ до вашої бази даних здійснюється за допомогою
неавторизована третя сторона, тепер усі облікові записи користувачів скомпрометовано.

На відміну від хешування, шифрування є оборотним (за умови, що у вас є ключ).
Шифрування корисне в інших сферах, але це погана стратегія для безпеки
збереження паролів.

Паролі також повинні бути індивідуальними
[_salted_](<https://wikipedia.org/wiki/Salt_(cryptography)>), додавши
довільний рядок до кожного пароля перед хешуванням. Це запобігає словнику
атак і використання «райдужних таблиць» (зворотний список критографічних
хеші для типових паролів.)

Хешування та соління є життєво важливими, оскільки часто користувачі використовують той самий пароль
кілька служб і якість пароля може бути низькою.

Крім того, вам слід використовувати [спеціалізований _хешування паролів_
алгоритм](https://paragonie.com/blog/2016/02/how-safely-store-password-in-2016)
а не швидка криптографічна хеш-функція загального призначення (наприклад,
SHA256). Короткий список прийнятних алгоритмів хешування паролів (станом на
червень 2018 р.) використовувати:

- Argon2 (доступний у PHP 7.2 і новіших версіях)
- Скрипт
- **Bcrypt** (PHP надає вам це; див. нижче)
- PBKDF2 з HMAC-SHA256 або HMAC-SHA512

На щастя, сьогодні PHP робить це легко.

**Хешування паролів за допомогою `password_hash`**

У PHP 5.5 було представлено `password_hash()`. У цей час він використовується
BCrypt, найнадійніший алгоритм, який зараз підтримує PHP. Це буде
оновлено в майбутньому, щоб підтримувати більше алгоритмів, якщо це необхідно. The
Бібліотека `password_compat` була створена для забезпечення прямої сумісності
для PHP \>= 5.3.7.

Нижче ми хешуємо рядок, а потім перевіряємо хеш на новий рядок.
Оскільки наші два рядки джерела різні («секретний пароль» проти.
«поганий пароль») цей вхід не вдасться.

```php
<?php
вимагати 'password.php';

$passwordHash = password_hash('секретний-пароль', PASSWORD_DEFAULT);

if (password_verify('bad-password', $passwordHash)) {
// Правильний пароль
} ще {
// Неправильний пароль
}
```

`password_hash()` подбає про підбір пароля за вас. Сіль є
зберігається разом із алгоритмом і «вартістю» як частина хешу.
`password_verify()` витягує це, щоб визначити, як перевірити
пароль, тож вам не потрібно окреме поле бази даних для зберігання ваших
солі.

- [Дізнатися про
  `password_hash()`](https://secure.php.net/function.password-hash)
- [`password_compat` для PHP \>= 5.3.7 && \<
  5.5](https://github.com/ircmaxell/password_compat)
- [Дізнайтеся про хешування щодо
  криптографія](https://wikipedia.org/wiki/Cryptographic_hash_function)
- [Дізнайтеся про солі](<https://wikipedia.org/wiki/Salt_(cryptography)>)
- [PHP `password_hash()` RFC](https://wiki.php.net/rfc/password_hash)

## <a name="data_filtering"></a> Фільтрування даних

Ніколи (ніколи) не довіряйте іноземним введенням у ваш код PHP.
Завжди очищайте та перевіряйте іноземні дані перед використанням у коді. The
Функції `filter_var()` і `filter_input()` можуть очистити текст і
перевіряти текстові формати (наприклад, адреси електронної пошти).

Зовнішнє введення може бути чим завгодно: вхідні дані форми `$_GET` і `$_POST`,
деякі значення в суперглобалі `$_SERVER` і тіло запиту HTTP через
`fopen('php://input', 'r')`. Пам’ятайте, іноземне введення не обмежується
дані форми, надані користувачем. Завантажені та завантажені файли, сесія
значення, дані cookie та дані сторонніх веб-сервісів є сторонніми
введення теж.

Хоча сторонні дані можна зберігати, комбінувати та отримувати доступ пізніше, це так

включити дані у свій код, запитайте себе, чи правильно дані відфільтровано
і чи можна йому вірити.

Дані можуть бути _фільтровані_ по-різному залежно від їх призначення. Наприклад,
коли невідфільтрований іноземний вхід передається на вихід сторінки HTML, це може
Виконуйте HTML і JavaScript на своєму сайті! Це відоме як міжсайтове
Сценарії (XSS) можуть бути дуже небезпечними атаками. Один із способів уникнути XSS
полягає в тому, щоб очистити всі створені користувачем дані перед виведенням їх на вашу сторінку
шляхом видалення тегів HTML за допомогою функції `strip_tags()` або екранування
символи зі спеціальним значенням у відповідні сутності HTML
функції `htmlentities()` або `htmlspecialchars()`.

Іншим прикладом є передача параметрів для виконання в командному рядку.
Це може бути надзвичайно небезпечно (і зазвичай погана ідея), але ви можете
скористайтеся вбудованою функцією `escapeshellarg()` для очищення виконаного
аргументи команди.

Останній приклад — прийняття стороннього введення для визначення файлу для завантаження
з файлової системи. Цим можна скористатися, змінивши назву файлу на a
шлях до файлу. Вам потрібно видалити `"/"`, `"../"`, [null
байтів](https://secure.php.net/security.filesystem.nullbytes) або інше
символів із шляху до файлу, щоб він не міг завантажити приховані, непублічні або
конфіденційні файли.

- [Дізнайтеся про фільтрацію даних](https://secure.php.net/book.filter)
- [Дізнатися про
  `filter_var`](https://secure.php.net/function.filter-var)
- [Дізнатися про
  `filter_input`](https://secure.php.net/function.filter-input)
- [Дізнайтеся про обробку null
  байтів](https://secure.php.net/security.filesystem.nullbytes)

### Дезінфекція

Дезінфекція видаляє (або усуває) незаконні або небезпечні символи з
іноземний вхід.

Наприклад, вам слід продезінфікувати іноземне введення перед тим, як включити
ввести в HTML або вставити його в необроблений запит SQL. Коли ви використовуєте bound
параметри з [PDO](#databases), він очистить введені дані замість вас.

Іноді потрібно дозволити деякі безпечні теги HTML у вхідних даних
включивши його на сторінку HTML. Це дуже важко зробити, і багато хто цього уникає
за допомогою іншого більш обмеженого форматування, наприклад Markdown або BBCode,
хоча бібліотеки, такі як [HTML
Очищувач](http://htmlpurifier.org/) існує з цієї причини.

[Див. Дезінфекція
Фільтри](https://secure.php.net/filter.filters.sanitize)

### Десеріалізація

Небезпечно `unserialize()` дані від користувачів або інших ненадійних осіб
джерела. Це може дозволити зловмисникам створювати екземпляри об’єктів (за допомогою
визначені користувачем властивості), чиї деструктори будуть виконані, **навіть якщо
самі об’єкти не використовуються**. Тому слід уникати
десеріалізація ненадійних даних.

Якщо вам абсолютно необхідно десеріалізувати дані з ненадійних джерел, використовуйте PHP
7
[`allowed_classes`](https://secure.php.net/manual/function.unserialize.php)
параметр для обмеження типів об’єктів, які можна десеріалізувати.

### Перевірка

Перевірка гарантує, що іноземні дані відповідають вашим очікуванням. Наприклад,
Ви можете підтвердити електронну адресу, номер телефону або вік
обробка реєстраційного подання.

[Див. фільтри перевірки](https://secure.php.net/filter.filters.validate)

## <a name="configuration_files"></a> Файли конфігурації

Під час створення конфігураційних файлів для ваших програм, передові практики
рекомендуємо скористатися одним із таких методів:

- Рекомендується зберігати конфігураційну інформацію
  де до нього неможливо отримати прямий доступ і отримати його через файл
  система.
- Якщо ви повинні зберігати файли конфігурації в корені документа,
  назвіть файли з розширенням `.php`. Це гарантує, що навіть якщо
  доступ до сценарію здійснюється безпосередньо, він не буде виводитися як звичайний
  текст.
- Інформація у конфігураційних файлах має бути захищена відповідним чином,
  через шифрування або дозволи файлової системи групи/користувача.
- Бажано переконатися, що ви не фіксуєте конфігурацію
  файли, що містять конфіденційну інформацію, напр. паролі або токени API
  для контролю джерела.

## <a name="register_globals"></a> Реєстрація Globals

**ПРИМІТКА:** Починаючи з PHP 5.4.0, налаштування `register_globals` було
видалено і більше не може використовуватися. Це включено лише як попередження
для тих, хто перебуває в процесі оновлення застарілої програми.

Якщо ввімкнено, параметр конфігурації `register_globals` робить декілька
типи змінних (включно з `$_POST`, `$_GET` і
`$_REQUEST`), доступний у глобальній області вашої програми. Це може
легко призвести до проблем безпеки, оскільки ваша програма не може ефективно працювати
сказати, звідки надходять дані.

Наприклад: `$_GET['foo']` буде доступним через `$foo`, який може
перевизначати змінні, які були оголошені.

Якщо ви використовуєте PHP \< 5.4.0, **переконайтеся**, що `register_globals`
**вимкнено**.

- [Register_globals у PHP
  посібник](https://secure.php.net/security.globals)

## <a name="error_reporting"></a> Звіт про помилку

Реєстрація помилок може бути корисною для пошуку проблемних місць у вашому
додаток, але він також може надавати інформацію про структуру
ваше застосування до зовнішнього світу. Щоб ефективно захистити свій
застосування від проблем, які можуть бути викликані результатом цих
повідомлення, вам потрібно налаштувати ваш сервер по-іншому під час розробки
проти виробництва (живий).

### Розвиток

Щоб показати всі можливі помилки під час **розробки**, налаштуйте
такі налаштування у вашому `php.ini`:

```ini
display_errors = Увімк
display_startup_errors = Увімк
error_reporting = -1
log_errors = Увімкнено
```

Передача значення `-1` покаже всі можливі помилки, навіть якщо
у майбутніх версіях PHP додаються нові рівні та константи. `E_ALL`
константа також поводиться таким чином, починаючи з PHP 5.4. -
[php.net](https://secure.php.net/function.error-reporting)

Константа рівня помилки `E_STRICT` була введена в 5.3.0 і не є такою
частина `E_ALL`, однак вона стала частиною `E_ALL` у 5.4.0. Що робить
це означає? З точки зору звітності про всі можливі помилки у версії 5.3 it
означає, що ви повинні використовувати `-1` або `E_ALL | E_STRICT`.

**Повідомлення про всі можливі помилки за версією PHP**

- \< 5.3 `-1` або `E_ALL`
- 5.3 `-1` або `E_ALL | E_STRICT`
- \> 5.3 `-1` або `E_ALL`

### Виробництво

Щоб приховати помилки у вашому **виробничому** середовищі, налаштуйте свій
`php.ini` як:

```ini
display_errors = Вимк
display_startup_errors = Вимк
error_reporting = E_ALL
log_errors = Увімкнено
```

З цими параметрами у виробництві помилки все одно реєструватимуться в
журнали помилок для веб-сервера, але не будуть показані користувачеві. для
більше інформації про ці налаштування див. у посібнику PHP:

- [error_reporting](https://secure.php.net/errorfunc.configuration#ini.error-reporting)
- [display_errors](https://secure.php.net/errorfunc.configuration#ini.display-errors)
- [display_startup_errors](https://secure.php.net/errorfunc.configuration#ini.display-startup-errors)
- [log_errors](https://secure.php.net/errorfunc.configuration#ini.log-errors)

[На початок](#top)

# <a name="testing"></a> Тестування

Написання автоматизованих тестів для вашого коду PHP вважається найкращою практикою
і може призвести до добре побудованих програм. Автоматизовані тести - це чудово
інструмент, щоб переконатися, що ваша програма не ламається під час створення
зміни або додавання нових функцій, і їх не слід ігнорувати.

Існує кілька різних типів інструментів тестування (або фреймворків)
доступні для PHP, які використовують різні підходи - усі вони є
намагаючись уникнути ручного тестування та потреби у великій гарантії якості
команд, щоб переконатися, що останні зміни не порушили існуючі
функціональність.

## <a name="test_driven_development"></a> Розробка, орієнтована на тестування

З [Вікіпедії](https://wikipedia.org/wiki/Test-driven_development):

Тестована розробка (TDD) — це процес розробки програмного забезпечення, який
спирається на повторення дуже короткого циклу розвитку: спочатку
розробник пише невдалий автоматизований тестовий приклад, який визначає бажаний
покращення або створення нової функції, потім створює код для проходження цього тесту та
остаточно переробляє новий код до прийнятних стандартів. Кент Бек, який
йому приписують розробку або «перевідкриття» техніки,
заявив у 2003 році, що TDD заохочує простий дизайн і надихає
впевненість.

Є кілька різних типів тестування, які ви можете зробити для себе
застосування:

### Модульне тестування

Модульне тестування — це підхід до програмування для забезпечення функцій, класів і
методи працюють, як очікувалося, з того моменту, коли ви створюєте їх усі
шлях через цикл розвитку. Перевіряючи значення, що входять і виходять
різноманітних функцій і методів, ви можете переконатися у внутрішній логіці
працює правильно. Використовуючи ін’єкцію залежностей і створюючи «макет»
класи та заглушки, ви можете перевірити, чи правильно використовуються залежності
для ще кращого покриття тесту.

Коли ви створюєте клас або функцію, вам слід створити модульний тест
кожна поведінка, яку вона повинна мати. На дуже базовому рівні ви повинні переконатися
він помиляється, якщо ви надсилаєте йому погані аргументи, і переконайтеся, що він працює, якщо ви
надішліть йому дійсні аргументи. Це допоможе переконатися, що коли ви робите
змінює цей клас або функцію пізніше в циклі розробки, що
старі функції продовжують працювати належним чином. Єдиний
альтернативою цьому буде `var_dump()` у test.php, що ні в якому разі
створити додаток - великий чи маленький.

Інше використання модульних тестів - це внесок у відкритий код. Якщо можеш
напишіть тест, який показує несправну функціональність (тобто не вдається), потім виправте це,
і показати проходження тесту, патчі з більшою ймовірністю будуть прийняті.
Якщо ви запускаєте проект, який приймає запити на вилучення, тоді вам слід запропонувати

[PHPUnit](https://phpunit.de/) — це фактична платформа тестування для
написання модульних тестів для PHP-додатків, але їх декілька
альтернативи

- [atoum](https://github.com/atoum/atoum)
- [Келан](https://github.com/crysalead/kahlan)
- [Peridot](https://peridot-php.github.io/)
- [SimpleTest](http://simpletest.org)

### Інтеграційне тестування

З [Вікіпедії](https://wikipedia.org/wiki/Integration_testing):

Інтеграційне тестування (іноді називається інтеграцією та тестуванням,
скорочено «I&T») — це етап тестування програмного забезпечення, на якому
окремі програмні модулі об'єднуються і тестуються як група. Це
відбувається після модульного тестування та перед перевірочним тестуванням. Інтеграція
тестування приймає як вхідні модулі, які пройшли модульне тестування, групи
їх у більших агрегатах, застосовує тести, визначені в інтеграції
тестовий план для цих агрегатів і надає як результат
інтегрована система готова до тестування системи.

Можна використовувати багато тих самих інструментів, які можна використовувати для модульного тестування
інтеграційне тестування, оскільки використовується багато однакових принципів.

### Функціональне тестування

Іноді також відоме як приймальне тестування, функціональне тестування складається
використання інструментів для створення автоматизованих тестів, які фактично використовують ваші
замість того, щоб просто перевіряти, чи є окремі одиниці коду
поводитися правильно, а окремі одиниці можуть спілкуватися між собою
правильно. Ці інструменти зазвичай працюють з використанням реальних даних і моделювання
фактичні користувачі програми.

#### Інструменти функціонального тестування

- [Selenium](https://docs.seleniumhq.org/)
- [Норка](http://mink.behat.org/)
- [Codeception](https://codeception.com/) — це повне тестування
  фреймворк, що включає інструменти приймального тестування
- [Storyplayer](https://datasift.github.io/storyplayer/) є
  фреймворк для повного тестування, що включає підтримку створення та
  знищення тестових середовищ на вимогу

## <a name="behavior_driven_development"></a> Розробка, керована поведінкою

Існує два різних типи розвитку, керованого поведінкою (BDD):
SpecBDD і StoryBDD. SpecBDD зосереджується на технічній поведінці коду,
у той час як StoryBDD зосереджується на поведінці чи взаємодії в бізнесі чи функціях.
PHP має рамки для обох типів BDD.

За допомогою StoryBDD ви пишете зрозумілі для людини історії, які описують
поведінка вашої програми. Потім ці історії можна вважати реальними
тестує вашу програму. Фреймворк, який використовується в програмах PHP
для StoryBDD — це [Behat](http://behat.org/), натхненний Ruby’s

для опису поведінки функції.

За допомогою SpecBDD ви пишете специфікації, які описують, як ваші фактичні
код повинен поводитися. Замість того, щоб тестувати функцію чи метод, ви
описуючи, як ця функція або метод повинні поводитися. PHP пропонує
[PHPSpec](https://www.phpspec.net/) для цієї мети. Це
фреймворк натхненний [проектом RSpec](https://rspec.info/) для
рубін.

### BDD Посилання

- [Behat](http://behat.org/), структура StoryBDD для PHP, натхненна
  проект Ruby [Cucumber](https://cucumber.io/);
- [PHPSpec](https://www.phpspec.net/), структура SpecBDD для PHP,
  натхненний проектом Ruby [RSpec](https://rspec.info/);
- [Codeception](https://codeception.com/) — це повне тестування
  структура, яка використовує принципи BDD.

## <a name="complementary_testing_tools"></a> Додаткові інструменти тестування

Окрім індивідуального тестування та структур, керованих поведінкою, існують
також ряд загальних фреймворків і допоміжних бібліотек, корисних для будь-кого
обраний підхід.

### Посилання на інструменти

- [Selenium](https://www.seleniumhq.org/) — це інструмент автоматизації браузера
  який можна [інтегрувати з
  PHPUnit](https://github.com/giorgiosironi/phpunit-selenium/)
- [Mockery](https://github.com/padraic/mockery) є фіктивним об’єктом
  Фреймворк, з яким можна інтегрувати
  [PHPUnit](https://phpunit.de/) або
  [PHPSpec](https://www.phpspec.net/)
- [Пророцтво](https://github.com/phpspec/prophecy) є дуже
  самовпевнений, але дуже потужний і гнучкий PHP об'єкт висміювання
  рамка. Його інтегровано з [PHPSpec](https://www.phpspec.net/)
  і може використовуватися з [PHPUnit](https://phpunit.de/).
- [php-mock](https://github.com/php-mock/php-mock) - це бібліотека для
  допомагають імітувати рідні функції PHP.
- [Інфекція](https://github.com/infection/infection) є PHP
  реалізація [Мутація
  Тестування](https://en.wikipedia.org/wiki/Mutation_testing), щоб допомогти
  вимірювати ефективність своїх тестів.

[На початок](#top)

# <a name="servers_and_deployment"></a> Сервери та розгортання

Програми PHP можна розгортати та запускати на робочих веб-серверах у a
кількість способів.

## <a name="platform_as_a_service"></a> Платформа як послуга (PaaS)

PaaS забезпечує системну та мережеву архітектуру, необхідну для запуску PHP
програми в Інтернеті. Це означає, що для
запуск програм PHP або фреймворків PHP.

Останнім часом PaaS став популярним методом розгортання, розміщення та
масштабування програм PHP будь-якого розміру. Ви можете знайти список [PHP PaaS
Постачальники «Платформа як послуга»](#php_paas_providers) у нашому
[розділ ресурсів](#ресурси).

## <a name="virtual_or_dedicated_servers"></a> Віртуальні або виділені сервери

Якщо вам подобається системне адміністрування або ви зацікавлені в цьому
вивчаючи його, віртуальні або виділені сервери дають вам повний контроль
виробниче середовище вашої програми.

### nginx і PHP-FPM

PHP за допомогою вбудованого в PHP диспетчера процесів FastCGI (FPM) дійсно підходить
чудово з [nginx](https://nginx.org/), який є легким,
високопродуктивний веб-сервер. Він використовує менше пам'яті, ніж Apache, і може
краще обробляти більше одночасних запитів. Це особливо важливо на
віртуальні сервери, які не мають багато вільної пам’яті.

- [Докладніше про nginx](https://nginx.org/)
- [Докладніше про PHP-FPM](https://secure.php.net/install.fpm)
- [Докладніше про налаштування nginx і PHP-FPM
  безпечно](https://nealpoole.com/blog/2011/04/setting-up-php-fastcgi-and-nginx-dont-trust-the-tutorials-check-your-configuration/)

### Apache і PHP

PHP і Apache мають довгу спільну історію. Апач дико
настроюється і має багато доступних
[модулі](https://httpd.apache.org/docs/2.4/mod/) для розширення
функціональність. Це популярний вибір для спільних серверів і простий
налаштування фреймворків PHP і програм з відкритим кодом, таких як WordPress.

не може обслуговувати стільки відвідувачів одночасно.

Apache має кілька можливих конфігурацій для запуску PHP. Найбільший
поширеним і найлегшим для налаштування є [prefork
MPM](https://httpd.apache.org/docs/2.4/mod/prefork.html) з mod_php5.
Хоча це не найефективніший спосіб використання пам’яті, його найпростіше отримати
працює та користується. Це, мабуть, найкращий вибір, якщо ви не хочете
надто глибоко копатися в аспектах адміністрування сервера. Зверніть увагу, якщо
ви використовуєте mod_php5, ви ПОВИННІ використовувати prefork MPM.

Крім того, якщо ви хочете вичавити більше продуктивності та стабільності
Apache, тоді ви можете скористатися тією ж системою FPM, що й nginx
і запустіть [worker
MPM](https://httpd.apache.org/docs/2.4/mod/worker.html) або [подія
MPM](https://httpd.apache.org/docs/2.4/mod/event.html) з mod_fastcgi
або mod_fcgid. У такій конфігурації буде значно більше пам'яті
ефективнішим і набагато швидшим, але його налаштування вимагає більше роботи.

Якщо ви використовуєте Apache 2.4 або новішої версії, ви можете використовувати

щоб отримати чудову продуктивність, яку легко налаштувати.

- [Докладніше про Apache](https://httpd.apache.org/)
- [Докладніше про багатопроцесорність
  Модулі](https://httpd.apache.org/docs/2.4/mod/mpm_common.html)
- [Докладніше про
  mod_fastcgi](https://blogs.oracle.com/opal/entry/php_fpm_fastcgi_process_manager)
- [Докладніше про mod_fcgid](hhttps://httpd.apache.org/mod_fcgid/)
- [Докладніше про
  mod_proxy_fcgi](https://httpd.apache.org/docs/current/mod/mod_proxy_fcgi.html)
- [Докладніше про налаштування Apache і PHP-FPM за допомогою
  mod_proxy_fcgi](https://serversforhackers.com/video/apache-and-php-fpm)

## <a name="shared_servers"></a> Спільні сервери

PHP має спільні сервери, щоб подякувати за свою популярність. Важко знайти a
хост без інстальованого PHP, але переконайтеся, що це остання версія. Спільний доступ
сервери дозволяють вам та іншим розробникам розгортати веб-сайти на одному
машина. Перевагою цього є те, що він став дешевим товаром. The
Мінусом є те, що ніколи не знаєш, який бунт твій сусід
орендарі збираються створити; завантаження сервера або відкриття
головним занепокоєнням є діри в безпеці. Якщо бюджет вашого проекту може
Ви повинні уникати спільних серверів.

Щоб переконатися, що ваші спільні сервери пропонують найновіші версії
PHP, перевірте [версії PHP](http://phpversions.info/shared-hosting/).

## <a name="building_and_deploying_your_application"></a> Створення та розгортання вашої програми

Якщо ви вручну змінюєте схему бази даних або працюєте
перевірте свої тести вручну, перш ніж оновлювати файли (вручну), подумайте двічі!
З кожним додатковим ручним завданням, необхідним для розгортання нової версії вашого
збільшується ймовірність потенційно фатальних помилок. Незалежно від того, чи є ви
що стосується простого оновлення, комплексного процесу збирання або навіть a
стратегія безперервної інтеграції, [буд
automation](https://wikipedia.org/wiki/Build_automation) — ваш друг.

Серед завдань, які ви можете автоматизувати, є:

- Управління залежностями
- Компіляція, мінімізація ваших активів
- Виконання тестів
- Створення документації
- Упаковка
- Розгортання

### Інструменти розгортання

Інструменти розгортання можна описати як набір сценаріїв, які обробляють
типові завдання розгортання програмного забезпечення. Інструмент розгортання не є частиною
вашого програмного забезпечення, воно діє на ваше програмне забезпечення «зовні».

Існує багато інструментів з відкритим кодом, які допоможуть вам створити
автоматизації та розгортання, деякі написані на PHP, інші ні. Це
не повинні утримувати вас від їх використання, якщо вони краще підходять для
конкретну роботу. Ось кілька прикладів:

[Phing](https://www.phing.info/) може контролювати ваше пакування, розгортання

на [Apache Ant](https://ant.apache.org/)) надає багатий набір завдань
зазвичай необхідний для встановлення або оновлення веб-програми і може бути
розширено додатковими спеціальними завданнями, написаними на PHP. Це твердий і
надійний інструмент і існує протягом тривалого часу, однак інструмент міг
сприйматися як трохи старомодний через те, як це стосується
конфігурації (файли XML).

[Capistrano](http://capistranorb.com/) — це система для
_програмісти середнього та просунутого рівня_ для виконання команд у a
структурований повторюваний спосіб на одній або кількох віддалених машинах. це є
попередньо налаштований для розгортання програм Ruby on Rails, однак ви можете
успішно розгортати з ним системи PHP. Успішне використання Capistrano
залежить від робочого знання Ruby та Rake.

[Ansistrano](https://ansistrano.com) — це кілька ролей Ansible
легко керувати процесом розгортання (розгортання та відкат) для сценаріїв
такі програми, як PHP, Python і Ruby. Це порт Ansible для
[Капістрано](http://capistranorb.com/). Його використовувало досить багато
PHP компанії вже.

[Rocketeer](http://rocketeer.autopergamene.eu/) отримує натхнення та
філософія з фреймворку Laravel. Його мета - бути швидким, елегантним
і простий у використанні з інтелектуальними параметрами за замовчуванням. Він містить кілька серверів,

паралельний. Усе в інструменті можна гарячо замінити або розширити, а також
все написано на PHP.

[Deployer](https://deployer.org/) - це інструмент розгортання, написаний на PHP.
Це просто і функціонально. Функції включають виконання завдань паралельно,
атомарне розгортання та збереження узгодженості між серверами. Рецепти з
доступні типові завдання для Symfony, Laravel, Zend Framework і Yii.
Стаття Юнеса Рафі [Просте розгортання додатків PHP за допомогою
Deployer](https://www.sitepoint.com/deploying-php-applications-with-deployer/)
це чудовий посібник із розгортання вашої програми за допомогою інструменту.

[Magallanes](https://www.magephp.com/) — ще один інструмент, написаний на PHP
із простою конфігурацією у файлах YAML. Він має підтримку для
кілька серверів і середовищ, атомарне розгортання та деякі вбудовані
у завданнях, які можна використовувати для звичайних інструментів і фреймворків.

#### Подальше читання:

- [Автоматизуйте свій проект за допомогою Apache
  Ant](https://code.tutsplus.com/tutorials/automate-your-projects-with-apache-ant--net-18595)
- [Розгортання PHP
  Програми](https://deployingphpapplications.com/) - платна книга на
  найкращі практики та інструменти для розгортання PHP.

### Підготовка сервера

багато серверів. Існують інструменти для вирішення цього, щоб ви могли автоматизувати
вашої інфраструктури, щоб переконатися, що у вас є правильні сервери
вони правильно налаштовані. Вони часто інтегруються з великою хмарою
хостинг-провайдерів (Amazon Web Services, Heroku, DigitalOcean тощо) для
керування екземплярами, що значно полегшує масштабування програми.

[Ansible](https://www.ansible.com/) - це інструмент, який керує вашими
інфраструктури через файли YAML. Почати роботу з і легко
може керувати складними та великомасштабними програмами. Є API для
керування хмарними примірниками, і він може керувати ними за допомогою динамічного
інвентаризація за допомогою певних інструментів.

[Puppet](https://puppet.com/) - це інструмент, який має власну мову та
типи файлів для керування серверами та конфігураціями. Його можна використовувати в a
майстер/клієнт, або його можна використовувати в режимі «без головного». В
у режимі головний/клієнт клієнти опитуватимуть центрального головного(-их) для нового
конфігурацію через встановлені інтервали та оновлювати себе, якщо необхідно. В
У режимі без майстра ви можете надсилати зміни до своїх вузлів.

[Chef](https://www.chef.io/) — це потужна системна інтеграція на основі Ruby
фреймворк, за допомогою якого можна побудувати ціле серверне середовище або віртуальне
ящики с. Він добре інтегрується з Amazon Web Services через їх
служба під назвою OpsWorks.

#### Подальше читання:

- [Анзибль
  Підручник](https://serversforhackers.com/an-ansible-tutorial)

- [Ansible for DevOps](https://leanpub.com/ansible-for-devops) - платно
  книга про все Ансібл
- [Ansible для AWS](https://leanpub.com/ansible-for-aws) - платна книга
  про інтеграцію Ansible і Amazon Web Services
- [Серія блогів із трьох частин про розгортання програми LAMP за допомогою
  Кухар, Волоцюга, і
  EC2](http://www.jasongrimes.org/2012/06/managing-lamp-environments-with-chef-vagrant-and-ec2-1-of-3/)
- [Chef Cookbook, який встановлює та налаштовує PHP і PEAR
  система керування пакетами](https://github.com/chef-cookbooks/php)
- [Відеоурок шеф-кухаря
  серіал](https://www.youtube.com/playlist?list=PL11cZfNdwNyPnZA9D1MbVqldGuOWqbumZ)

### Постійна інтеграція

Безперервна інтеграція - це практика розробки програмного забезпечення, де
члени команди часто об’єднують свою роботу, зазвичай кожна особа
інтегрується принаймні щодня, що призводить до кількох інтеграцій на день.
Багато команд виявляють, що такий підхід призводить до значного зниження
проблеми інтеграції та дозволяє команді розробляти згуртоване програмне забезпечення
швидше.

_- Мартін Фаулер_

Існують різні способи реалізації постійної інтеграції для PHP.
[Travis CI](https://travis-ci.org/) чудово попрацював над створенням
постійна інтеграція - реальність навіть для невеликих проектів. Тревіс К.І
розміщено безперервну службу інтеграції для спільноти з відкритим кодом. Це
інтегровано з GitHub і пропонує першокласну підтримку для багатьох
мови, включаючи PHP.

#### Подальше читання:

- [Постійна інтеграція з Jenkins](https://jenkins.io/)
  - [Безперервна інтеграція с
    PHPCI](https://github.com/dancryer/phpci)
- [Постійна інтеграція з PHP
  Цензор](https://github.com/php-censor/php-censor)
  - [Безперервна інтеграція с
    Teamcity](https://www.jetbrains.com/teamcity/)

[На початок](#top)

# <a name="virtualization"></a> Віртуалізація

Запуск вашої програми в різних середовищах у розробці та
виробництво може призвести до появи дивних помилок, коли ви виходите в прямому ефірі. Його
також складно підтримувати різні середовища розробки в актуальному стані
однакова версія для всіх бібліотек, які використовуються під час роботи з командою
розробників.

Якщо ви розробляєте в Windows і розгортаєте в Linux (або щось інше
не-Windows) або розробляєте в команді, вам слід розглянути можливість використання a
віртуальна машина. Це звучить хитро, але до того ж широко відомо
існують такі середовища віртуалізації, як VMware або VirtualBox
додаткові інструменти, які можуть допомогти вам налаштувати віртуальне середовище в a
кілька простих кроків.

## <a name="vagrant"></a> Vagrant

[Vagrant](https://www.vagrantup.com/) допомагає вам створювати віртуальні коробки
поверх відомих віртуальних середовищ і налаштує їх
середовища на основі одного файлу конфігурації. Ці ящики можуть бути
налаштувати вручну, або ви можете використовувати програмне забезпечення для «ініціалізації», наприклад
[Puppet](https://puppet.com/) або [Chef](https://www.chef.io/), щоб це зробити
для вас. Ініціалізація базової коробки є чудовим способом забезпечити це
кілька ящиків налаштовано однаковим чином і усуває потребу
щоб ви могли підтримувати складні списки команд «налаштування». Ви також можете
«знищити» вашу базову коробку та відтворити її без численних кроків вручну,
що полегшує створення «свіжої» установки.

Vagrant створює папки для обміну кодом між хостом і вашим
віртуальна машина, що означає, що ви можете створювати та редагувати свої файли
вашій хост-машині, а потім запустіть код у вашій віртуальній машині.

### Трохи допомоги

Якщо вам потрібна невелика допомога, щоб почати користуватися Vagrant, є кілька послуг
це може бути корисним:

- [Puphpet](https://github.com/puphpet/puphpet): простий графічний інтерфейс для налаштування
  віртуальні машини для розробки PHP. **Зосереджений на PHP**.
  Крім локальних віртуальних машин, його можна використовувати для розгортання в хмарних службах як
  Ну. Підготовка здійснюється за допомогою Puppet.
- [Phansible](http://phansible.com/): простий у використанні
  інтерфейс, який допомагає створювати Ansible Playbooks для PHP на основі
  проекти.

## <a name="docker"></a> Докер

[Docker](https://www.docker.com/) - легка альтернатива повному
віртуальна машина - називається так тому, що це все про «контейнери». А
контейнер — це будівельний блок, який у найпростішому випадку виконує один
конкретна робота, напр. запуск веб-сервера. «Зображення» — це ваш пакет
використовуйте для створення контейнера - у Docker є їх повне сховище.

Типова програма LAMP може мати три контейнери: веб-сервер, a
Процес PHP-FPM і MySQL. Як і у випадку зі спільними папками у Vagrant, ви можете
залиште файли програми там, де вони є, і вкажіть Docker, куди
знайди їх.

Ви можете створити контейнери з командного рядка (див. приклад нижче)
або, для зручності обслуговування, створіть файл `docker-compose.yml` для свого
проект із зазначенням того, який створити та як з ним спілкуватися
інший.

Docker може допомогти, якщо ви розробляєте кілька веб-сайтів і хочете
поділ, який виникає внаслідок встановлення кожного на власну віртуальну машину,
але немає необхідного місця на диску або часу, щоб зберегти все
в актуальному стані. Це ефективно: встановлення та завантаження відбуваються швидше,
вам потрібно лише зберігати одну копію кожного зображення, незалежно від того, як часто воно використовується,
контейнери потребують менше оперативної пам’яті та використовують те саме ядро ОС, тому ви можете мати
більше серверів, що працюють одночасно, і це займає лічені секунди
зупиняйте та запускайте їх, не потрібно чекати повного завантаження сервера.

### Приклад: запуск PHP-додатків у Docker

Після [встановлення докера](https://docs.docker.com/install/) на вашому
Ви можете запустити веб-сервер однією командою. Наступна воля
завантажте повнофункціональну установку Apache з останньою версією PHP
версії, зіставте `/path/to/your/php/files` з коренем документа, який ви
можна переглянути на `http://localhost:8080`:

```sh
docker run -d --name my-php-webserver -p 8080:80 -v /path/to/your/php/files:/var/www/html/ php:apache
```

Це ініціалізує та запустить ваш контейнер. `-d` змушує його працювати
фон. Щоб зупинити і почати його, просто біжіть
`docker stop my-php-webserver` і `docker start my-php-webserver` (докер
інші параметри знову не потрібні).

### Дізнайтеся більше про Docker

Наведена вище команда показує швидкий спосіб запуску базового сервера. Є багато
більше, що ви можете зробити (і тисячі попередньо створених зображень у [Docker
Hub](https://hub.docker.com/)). Знайдіть час, щоб вивчити термінологію та
прочитайте [Посібник користувача Docker](https://docs.docker.com/), щоб отримати максимум
з нього та не запускайте випадковий код, який ви завантажили без перевірки
це безпечно - неофіційні зображення можуть не мати останніх патчів безпеки.
Якщо ви сумніваєтеся, дотримуйтеся [офіційного
репозиторії](https://hub.docker.com/explore/).

Сайт [PHPDocker.io](https://phpdocker.io/generator) буде
автоматично створювати всі файли, необхідні для повнофункціонального LAMP/LEMP
стек, включаючи версію PHP і розширення на ваш вибір.

- [Веб-сайт Docker](https://www.docker.com/)
- [Встановлення Docker](https://docs.docker.com/install/)
- [Посібник користувача Docker](https://docs.docker.com/)
- [Docker Hub](https://hub.docker.com/)
- [Docker Hub - офіційні зображення](https://hub.docker.com/explore/)

[На початок](#top)

# <a name="cache"></a> Кешування

PHP досить швидкий сам по собі, але під час створення можуть виникати вузькі місця
віддалені підключення, завантаження файлів тощо. На щастя, існують різні інструменти
доступні для прискорення певних частин програми або зменшення
скільки разів потрібно виконати ці різноманітні трудомісткі завдання.

## <a name="opcode_cache"></a> Opcode Кеш

Коли файл PHP виконується, його потрібно спочатку скомпілювати
[коди операцій](https://secure.php.net/manual/internals2.opcodes.php) (машина
мовні інструкції для ЦП). Якщо вихідний код не змінено,
коди операцій будуть однаковими, тому цей крок компіляції стає марною тратою
ресурси ЦП.

Кеш кодів операцій запобігає надлишковій компіляції, зберігаючи коди операцій
пам’яті та повторного використання їх під час послідовних викликів. Зазвичай це перевіряє
спочатку підпис або час модифікації файлу, якщо є
були якісь зміни.

Цілком ймовірно, що кеш коду операції значно підвищить швидкість
ваша заявка. Починаючи з PHP 5.5, є один вбудований - [Zend
OPcache](https://secure.php.net/book.opcache). Залежно від вашого PHP
пакет/дистрибутив, зазвичай увімкнено за замовчуванням - перевірте
[opcache.enable](https://secure.php.net/manual/opcache.configuration.php#ini.opcache.enable)
і результат `phpinfo()`, щоб переконатися. Для попередніх версій є
розширення PECL.

Докладніше про кеші кодів операцій:

- [Zend OPcache](https://secure.php.net/book.opcache) (у комплекті з
  PHP з 5.5)
- Zend OPcache (раніше відомий як Zend Optimizer+) тепер [відкритий
  джерело](https://github.com/zendtech/ZendOptimizerPlus)
- [APC](https://www.php.net/book.apcu) - PHP 5.4 і раніше
- [XCache](https://xcache.lighttpd.net/)
- [WinCache](https://www.iis.net/downloads/microsoft/wincache-extension)
  (розширення для MS Windows Server)
- [список прискорювачів PHP на
  Вікіпедія](https://wikipedia.org/wiki/List_of_PHP_accelerators)
- [Попереднє завантаження PHP](https://www.php.net/opcache.preloading) - PHP \>=
  7.4

## Кешування об'єктів

Бувають випадки, коли може бути корисним кешувати окремі об’єкти
ваш код, наприклад, з даними, які дорого отримати, або викликами бази даних
де результат навряд чи зміниться. Ви можете використовувати кешування об'єктів
програмне забезпечення для надзвичайно швидкого зберігання цих фрагментів даних у пам’яті
доступ пізніше. Якщо ви збережете ці елементи в сховищі даних після того, як ви
відновіть їх, потім витягніть їх безпосередньо з кешу для подальшого перегляду
запитів, ви також можете значно покращити продуктивність
щоб зменшити навантаження на сервери бази даних.

Багато популярних рішень для кешування байт-коду дозволяють кешувати власні дані
а також, тому є ще більше причин скористатися ними. APCu,
XCache і WinCache надають API для збереження даних із вашого PHP-коду
кеш пам'яті.

Найбільш часто використовуваними системами кешування об'єктів пам'яті є APCu і
memcached. APCu є чудовим вибором для кешування об’єктів, він включає a
простий API для додавання ваших власних даних до кешу пам’яті та дуже простий
налаштувати та використовувати. Єдине реальне обмеження APCu полягає в тому, що він прив’язаний до
сервер, на якому він встановлений. З іншого боку встановлено Memcached
як окрему службу, до якої можна отримати доступ через мережу, тобто
що ви можете зберігати об’єкти в надшвидкісному сховищі даних у центральному
місцезнаходження та багато різних систем можуть витягти з нього.

Зауважте, що під час запуску PHP як програми (Fast-)CGI у вашому
веб-сервер, кожен процес PHP матиме власний кеш, тобто дані APCu
не розподіляється між вашими робочими процесами. У цих випадках вам може знадобитися
розглянути можливість використання memcached натомість, оскільки він не прив’язаний до PHP
процеси.

У мережевій конфігурації APCu зазвичай перевершує memcached in
з точки зору швидкості доступу, але memcached зможе швидше масштабуватися та
далі. Якщо ви не очікуєте мати кілька серверів, на яких буде працювати ваш
або не потребує додаткових функцій, які пропонує memcached
тоді APCu, мабуть, найкращий вибір для кешування об’єктів.

Приклад логіки використання APCu:

```php
<?php
// перевірити, чи є дані, збережені як 'expensive_data' в кеші
$data = apc_fetch('expensive_data');
if ($data === false) {
// даних немає в кеші; зберегти результат дорогого дзвінка для подальшого використання
apc_add('expensive_data', $data = get_expensive_data());
}

print_r($дані);
```

Зауважте, що до PHP 5.5 APC надає як кеш об’єктів, так і a
кеш байт-коду. APCu — це проект перенесення кешу об’єктів APC у PHP
5.5+, оскільки PHP тепер має вбудований кеш байт-кодів (OPcache).

### Дізнайтеся більше про популярні системи кешування об'єктів:

- [APCu](https://github.com/krakjoe/apcu)
- [Функції APC](https://secure.php.net/ref.apc)
- [Memcached](https://memcached.org/)
- [Redis](https://redis.io/)
- [API XCache](https://xcache.lighttpd.net/wiki/XcacheApi)
- [Функції WinCache](https://secure.php.net/ref.wincache)

[На початок](#top)

# <a name="documenting"></a> Документування вашого коду

## <a name="phpdoc"></a> PHPDoc

PHPDoc — це неформальний стандарт для коментування коду PHP. Є
_багато_ різних
[тегів](https://docs.phpdoc.org/latest/guide/references/phpdoc/tags/index.html)
. Повний список тегів і приклади можна знайти у
[Посібнику PHPDoc](https://docs.phpdoc.org/latest/index.html).

Нижче наведено приклад того, як можна задокументувати клас із кількома
методи;

```php
<?php
/**
* @author A Name <a.name@example.com>
* @link http://www.phpdoc.org/docs/latest/index.html
*/
клас DateTimeHelper
{
/**
* @param змішав $anything Все, що ми можемо перетворити на об’єкт \DateTime
*
* @throws \InvalidArgumentException
*
* @return \DateTime
*/
public function dateTimeFromAnything($anything)
{
$type = gettype($anything);

перемикач ($type) {
// Деякий код, який намагається повернути об'єкт \DateTime
}

створити новий \InvalidArgumentException(
«Помилка перетворення параметра типу '{$type}' в об'єкт DateTime»
);
}

/**
* @param mixed $date Усе, що ми можемо перетворити на об’єкт \DateTime
*
* @return void
*/
public function printISO8601Date($date)
{
echo $this->dateTimeFromAnything($date)->format('c');
}

/**
* @param mixed $date Усе, що ми можемо перетворити на об’єкт \DateTime
*/
public function printRFC2822Date($date)
{
echo $this->dateTimeFromAnything($date)->format('r');
}
}
```

Документація по класу в цілому має свою
[@author](https://docs.phpdoc.org/latest/guide/references/phpdoc/tags/author.html)
тег і a
[@link](https://docs.phpdoc.org/latest/guide/references/phpdoc/tags/link.html)
тег. The
[@author](https://docs.phpdoc.org/latest/guide/references/phpdoc/tags/author.html)
тег використовується для документування автора коду та може повторюватися для
документування кількох авторів. The
[@link](https://docs.phpdoc.org/latest/guide/references/phpdoc/tags/link.html)
тег використовується для посилання на веб-сайт, що вказує на зв’язок між
веб-сайт і код.

Усередині класу перший метод має a
[@param](https://docs.phpdoc.org/latest/guide/references/phpdoc/tags/param.html)
тег, що документує тип, назву та опис параметра
перейшов до методу. Крім того, він має
[@return](https://docs.phpdoc.org/latest/guide/references/phpdoc/tags/return.html)
і
[@throws](https://docs.phpdoc.org/latest/guide/references/phpdoc/tags/throws.html)
теги для документування типу повернення та будь-яких винятків, які можуть бути
кинуті відповідно.

Другий і третій способи дуже схожі і мають єдине
[@param](https://docs.phpdoc.org/latest/guide/references/phpdoc/tags/param.html)
тег, як і перший метод. Важлива відмінність другої
і блок документів третього методу - це включення/виключення
[@return](https://docs.phpdoc.org/latest/guide/references/phpdoc/tags/return.html)
тег. `@return void` явно повідомляє нам, що повернення не відбувається;
історичне пропускання оператора `@return void` також призводить до
така сама (без повернення) дія.

[На початок](#top)

# <a name="resources"></a> Ресурси

## Від Джерела

- [веб-сайт PHP](https://secure.php.net/)
- [Документація PHP](https://secure.php.net/docs.php)

## <a name="people_to_follow"></a> Люди, на яких варто підписатись

Важко знайти цікаву та обізнану спільноту PHP
членів, коли ви тільки починаєте. Можна знайти скорочений
список членів PHP-спільноти для початку:

- <https://www.ogprogrammer.com/2017/06/28/how-to-get-connected-with-the-php-community/>
- <https://twitter.com/CalEvans/lists/phpeople>

## <a name="php_paas_providers"></a> Постачальники PHP PaaS

- [AppFog](https://www.ctl.io/appfog/)
- [Amezmo](https://www.amezmo.com)
- [AWS Elastic Beanstalk](https://aws.amazon.com/elasticbeanstalk/)
- [Cloudways](https://www.cloudways.com/)
- [Divio](https://www.divio.com/php/)
- [Engine Yard Cloud](https://www.engineyard.com/features)
- [fortrabbit](https://www.fortrabbit.com/)
- [Google App Engine](https://cloud.google.com/appengine/docs/php/)
- [Heroku](https://devcenter.heroku.com/categories/php-support)
- [IBM
  Cloud](https://console.bluemix.net/docs/runtimes/php/getting-started.html#getting_started)
- [Jelastic](https://jelastic.com/)
- [Microsoft Azure](https://azure.microsoft.com/)
- [Nanobox](https://nanobox.io/)
- [Основні веб-служби](https://run.pivotal.io/)
- [Platform.sh](https://platform.sh/)
- [Red Hat OpenShift](https://www.openshift.com/)

Щоб дізнатися, які версії працюють на цих хостах PaaS, перейдіть до [PHP
Версії](http://phpversions.info/paas-hosting/).

## <a name="frameworks"></a> Frameworks

Замість того, щоб заново винаходити колесо, багато розробників PHP використовують фреймворки
створювати веб-додатки. Фреймворки абстрагують багато з них
проблеми низького рівня та надати корисні, прості у використанні інтерфейси для
виконувати спільні завдання.

Вам не потрібно використовувати фреймворк для кожного проекту. Іноді простий
PHP — це правильний шлях, але якщо вам потрібна фреймворк, то тут
доступні три основні типи:

- Мікрофреймворки
- Full-Stack Frameworks
- Компонентні рамки

зворотний виклик, контролер, метод тощо якомога швидше, а іноді
постачаються з кількома додатковими бібліотеками для сприяння розробці, наприклад базовою
оболонки бази даних тощо. Вони переважно використовуються для будівництва
віддалені служби HTTP.

Багато фреймворків додають значну кількість функцій на додаток до того, що є
доступний у мікрофреймворку; вони називаються Full-Stack Frameworks.
Вони часто постачаються в комплекті з ORM, пакетами автентифікації тощо.

Компонентні фреймворки — це колекції спеціалізованих і
одноцільові бібліотеки. Можуть бути різні фреймворки на основі компонентів
використовуються разом для створення мікро- або повного стеку.

## <a name="components"></a> Компоненти

Як згадувалося вище, «Компоненти» є іншим підходом до спільної мети
створення, розповсюдження та впровадження спільного коду. різноманітні
існують сховища компонентів, два основних з яких:

- [Packagist](#composer_and_packagist)
- [PEAR](#pear)

Обидва ці сховища мають пов’язані з ними інструменти командного рядка
щоб допомогти процесам інсталяції та оновлення, і були пояснені
докладніше в розділі [Керування залежностями](#dependency_management)
розділ.

Існують також фреймворки на основі компонентів і постачальники компонентів
взагалі не пропонують рамок. Ці проекти є ще одним джерелом
пакети, які в ідеалі практично не залежать від інших пакетів,
або конкретні рамки.

Наприклад, ви можете використовувати [Перевірка FuelPHP
пакет](https://github.com/fuelphp/validation), без необхідності використання
сама структура FuelPHP.

- [Аура](http://auraphp.com/framework/)
- Компоненти CakePHP
- [Колекція](https://github.com/cakephp/collection)
- [База даних](https://github.com/cakephp/database)
- [Джерело даних](https://github.com/cakephp/datasource)
- [Подія](https://github.com/cakephp/event)
- [I18n](https://github.com/cakephp/i18n)
- [ORM](https://github.com/cakephp/orm)
- [FuelPHP](https://github.com/fuelphp)
- [Проект Hoa](https://github.com/hoaproject)
- [Symfony Компоненти](https://symfony.com/doc/current/components/index.html)
- [Ліга екстраординарних пакетів](https://thephpleague.com/)
- Компоненти illuminate Laravel
- [IoC Container](https://github.com/illuminate/container)
- [Eloquent ORM](https://github.com/illuminate/database)
- [Queue](https://github.com/illuminate/queue)

* [Компоненти Illuminate](https://github.com/illuminate) Laravel ставатимуть краще відокремленими від структури Laravel. Наразі лише компоненти, найкраще відокремлені від інфраструктури Laravel, перераховані вище.\*

## <a name="other_resources"></a> Інші корисні ресурси

### Шпаргалки

- [PHP Cheatsheets](http://phpcheatsheets.com/) - для змінної
  порівнянь, арифметики та тестування змінних у різних PHP
  версії.
  - [Сучасний PHP
    Шпаргалка](https://github.com/smknstd/modern-php-cheatsheet)
    документує сучасні (PHP 7.0+) ідіоми в єдиному документі.
- [Безпека OWASP
  Шпаргалки](https://www.owasp.org/index.php/OWASP_Cheat_Sheet_Series) -
  надає стислу колекцію високоцінної інформації про конкретні
  теми безпеки програми.

### Більше найкращих практик

- [Найкращі практики PHP](https://phpbestpractices.org/)
- [Чому вам слід використовувати підтримуваний PHP
  Версії](https://kinsta.com/blog/php-versions/)

### Новини навколо спільнот PHP і веб-розробників

Ви можете підписатися на щотижневі інформаційні бюлетені, щоб бути в курсі новинок
бібліотеки, останні новини, події та загальні оголошення, а також
час від часу публікуються додаткові ресурси:

- [PHP Weekly](http://www.phpweekly.com)
- [Щотижневий JavaScript](https://javascriptweekly.com/)
- [Frontend Focus](https://frontendfoc.us/)
- [Mobile Web Weekly](https://mobiledevweekly.com/)

Є також тижневики на інших платформах, які можуть вас зацікавити;
ось [список деяких](https://github.com/jondot/awesome-weekly).

### всесвіт PHP

- [Блог розробника PHP](https://blog.phpdeveloper.org/)

## <a name="videos"></a> Відеоуроки

### Канали YouTube

- [Академія PHP](https://www.youtube.com/user/phpacademy)
- [Новий Бостон](https://www.youtube.com/user/thenewboston)
- [Шериф Рамадан](https://www.youtube.com/user/businessgeek)
- [Level Up Tuts](https://www.youtube.com/user/LevelUpTuts)

### Платні відео

- [Стандарти і найкраще практики](https://teamtreehouse.com/library/php-standards-and-best-practices)
- [Тренінг PHP на Pluralsight](https://www.pluralsight.com/search?q=php)
- [Навчання PHP на Lynda.com](https://www.lynda.com/search?q=php)
- [Тренінг PHP на Tutsplus](https://code.tutsplus.com/categories/php/courses)
- [Laracasts](https://laracasts.com/)

## <a name="books"></a> Книги

Існує багато книг про PHP; на жаль, деякі зараз досить старі й уже не
точні. Зокрема, уникайте книг про «PHP 6», версію, яка тепер буде
ніколи не існує. Наступним великим випуском PHP після 5.6 був “PHP 7”,
[частково через це](https://wiki.php.net/rfc/php6).

Цей розділ має бути живим документом для рекомендованих книг з PHP
розвитку в цілому. Якщо ви хочете, щоб ваша книга була додана, надішліть a
PR і буде перевірено на відповідність.

### Безкоштовні книги

- [PHP Pandas](http://daylerees.com/php-pandas/) - Має на меті навчати
  кожен як стати веб-розробником.
- [Правильний шлях PHP](https://leanpub.com/phptherightway/) - Це
  веб-сайт доступний у вигляді книги повністю безкоштовно.
- [Використання Libsodium у PHP
  Проекти](https://paragonie.com/book/pecl-libsodium) - Посібник до
  використання розширення PHP Libsodium для сучасного, безпечного та швидкого
  криптографія.

### Платні книги

- [Створення API, які ви не будете ненавидіти](https://apisyouwonthate.com/) - Усі
  і їхній собакі потрібен API, тож вам, ймовірно, варто навчитися
  будувати їх.
- [Сучасний PHP](http://shop.oreilly.com/product/0636920033868.do) -
  охоплює сучасні функції PHP, найкращі практики, тестування, налаштування,
  розгортання та налаштування середовища розробника.
- [Створення безпечного PHP
  Програми](https://leanpub.com/buildingsecurephpapps) - Дізнайтеся
  основи безпеки, які старший розробник зазвичай здобуває роками
  досвіду, зібраного в одному швидкому та легкому посібнику
- [Модернізація застарілих програм у
  PHP](https://leanpub.com/mlaphp) - Керуйте своїм кодом у a
  ряд маленьких, конкретних кроків
- [Захист PHP: ядро
  Концепції](https://leanpub.com/securingphp-coreconcepts) - посібник із
  деякі з найпоширеніших термінів безпеки та наводить кілька прикладів

- [Масштабування PHP](http://www.scalingphpbook.com/) - Зупиніть гру
  системного адміністратора та поверніться до кодування
- [Сигналізація PHP](https://leanpub.com/signalingphp) - Сигнали PCNLT
  є великою підмогою під час написання сценаріїв PHP, які запускаються з команди
  лінія.
- [Мінімально життєздатні тести](https://leanpub.com/minimumviabletests) -
  Багаторічний проповідник тестування PHP Кріс Хартьєс розповідає про те, що він
  почуття — це мінімум, який вам потрібно знати, щоб почати.
- [Дизайн на основі домену в PHP](https://leanpub.com/ddd-in-php) - Див.
  реальні приклади, написані на PHP, що демонструють доменно-керований дизайн
  Архітектурні стилі (гексагональна архітектура, CQRS або Event
  Sourcing), тактичні шаблони проектування та обмежений контекст
  Інтеграція.

[На початок](#top)

# <a name="community"> Спільнота

Спільнота PHP така ж різноманітна, як і велика, і її члени є такими ж
готовий і готовий підтримувати нових PHP-програмістів. Розгляньте можливість приєднатися до вашого
локальна група користувачів PHP (PUG) або відвідування більших конференцій PHP для навчання
докладніше про найкращі практики тут. Ви можете туситися на IRC в

[irc.freenode.com](https://webchat.freenode.net/?channels=phpc) і
підпишіться на обліковий запис у Twitter [@phpc](https://twitter.com/phpc). Забирайся
там познайомтеся з новими розробниками, вивчіть нові теми та, перш за все, створіть нове
друзі! Інші ресурси спільноти включають
[StackOverflow](https://stackoverflow.com/questions/tagged/php).

[Ознайомтеся з офіційним календарем подій PHP](https://secure.php.net/cal.php)

## <a name="user_groups"></a> Групи користувачів PHP

Якщо ви живете у великому місті, швидше за все, поблизу є група користувачів PHP.
Ви можете легко знайти свого місцевого МОПСА на [PHP.ug](https://php.ug/).
Альтернативними джерелами можуть бути [Meetup.com](https://www.meetup.com/find/) або
здійсніть пошук `php user group near me` за допомогою вашої улюбленої пошукової системи
(тобто [Google](https://www.google.com/search?q=php+user+group+near+me)).
Якщо ви живете в меншому місті, там може не бути місцевого МОПСА; якщо це
справа, почніть одну!

Окремо варто відзначити дві глобальні групи користувачів:
[NomadPHP](https://nomadphp.com/) і
[PHPWomen](https://twitter.com/PHPWomen).
[NomadPHP](https://nomadphp.com/) пропонує онлайн-групу користувачів двічі на місяць
зустрічі з презентаціями деяких найкращих доповідачів PHP
громада. [PHPWomen](https://twitter.com/PHPWomen) є неексклюзивним
група користувачів, спочатку націлена на жінок у світі PHP.
Членство відкрите для всіх, хто підтримує більш різноманітну спільноту.
PHPWomen надають мережу підтримки, наставництва та навчання, а також
загалом сприяти створенню «дружнього до жінок» і професійного
атмосфера.

[Прочитайте про групи користувачів на PHP
Wiki](https://wiki.php.net/usergroups)

## <a name="conferences"></a> Конференції PHP

Спільнота PHP також проводить більші регіональні та національні конференції в
багато країн світу. Відомі члени спільноти PHP
зазвичай виступають на таких великих заходах, тож це чудова можливість
навчайтеся безпосередньо у лідерів галузі.

[Знайти конференцію PHP](https://secure.php.net/conferences/index.php)

## <a name="elephpants"></a> ElePHPants

[ElePHPant](https://secure.php.net/elephpant.php) такий гарний
талісман проекту PHP зі слоном у своєму дизайні. Це було
спочатку розроблений для проекту PHP у 1998 році [Vincent
Pontier](http://www.elroubio.net/) - духовний отець тисяч
elePHPants у всьому світі та 10 років потому чарівний плюшевий слоник
іграшка теж народилася. Зараз elePHPants присутні в багатьох PHP
конференції та з багатьма розробниками PHP за комп’ютерами для розваги та
натхнення.

## <a name="creds"></a> Створено та підтримується

- [Джош Локхарт](https://joshlockhart.com)
- [Філ Стерджен](https://philsturgeon.uk/)
- [Демонструвати
  Учасники](https://github.com/codeguy/php-the-right-way/graphs/contributors)

PHP: правильний шлях, [Джош Локхарт](https://joshlockhart.com)
ліцензується
[Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported Ліцензія](https://creativecommons.org/licenses/by-nc-sa/3.0/).

Переклад: [Ігор Іващенко](linkedin.com/in/lisdev/) в рамках проєкту [php.org.ua](https://php.org.ua)

За мотивами твору в [www.phptherightway.com](https://www.phptherightway.com).
